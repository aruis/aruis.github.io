<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在Apple Silicon上关闭M1的GPU，仅用CPU进行Tensorflow训练</title>
      <link href="/2022/04/18/disable-metal-gpu-on-apple-silicon/"/>
      <url>/2022/04/18/disable-metal-gpu-on-apple-silicon/</url>
      
        <content type="html"><![CDATA[<p>在苹果<code>M1</code>系列芯片上运行<code>tensorflow</code>是可以通过插件<code>tensorflow-metal</code>进行<code>GPU</code>训练加速的，并且随着操作系统的升级以及插件的不断完善，<code>M1</code>的训练性能正在稳步提高，这也是苹果官方推荐的做法。</p><p>不过某些情况下，我们还是需要关闭<code>GPU</code>加速，仅使用<code>CPU</code>进行加速。那么以下这段代码可以帮助你临时禁用<code>GPU</code>，而把训练的压力转移到<code>CPU</code>上来。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">tf<span class="selector-class">.config</span><span class="selector-class">.set_visible_devices</span>(<span class="selector-attr">[]</span>, <span class="string">&#x27;GPU&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过加深网络把CIFAR10的训练精度提升到80%</title>
      <link href="/2022/04/15/cnn-cifar10-try-3-deep/"/>
      <url>/2022/04/15/cnn-cifar10-try-3-deep/</url>
      
        <content type="html"><![CDATA[<p>这次继续，在原来网络的基础上，加深了卷积层的数量，从原来的3层卷积，加深到了6层。核心代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="/media/CleanShot%202022-04-15%20at%2013.52.32.png" alt="CleanShot 2022-04-15 at 13.52.32"></p><p>可以看到验证精度比之前的略好一些。但是程度非常有限，刚刚有接近<code>80%</code>的影子。下面我尝试增加<code>Dropout</code>层：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.2</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.4</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model.add(layers.Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br></pre></td></tr></table></figure><p>在原来的基础上增加了两层<code>Dropout</code>，结果点进一步得到改善：</p><p><img src="/media/CleanShot%202022-04-15%20at%2013.57.20.png" alt="CleanShot 2022-04-15 at 13.57.20"></p><p>已经达到<code>80%</code>的水平了。</p><hr><p>到这之后，我又发现一个自己代码的问题，之前修改代码的时候，去掉了最后卷积层之后的池化层，肯定是不妥的。我现在给加回来：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.2</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.4</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br></pre></td></tr></table></figure><p>重新训练结果如下：</p><p><img src="/media/CleanShot%202022-04-15%20at%2014.22.21.png" alt="CleanShot 2022-04-15 at 14.22.21"></p><p>可以看到验证精度最后都能超过<code>80%</code>。只能说怪我了，卷积层后面不跟池化层的话数据就太大了，用池化层压缩一下，训练效果往往会更好。</p><p>下面我又尝试把<code>Flatten</code>之后的全连接层给去掉，得到了更好的数据：</p><p><img src="/media/CleanShot%202022-04-15%20at%2014.40.38.png" alt="CleanShot 2022-04-15 at 14.40.38"></p><p>训练在<code>12</code>轮之后，验证精度就稳步在<code>80%</code>以上了。<br>最终代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.2</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">128</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.4</span>))</span><br><span class="line"></span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line"></span><br><span class="line">model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;Adam&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">history = model.fit(train_images, train_labels, epochs=<span class="number">50</span>, batch_size=<span class="number">64</span>,validation_data=(test_images, test_labels))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keras </tag>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用简单的CNN训练CIFAR10，理解padding=&#39;same&#39;的含义</title>
      <link href="/2022/04/14/cnn-cifar10-try-2/"/>
      <url>/2022/04/14/cnn-cifar10-try-2/</url>
      
        <content type="html"><![CDATA[<p>今天在训练<code>CIFAR10</code>数据的时候，稍微调整了下网络，对卷积层增加了<code>padding</code>，最终结果得到了一定的改善：</p><p><img src="/media/CleanShot%202022-04-14%20at%2020.05.02.png" alt="CleanShot 2022-04-14 at 20.05.02"></p><p>上图左边，是增加了<code>padding=&#39;same&#39;</code>的结果，右图是<a href="https://www.kankanzhijian.com/2022/04/12/cnn-cifar10/">上一次</a>的模型。可以看到左边的训练精度明显好于右侧。而验证精度也略好于右侧。</p><p>参考<code>keras</code>的文档：</p><blockquote><p><strong>padding</strong>: one of “valid” or “same” (case-insensitive). “valid” means no padding. “same” results in padding with zeros evenly to the left&#x2F;right or up&#x2F;down of the input. When padding&#x3D;”same” and strides&#x3D;1, the output has the same size as the input.</p></blockquote><p><code>padding</code>设置为<code>true</code>后，会对输入的上下左右进行填充，并且如果<code>strides</code>（步幅）设置为<code>1</code>后，输入与输出的大小应该相同。如果拿<code>4*4</code>的输入为例，用<code>3*3</code>的卷积以步幅为<code>1</code>进行运算时。应该在上下左右四边每边补充一组数据，形成一个<code>6*6</code>的输入，这样在和<code>3*3</code>做以步幅为<code>1</code>做卷积的时候，输出才会是<code>4*4</code>（6-3+1&#x3D;4）。</p><p>回到本例，<code>CIFAR10</code>的原始大小是<code>32*32</code>的，如果没有<code>padding=&#39;same&#39;</code>，那么在与<code>3*3</code>做步幅为<code>1</code>的卷积时，输出的大小就应该是<code>32-2</code>，也就是<code>30*30</code>了。</p><p>关于<code>padding</code>参数的解释就到这，至于为什么增加<code>padding</code>之后，训练的结果朝着更好的方向发展。或者说，如果不提供<code>padding</code>，会使训练结果变差，在<code>《深度学习入门 基于Python的理论与实现》</code>这本书中有这样的解释：</p><blockquote><p>如果每次进行卷积运算都会缩小空间，那么在某个时刻输出大小就有可能为1，导致无法再应用卷积运算。</p></blockquote><p>基于这种极限化的考虑，那么在每次卷积之后，保证输出大小不变就是必要的了。</p><p>不过我在测试API使用中还遇到一个问题，如果<code>strides</code>大于<code>1</code>，那么<code>padding=&#39;same&#39;</code>也是无法保证输出与输入大小相同的。这个虽然在<code>keras</code>文档里说了，但是我却有点困惑，觉得这有悖于<code>same</code>的字面意思，只能留着以后再研究了。</p><p>最后附上今天使用的核心代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Conv2D(<span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>),padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">model.add(layers.Conv2D(<span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), activation=<span class="string">&#x27;relu&#x27;</span>,padding=<span class="string">&#x27;same&#x27;</span>))</span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;Adam&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">history = model.fit(train_images, train_labels, epochs=<span class="number">50</span>, batch_size=<span class="number">64</span>,validation_data=(test_images, test_labels))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keras </tag>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普普通通的CNN训练CIFAR-10</title>
      <link href="/2022/04/12/cnn-cifar10/"/>
      <url>/2022/04/12/cnn-cifar10/</url>
      
        <content type="html"><![CDATA[<p>之前用<code>VGG16</code><a href="https://www.kankanzhijian.com/2022/04/01/use-vgg16-at-cifar10/">训练了一次</a><code>CIFAR10</code>数据集，我还说用<code>VGG16</code>会有一个不错的起点呢，毕竟是业界训练好的模型嘛。结果今天用自建的卷积神经网络一测，结果出乎意料，自建的神经网络虽然训练精度的上升没有之前的快，但是验证精度也能达到<code>75%</code>的水平，跟上次区别不大。同时，虽然这次迭代次数有增加，但是得益于模型简化了许多，训练速度也提升了不少。话不多说，上结果：</p><p><img src="/media/CleanShot%202022-04-12%20at%2016.17.14.png" alt="CleanShot 2022-04-12 at 16.17.14"></p><hr><p>看来<code>75%</code>的验证精度对这个数据集来说是到瓶颈了，下次要尝试使用数据增强技术了。看看不能不有一点突破。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keras </tag>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在windows里杀进程，遭遇提示：没有此任务的实例在运行</title>
      <link href="/2022/04/11/kill-pid-in-windows/"/>
      <url>/2022/04/11/kill-pid-in-windows/</url>
      
        <content type="html"><![CDATA[<p>今天有被windows给坑了一把，有个几个进程死活结束不掉，还遇到提示：“没有此任务的实例在运行”，所以做个笔记。</p><p>以名称为<code>xxx.exe</code>、<code>PID</code>为<code>1024</code>为例，正常来说，杀掉一个进程命令如下：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">taskkill <span class="regexp">/F /</span>PID <span class="number">1024</span></span><br></pre></td></tr></table></figure><p>如果杀不掉，可能是因为有父进程影响，需要先杀父进程，而获取父进程的命令为：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">wmic process where <span class="attribute">ProcessId</span>=1024 <span class="built_in">get</span> ParentProcessId</span><br></pre></td></tr></table></figure><p>如果不知道子进程的<code>PID</code>，但是知道进程名字，也可以试试这个：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">wmic process <span class="keyword">where</span> <span class="type">name</span>=&quot;xxx.exe&quot; <span class="keyword">call</span> terminate</span><br></pre></td></tr></table></figure><p>总之找到父进程<code>PID</code>后，再用第一行命令去杀父进程才是正解。</p><p>另外补充一下，如果不知道<code>PID</code>，想用进程名作为参数，可以用这条：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">taskkill <span class="string">/IM</span> <span class="string">&quot;xxx.exe&quot;</span> <span class="string">/F</span></span><br></pre></td></tr></table></figure><p>如果你喜欢用<code>PowerShell</code>，还可以用下面两个命令：</p><figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">Stop-<span class="keyword">Process</span> -Name <span class="string">&quot;xxx.exe&quot;</span> -<span class="keyword">Force</span></span><br><span class="line">Stop-<span class="keyword">Process</span> -ID <span class="number">1024</span> -<span class="keyword">Force</span></span><br></pre></td></tr></table></figure><p>分别对应了用名称或者<code>PID</code>杀进程。</p><hr><p>后来我又遇到一种情况，即使用上面的方式还是不行。无意中发现可以这样：</p><p><img src="/media/CleanShot%202022-04-11%20at%2017.28.53.png" alt="CleanShot 2022-04-11 at 17.28.53"></p><p>在任务管理器，选中杀不掉的进程，右键-&gt;<code>分析等待链</code>，</p><p><img src="/media/CleanShot%202022-04-11%20at%2017.29.11.png" alt="CleanShot 2022-04-11 at 17.29.11"></p><p>然后可以把它列出的在<code>等待链</code>中的进程进行结束，就可以杀死之前不能杀死的进程了。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用VGG16训练CIFAR-10的一次失败记录</title>
      <link href="/2022/04/01/use-vgg16-at-cifar10/"/>
      <url>/2022/04/01/use-vgg16-at-cifar10/</url>
      
        <content type="html"><![CDATA[<p>最近研究<code>深度学习</code>，主要想做计算机视觉相关的事情。因为我是个纯新手，所以想把一些学习进展记录一下。毕竟<code>深度学习</code>的超参数设置，还是非常依赖经验的，而我在这方面只是个小白，如果我能把每次训练的情况，都详细记录下来，或许能够帮助我总结一些经验。毕竟跑一次训练，少则几分钟，多则数十分钟（我是M1 Air，没风扇，也不敢跑太久的），既然这时间都花了，所以结果还是记录的越详细越好。</p><p><code>CIFAR-10</code>是一组别人准备好的图片数据集，总共有10个类别，每个类别有<code>6000</code>张图像，但是每个图片都不大，才<code>32*32</code>。</p><p>今天我先用别人已经预训练好的模型<code>VGG16</code>做个基准，后面再找机会看看能不能改进吧。先来看结果：</p><p><img src="/media/CleanShot%202022-04-01%20at%2017.42.06.png" alt="CleanShot 2022-04-01 at 17.42.06"></p><p>这明显是<code>过拟合</code>了，模型在<code>训练集</code>上表现越来越好，但是在<code>验证集</code>上精度就是上不去。我估计还是因为<code>VGG16</code>的模型比较大，参数多，所以在训练集不充足的情况下比较容易过拟合。下面是我训练相关的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> cifar10</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.applications <span class="keyword">import</span> VGG16</span><br><span class="line"></span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = cifar10.load_data()</span><br><span class="line"></span><br><span class="line">train_images = train_images.astype(<span class="string">&#x27;float32&#x27;</span>) / <span class="number">255</span></span><br><span class="line">test_images = test_images.astype(<span class="string">&#x27;float32&#x27;</span>) / <span class="number">255</span></span><br><span class="line">train_labels = to_categorical(train_labels)</span><br><span class="line">test_labels = to_categorical(test_labels)</span><br><span class="line"></span><br><span class="line">conv_base = VGG16(weights=<span class="string">&#x27;imagenet&#x27;</span>,</span><br><span class="line">                  include_top=<span class="literal">False</span>,</span><br><span class="line">                  input_shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>))</span><br><span class="line">                  </span><br><span class="line">conv_base.trainable = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">set_trainable = <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> conv_base.layers:</span><br><span class="line">    <span class="keyword">if</span> layer.name == <span class="string">&#x27;block5_conv1&#x27;</span>:</span><br><span class="line">        set_trainable = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> set_trainable:</span><br><span class="line">        layer.trainable = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        layer.trainable = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(conv_base)</span><br><span class="line">model.add(layers.Flatten())</span><br><span class="line">model.add(layers.Dense(<span class="number">512</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;rmsprop&#x27;</span>,</span><br><span class="line">              loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">history = model.fit(train_images, train_labels, epochs=<span class="number">25</span>, batch_size=<span class="number">64</span>,validation_data=(test_images, test_labels))</span><br></pre></td></tr></table></figure><p>下面是绘制精度图的代码：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import matplotlib<span class="selector-class">.pyplot</span> as plt</span><br><span class="line"></span><br><span class="line">acc = history<span class="selector-class">.history</span><span class="selector-attr">[<span class="string">&#x27;accuracy&#x27;</span>]</span></span><br><span class="line">val_acc = history<span class="selector-class">.history</span><span class="selector-attr">[<span class="string">&#x27;val_accuracy&#x27;</span>]</span></span><br><span class="line">loss = history<span class="selector-class">.history</span><span class="selector-attr">[<span class="string">&#x27;loss&#x27;</span>]</span></span><br><span class="line">val_loss = history<span class="selector-class">.history</span><span class="selector-attr">[<span class="string">&#x27;val_loss&#x27;</span>]</span></span><br><span class="line"></span><br><span class="line">epochs = <span class="built_in">range</span>(<span class="built_in">len</span>(acc))</span><br><span class="line"></span><br><span class="line">plt<span class="selector-class">.plot</span>(epochs, acc, <span class="string">&#x27;bo&#x27;</span>, label=<span class="string">&#x27;Training acc&#x27;</span>)</span><br><span class="line">plt<span class="selector-class">.plot</span>(epochs, val_acc, <span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;Validation acc&#x27;</span>)</span><br><span class="line">plt<span class="selector-class">.title</span>(<span class="string">&#x27;Training and validation accuracy&#x27;</span>)</span><br><span class="line">plt<span class="selector-class">.legend</span>()</span><br><span class="line"></span><br><span class="line">plt<span class="selector-class">.figure</span>()</span><br><span class="line"></span><br><span class="line">plt<span class="selector-class">.plot</span>(epochs, loss, <span class="string">&#x27;bo&#x27;</span>, label=<span class="string">&#x27;Training loss&#x27;</span>)</span><br><span class="line">plt<span class="selector-class">.plot</span>(epochs, val_loss, <span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;Validation loss&#x27;</span>)</span><br><span class="line">plt<span class="selector-class">.title</span>(<span class="string">&#x27;Training and validation loss&#x27;</span>)</span><br><span class="line">plt<span class="selector-class">.legend</span>()</span><br><span class="line"></span><br><span class="line">plt<span class="selector-class">.show</span>()</span><br></pre></td></tr></table></figure><p>今天就这样，回头我会尝试改进模型训练，看能不能把精度提高一点。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keras </tag>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的38堂成长课》读后小记</title>
      <link href="/2022/03/31/becoming-a-batter-programmer/"/>
      <url>/2022/03/31/becoming-a-batter-programmer/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/IMG_2E23A74A58A6-1.jpeg" alt="IMG_2E23A74A58A6-1"></p><p>就如书名一样，这本书由38个主题组成，并且颇具课堂的感觉，好似来自一位长者的谆谆教诲。所以这种书读起来是很考验读者的，因为作者讲的道理都对，但是读者依其经验的多寡，思索的深浅，往往会有不同的体会。愚者，可能会抱怨这本书充满了说教；而智者，反而会跟随作者的节奏忍不住拍手喝彩。</p><p>而我，似乎离智者还有一段距离。</p><p>其实这本书我是很喜欢的，作者虽然在导读里面说书中章节，读者可按需横跳阅读，但其实仅仅透过<a href="https://www.ituring.com.cn/book/1550">目录</a>，我们就能看到一位严谨的程序员如何组织他的思路，以及要把我们引向何方。更何况，全书按耐不住的幽默感，使得阅读体验提升不少。这里也得感谢译者，翻译一本理论大于实践的书籍，是很难的，尤其是面对这么一位知识渊博的原作者，想要传神地表现原著的思想，还非得下一番功夫才行。</p><p>但是就跟我们在所有课堂里学到的东西一样，“纸上得来终觉浅，觉知此事要躬行”，作为一本理论性的书籍，即使这本书里提到了众多可操作性的方案，但是在真实场景下，我们会不会采取这些方案，其实还是有赖于每个人对理论的认知以及对目标的追求。</p><p>所以这是一个悖论，你不能指望读完一本大师写的书，自己就可以成为大师；而当你已经成为大师之后，这本书似乎只能作为餐后小甜品，好吃，但是没什么必要了。</p><p>对于我来说，我认可作者的高度，也认可书籍内容的高度，我怀着严谨的态度阅读完此书，并且好多次为作者的幽默会心一笑，也对作者的好多观点拍手称快。但是我恐怕不会在未来再翻一遍这本书，因为有同样的时间，再阅读另外一本完全不同的理论书籍，可能更有利于完善自己的编程心智模型。当然，最快这也是一年以后的事情了。</p><p>如果你已经有2年以上的项目编程经验，但是还没读过类似的理论书籍，又想在编程这条路上一直走下去，那么这本书还是非常值得推荐的。</p>]]></content>
      
      
      <categories>
          
          <category> 读书日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>能力的四个阶段</title>
      <link href="/2022/03/30/power-four-level/"/>
      <url>/2022/03/30/power-four-level/</url>
      
        <content type="html"><![CDATA[<p>能力的四个阶段，这是我在读<code>《程序员的38堂成长课》</code>里看到的。有意思的是，这段理论也非该书作者<code>皮特·古德利夫</code>的原创。而是作者引用了心理学家<code>亚伯拉罕·马斯洛</code>在20世纪40年代提出来的。</p><p>都是大白话。但是这样简单的模型，却有着惊人的概括能力。它对于我们找准自己的象限非常有用。一旦明确了自己的象限，就能知道自己的潜在瓶颈，进而有利于明确下一步的努力方向。下面就一起来看一下吧。</p><blockquote><ul><li>有意识的无能力<br>你不知道某些东西，但是你知道你不知道。这是一个相对安全的状态。你可能不在 乎，因为这不是你需要知道的事情。或者你很在乎，它成为你的一个挫折未源。</li><li>有意识的有能力<br>这也是一个很好的状态。你知道某些东西，而且你知道你知道。要使用这项技能，你必须有意识地努力，并集中精力。</li><li>无意识的有能力<br>你对一个话题的知识了解得如此之多，它已经成为第二天性。你根本没有意识到在使用自己的专业知识。例如，大多数成年人可以把走路和保村平街看作一种无意识的能力，不假思索就能做到。</li><li>无意识的无能力<br>这是一个危险的状态。你对自己的无知一无所知。的确，你很可能以为自己理解了某些问题，但不知道自己错得有多离谱。这是你知识中的盲点。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《社会契约论》读后小记</title>
      <link href="/2022/03/27/du-contrat-social/"/>
      <url>/2022/03/27/du-contrat-social/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/IMG_6CA22B2EF83A-1.jpeg" alt="BookTime-w400"></p><p>受友人推荐，我读了卢梭的这本书。正如书的名字所表述出来的那样，这是一本社会学的书。我这个程序员读起来，还是有点力不从心。毕竟作者渊博的知识积淀都源于欧洲，书中的例子、典故也都出自于那里。对于一个没有系统的接受过西方文化熏陶的工科生来说，很难从作者的旁征博引中产生共鸣。</p><p>但好在，卢梭讲述问题时往往循着某个路线，逻辑上缜密而又循序渐进。对于很多重要观点的推导，相当不惜笔墨，像做证明题一样，一步一步丝丝入扣，倒是很有理科生的特质。仅仅通过目录的排布，这种逻辑上的自洽，你便可窥之一二，若不信，可试翻之。</p><p>下面我谈几个书中对我颇有启迪的概念：</p><h4 id="自由的三个部分"><a href="#自由的三个部分" class="headerlink" title="自由的三个部分"></a>自由的三个部分</h4><ul><li>我可以实现自己的意志</li><li>我可以不屈服于别人的意志</li><li>不使别人的意志屈服于我的意志</li></ul><p>这段是书中译者注提到的，摘自卢梭的《山中书简》。细读起来，其中竟有程序代码般的精妙之感。</p><h4 id="从人类的本能状态，到组建社会之后，人类的呈现出的道德状态"><a href="#从人类的本能状态，到组建社会之后，人类的呈现出的道德状态" class="headerlink" title="从人类的本能状态，到组建社会之后，人类的呈现出的道德状态"></a>从人类的本能状态，到组建社会之后，人类的呈现出的道德状态</h4><blockquote><p>“只有当义务的呼声取代了生理冲动，当权利取代了嘘欲时，在此之前眼中只有自己的人类，方才发现必须遵守除了冲动欲望之外的原则，在听任自己的喜好之前还需要进行理智的考量。尽管人失去了若干自然状态下的利益，但所收获的远远更多。”</p></blockquote><p>这里引出了两个问题：</p><ol><li>社会之于人类的最基本意义。它把独立的动物性的人类，链接在一个框架下。在这个框架下，每个个体让渡一部分权利，然后获得与之相称的另一部分权利。</li><li>道德的产生。这就是社会框架对其中每个人形成一种约束链。当一个人在符合框架的规范下劳动与生活时，这些链接处于休眠状态。反之，如果一个人的行为有逾矩之处，侵害他人甚至集体利益的时候，相应的链接就会被激活，对这个人形成反向约束。同时，我们也应认识到，道德标准是不断变化的，也就意味着，这种约束链条也不是一尘不变而是动态平衡的。</li></ol><p>作者还试图详细解释，人类让渡自己的权利，使自己成为社会一份子后，到底获得了怎样的收益，这笔买卖到底合算不合算。请看下面这段话：</p><blockquote><p>“当人进入社会契约中，他们的处境比契约存在之前更优越了，他们不是放弃，而是进行了一笔合算的交易。以不确定不稳定的生活方式换取了更好更可靠的生活方式，用天然的不受束缚换取了自由，用侵害他人的杈利换取了自身的安全，用可能被别人压制的强力换取了因社会团结而不可被征服的权利。他们奉献给国家的个人生命也得到了持续的保护，当人们献出生命来保卫国家时，不就是将所获得的重新奉献给国家吗？他们所做的，不就是在自然状态下需要更加频繁、冒着更大的危险，在发动无可避免的斗争时，以生命为代价去保卫能够使他们保住生命的东西吗？所有人都要为国家的需求而战，这是千真万确的，但人们也就不必为自己而战了。在联合之前，我们要冒着很大的风险去保全自己；联合之后，我们只需冒部分危险来保卫国家，这难道不是很大的改善吗？”</p></blockquote><p>其实我们无从得知，上面这段话是描述的“原因”还是“结果”，但是应该无人可以质疑这段话的正确性。</p><h4 id="“神”言惑众"><a href="#“神”言惑众" class="headerlink" title="“神”言惑众"></a>“神”言惑众</h4><p>应该还有人记得中学课本里的“大楚兴，陈胜王”，彼时社会底层的劳动人民就吃这一套。你是否曾有些许疑惑，这样愚昧迷信的特质，是我们这个民族所特有的，还是在全球各文化中所普遍存在的？读了卢梭的这本书，答案一目了然，就是这种假借神语，以惑众人的手段，是全球通用的。请看下面这段：</p><blockquote><p>“他们将自己的智慧归功于诸神，是为了他们的人民能够像服从自然法则那样去服从国家法律，能够认识到正是创造了人类的力量创造了国家，从而能够在自由中顺服地承担起公共福祉的责任。”</p></blockquote><h4 id="民主投票"><a href="#民主投票" class="headerlink" title="民主投票"></a>民主投票</h4><p>这是书中最有意思，对我启发最大的一段论述了。想象这样一个场景，你们班级正在投票决议一个制度。大部分人投票赞成，最后少数服从多数，决议通过，这个制度开始施行。但是少部分投反对票的人，他们还想负隅顽抗。他们会说：“同意的是你们，我没同意，我拒绝执行。”你会怎么答复他？如果仅用“少数服从多数”，是不是略显苍白？</p><p>在这本书里，卢梭用他惊人的逻辑能力给出了一个完美解释。这个解释，需要所有参与民主投票的人明白下面几个要点：</p><ol><li>虽然我们征求的是每个个体的意见，但是我们是要选出一个对集体最好的结果，这是我们的目的。</li><li>所以你的意见，只是代表你认为这样做，对集体最好，而不是为了让你自己受益更多。</li><li>既然多数人投票得出了一个结论，这个结论就是集体选择的，是集体认为对集体最有利的选择。</li><li>所以那些与多数人投票向左的意见，是他们判断错误了，集体已经给出了它的选择，他们只需要修正自己错误，按集体决定的最优解执行就好了。</li><li>所以任何人都没有反驳多数票的权利。</li></ol><hr><p>关于这本书，就谈到这里吧。说实话，从国家距离、文化距离、时间距离这几个维度来说，距离我此刻越远，这样的书读起来就越费劲，需要花时间也就越多，但是获得的知识收益可能也会越多，当然也可能越少（因为读不懂）。同时，每读完这样的一本书，就像在那个时空、那个文化位置上锚定了一个点，之后再读这个锚定点附近位置的书籍，就可以轻松一点了，所以这就是读书的乐趣吧。</p>]]></content>
      
      
      <categories>
          
          <category> 读书日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PostGIS 初体验</title>
      <link href="/2022/03/25/postgis-first-look/"/>
      <url>/2022/03/25/postgis-first-look/</url>
      
        <content type="html"><![CDATA[<h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一 安装"></a>一 安装</h2><p><code>PostGIS</code>的安装及本是无障碍的。不管是<code>Red Hat</code>系的<code>YUM</code>还是<code>Ubuntu</code>系的<code>APT</code>都可以轻松安装。以<code>Ubuntu</code>为例的话，只需要轻松执行下面的明令即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get -y install postgresql-14-postgis-3</span><br></pre></td></tr></table></figure><p>这里注意上面的<code>14</code>对应的是本机已安装<code>PostgreSQL</code>的主版本号。因为<code>PostGIS</code>是作为插件存在的，所以最好先装好一个可用的<code>PostgreSQL</code>服务，然后再安装对应版本的插件。</p><h2 id="二-启用插件"><a href="#二-启用插件" class="headerlink" title="二 启用插件"></a>二 启用插件</h2><p>对<code>PostgreSQL</code>来说，一个好的实践是把安装的插件，单独控制在一个<code>schema</code>里面。因为插件往往会带来各种各样的函数或者表，我们应该把这些非自己维护的资源与自己的业务表区分开。所以建议执行下面两行<code>SQL</code>语句，以安装（启用）插件。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA extensions;</span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION postgis SCHEMA extensions;</span><br></pre></td></tr></table></figure><h2 id="三-简单测试"><a href="#三-简单测试" class="headerlink" title="三 简单测试"></a>三 简单测试</h2><p>一切顺利的话，我们就可以测试<code>PostGIS</code>的基本功能了：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询北京到南京的距离，单位米</span></span><br><span class="line"><span class="keyword">select</span> extensions.st_distance(extensions.st_point( <span class="number">116.2</span>,<span class="number">39.56</span>), extensions.st_point( <span class="number">118.78</span>,<span class="number">32.04</span>), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>因为我们把<code>PostGIS</code>的相关函数等资源都装在可<code>schema</code>下，所以调用函数的时候，就需要加上<code>schema</code>的名字了。这里稍微有点麻烦。所以需要修正下数据库的<code>search_path</code>。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database postgres <span class="keyword">set</span> search_path <span class="operator">=</span> public,extensions;</span><br><span class="line"><span class="keyword">set</span> search_path <span class="operator">=</span> public,extensions;</span><br></pre></td></tr></table></figure><p>第一句的<code>postgres</code>对应你在用的数据库名，所以要根据实际情况做些调整。同时，第一句的设置，只有在下次客户端连接到数据库的时候才会启用，如果想要当前执行<code>SQL</code>的上下文环境即时生效，所以才有了第二句。</p><p>一切设置完毕后，我们就可以直接这样执行了：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> st_distance(st_point( <span class="number">116.2</span>,<span class="number">39.56</span>), st_point( <span class="number">118.78</span>,<span class="number">32.04</span>), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maupassant主题在Apple M1上不能用的问题</title>
      <link href="/2022/03/22/maupassant-in-apple-silicon/"/>
      <url>/2022/03/22/maupassant-in-apple-silicon/</url>
      
        <content type="html"><![CDATA[<p>我这个博客是用<a href="https://hexo.io/zh-cn/">hexo</a> 搭建的，说实话<code>node</code>的技术栈真是很烦，各种依赖非常重，借用一位朋友的话说”天下苦<code>node</code>久矣”。</p><p>不过对我来说，平时开发也不用<code>node</code>了，现在就用用<code>blog</code>嘛，也不是不能忍。</p><p>谁成想，两年前换了<code>Apple M1</code>后，情况都变了。<code>blog</code>直接跑不起来了，当时我一直以为是<code>hexo</code>的问题，很无奈就只能停更了。</p><p>中间陆陆续续，各种东西也在适配，我也都顺手尝试了几次，不过无疾而终，这也就导致了我这个<code>blog</code>断更了这么久。</p><p><code>失之东隅，收之桑榆</code>，虽然<code>blog</code>都长草了，但是<a href="https://space.bilibili.com/24370353">B站</a> 倒是有点蒸蒸日上的感觉。</p><p>时间来到了<code>2022</code>年，我突然觉得视频的形式虽然受众广，也适合安利教程啊、软件啊、开箱评测类的东西。但是本质上，视频对沉淀自己，其实没有<code>blog</code>来的深刻。</p><p>所以<code>blog</code>还是不能丢，从今天起，我要回归这个<code>blog</code>，继续记录生活与技术。</p><p>回归标题，说说我是怎么解决之前我的<code>blog</code>无法<code>hexo g -d</code>的问题。</p><p>经研究发现不是<code>hexo</code>的问题，而是我用的这款皮肤<code>maupassant</code>，它依赖一个包<code>hexo-renderer-sass</code>，众所周知，<code>sass</code>的一些生态在<code>node</code>里就是万恶之源啊。</p><p>但其实<code>sass</code>大部分情况下也早就适配<code>M1</code>了，只是这个<code>hexo-renderer-sass</code>已经三年没人管了。实在没办法，我只能自己<code>fork</code>了一下，改了一下依赖。</p><p>也就是把下面这段：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line"> &quot;node-sass&quot;: &quot;^4.5.3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成了:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line"> &quot;node-sass&quot;: &quot;^7.0.1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，回到我自己的<code>blog</code>项目的<code>package.json</code>文件，手动添加依赖：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;hexo-renderer-sass&quot;: &quot;github:aruis/hexo-renderer-sass&quot;,</span><br><span class="line">  ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>然后<code>npm install</code>，就万事大吉了。</p><p>就这样，我的<code>blog</code>就复活了，😄</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL频繁更新数据的大表查询计划可能会搞错的应对方案</title>
      <link href="/2020/11/05/autovacuum-analyze-scale-factor/"/>
      <url>/2020/11/05/autovacuum-analyze-scale-factor/</url>
      
        <content type="html"><![CDATA[<p>当表的数据比较多（大概百万级以上）的时候，对表的使用是重度依赖analyze采集的数据的。尤其是当表处于被频繁的update、insert操作下，之前analyze的数据如果不及时更新，极有可能让查询计划走歪，然后导致一个查询可能要付出10倍以上的时间——我遇到过好几次，每次都是通过手动vaccum解决。<br>本来pg是有autovacuum的，这里之所以没有触发，还是因为表比较大，百万行的数据，update个几万行，变更率才百分之几，而调度autovacuum_analyze的默认阈值是百分之十。<br>这就比较尴尬了，好在pg支持针对单表做详细的定制。这里给出一个参考SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> demo_table <span class="keyword">SET</span> (fillfactor<span class="operator">=</span><span class="number">85</span>, autovacuum_vacuum_scale_factor<span class="operator">=</span><span class="number">0.02</span>, autovacuum_analyze_scale_factor<span class="operator">=</span><span class="number">0.02</span>);</span><br></pre></td></tr></table></figure><p>这就把阈值定在2%了。<br>理论上，这样autovacuum能调度的更频繁一点。查询计划相对来说也要更准确点。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找出Postgres中占用磁盘最多的表</title>
      <link href="/2020/10/30/postgres_table_disk_used_order/"/>
      <url>/2020/10/30/postgres_table_disk_used_order/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> schemaname,</span><br><span class="line">       relname,</span><br><span class="line">       pg_size_pretty(pg_table_size(relid))</span><br><span class="line"><span class="keyword">from</span> pg_stat_user_tables</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> pg_table_size(relid) <span class="keyword">desc</span> ,schemaname;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用pg_stat_statements排查PostgreSQL中的慢SQL</title>
      <link href="/2019/03/24/pg_stat_statements/"/>
      <url>/2019/03/24/pg_stat_statements/</url>
      
        <content type="html"><![CDATA[<ol><li>编辑<code>postgresql.conf</code><ul><li><code>shared_preload_libraries = &#39;pg_stat_statements&#39;</code></li><li><code>track_activity_query_size = 16384</code></li></ul></li><li>启用扩展<code>create extension pg_stat_statements</code></li><li>查找慢<code>SQL</code><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> round((<span class="number">100</span> * total_time / sum(total_time) <span class="keyword">over</span> ())::<span class="type">numeric</span>, <span class="number">2</span>) percent,</span><br><span class="line">       round(total_time::<span class="type">numeric</span>, <span class="number">2</span>) <span class="keyword">as</span>                                total,</span><br><span class="line">       calls,</span><br><span class="line">       round(mean_time::<span class="type">numeric</span>, <span class="number">2</span>)  <span class="keyword">as</span>                                mean,</span><br><span class="line">       query</span><br><span class="line"><span class="keyword">from</span> pg_stat_statements</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> total_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个较新的Vert.x例子</title>
      <link href="/2019/02/28/vertx_demo_2019/"/>
      <url>/2019/02/28/vertx_demo_2019/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://github.com/yuri-mednikov/bike-share">https://github.com/yuri-mednikov/bike-share</a></li><li><a href="https://github.com/PharosProduction/tutorial-vertx-microservices-java">https://github.com/PharosProduction/tutorial-vertx-microservices-java</a></li><li><a href="https://github.com/migibert/vertx-in-production">https://github.com/migibert/vertx-in-production</a></li><li><a href="https://github.com/marceloandradep/vertx-example">https://github.com/marceloandradep/vertx-example</a></li></ul><p>基本上都是2019年新鲜出炉的几个项目，还算比较新</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中执行即时代码段(匿名存储过程)</title>
      <link href="/2019/02/27/postgresql_%20execute_an_anonymous_codeblock/"/>
      <url>/2019/02/27/postgresql_%20execute_an_anonymous_codeblock/</url>
      
        <content type="html"><![CDATA[<p>某些时候需要执行过程化的逻辑，单纯靠组织<code>SQL</code>语句已经完成不了了，这个时候一般需要引入存储过程用以实现。但是如果只是单纯执行一段逻辑，而不是要封装一个函数，用来接收参数复用，完全可以通过<code>DO</code>语句执行一个匿名代码段。这样就可以避免：创建存储过程 -&gt; 调用存储过程 -&gt; 删除存储过程的窘境。<br>这里给出一个简短的<code>SQL</code>演示：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DO</span></span><br><span class="line">  $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">    <span class="keyword">declare</span></span></span><br><span class="line"><span class="language-pgsql">      i <span class="type">int</span> := <span class="number">0</span>;</span></span><br><span class="line"><span class="language-pgsql">    <span class="keyword">begin</span></span></span><br><span class="line"><span class="language-pgsql">      <span class="keyword">raise</span> <span class="keyword">notice</span> <span class="string">&#x27;il:%&#x27;</span>,i;</span></span><br><span class="line"><span class="language-pgsql">      <span class="keyword">declare</span></span></span><br><span class="line"><span class="language-pgsql">        i <span class="type">int</span>;</span></span><br><span class="line"><span class="language-pgsql">      <span class="keyword">begin</span></span></span><br><span class="line"><span class="language-pgsql">        <span class="keyword">raise</span> <span class="keyword">notice</span> <span class="string">&#x27;i2:%&#x27;</span>,i;</span></span><br><span class="line"><span class="language-pgsql">      <span class="keyword">end</span>;</span></span><br><span class="line"><span class="language-pgsql">    <span class="keyword">end</span></span></span><br><span class="line"><span class="language-pgsql">    $$</span> <span class="keyword">language</span> plpgsql;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PortgreSQL中找到那些被大量顺序扫表没走索引的表</title>
      <link href="/2019/02/25/lot_of_seq_scan_in_postgresql/"/>
      <url>/2019/02/25/lot_of_seq_scan_in_postgresql/</url>
      
        <content type="html"><![CDATA[<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> schemaname,</span><br><span class="line">       relname,</span><br><span class="line">       seq_scan,</span><br><span class="line">       seq_tup_read,</span><br><span class="line">       seq_tup_read / seq_scan <span class="keyword">as</span> avg,</span><br><span class="line">       idx_scan</span><br><span class="line"><span class="keyword">from</span> pg_stat_user_tables</span><br><span class="line"><span class="keyword">where</span> seq_scan &gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> seq_tup_read <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>解释一下</p><ul><li><code>seq_scan</code>是表上发生顺序扫描的次数</li><li><code>seq_tup_read</code>是顺序扫描时系统读取了多少个元组</li><li><code>idx_scan</code>是表上发生索引扫描的次数</li></ul><p>通过上面的<code>SQL</code>就能查询到那些被频繁访问，但是几乎没有利用到索引的表，这样我们就可以针对这些表针对性的创建索引，从而大幅提升数据库的访问速度。</p><p>补充一点：顺序扫表不是一定不好，但是大规模的顺序扫表常常是数据库性能低下的根源。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用groovy实现根据规则校验单据数据</title>
      <link href="/2019/02/20/groovy_validating_form_on%20dynamic_rules/"/>
      <url>/2019/02/20/groovy_validating_form_on%20dynamic_rules/</url>
      
        <content type="html"><![CDATA[<p>单据字段校验，在任何管理信息系统中都是普通得不能再普通的问题。通常我们的都会选择在前端以及后端各实现一遍。<br>前端实现，方便用户体验；后端实现，确保数据健康。<br>但是总觉得同样的业务实现两遍，真的不符合直觉。我的想法是，把校验规则抽象出来，通过公共方法来处理单据校验问题。做到一套规则，两处判断。减少业务开发人员的重复劳动。<br>比如规则是这样的</p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;v_name&quot;</span>,</span><br><span class="line">        <span class="string">&quot;expression&quot;</span>: <span class="string">&quot;notBlank(v_name)&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tip&quot;</span>: <span class="string">&quot;姓名必填&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;v_password&quot;</span>,</span><br><span class="line">            <span class="string">&quot;v_password_twice&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;expression&quot;</span>: <span class="string">&quot;v_password == v_password_twice&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tip&quot;</span>: <span class="string">&quot;两次密码输入不一致&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里面<code>target</code>是为了跟前端交互，在规则验证失败时给前端UI标红框使用的；<code>tip</code>是出错信息提示。只有<code>expression</code>才是核心业务——能返回<code>boolean</code>的表达式。<br>怎么才能驱动表达式执行呢，这在有动态特性的<code>groovy</code>中简直是小菜一碟。最简单的：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="literal">true</span><span class="operator"> == </span><span class="module-access"><span class="module"><span class="identifier">Eval</span>.</span></span>me(<span class="string">&quot;2&gt;1&quot;</span>)</span><br></pre></td></tr></table></figure><p>轻松通过，但是注意我上面的<code>v_password == v_password_twice</code>这就比较棘手了，要从一个上下文中获取字段数据，再执行表达式，<br>这里假设我们准备的数据是：</p><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">def <span class="built_in">map</span> = [</span><br><span class="line">        <span class="string">&quot;v_name&quot;</span>          : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;v_password&quot;</span>      : <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;v_password_twice&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>想让<code>groovy</code>动态脚本认识<code>map</code>，需要借助更强大的<code>GroovyShell</code>，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">def sharedData = <span class="keyword">new</span> <span class="constructor">Binding()</span></span><br><span class="line">def shell = <span class="keyword">new</span> <span class="constructor">GroovyShell(<span class="params">sharedData</span>)</span></span><br><span class="line">map.each &#123; k, v -&gt;</span><br><span class="line">    sharedData.set<span class="constructor">Property(<span class="params">k</span>, <span class="params">v</span>)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> <span class="literal">true</span><span class="operator"> == </span>shell.evaluate(<span class="string">&quot;v_password == v_password_twice&quot;</span>)</span><br></pre></td></tr></table></figure><p>看起来<code>Binding</code>可以轻易地构造执行脚本的上下文环境，那能不能更进一步，传入一个方法呢，比如上文的<code>notBlank</code>，也很简单</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">def notBlank = &#123; String s -&gt;</span><br><span class="line">    s != <span class="keyword">null</span> &amp;&amp; s.trim().length() &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">sharedData.setProperty(&quot;notBlank&quot;, notBlank)</span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">true</span> == shell.evaluate(&quot;notBlank(v_name)&quot;)</span><br></pre></td></tr></table></figure><p>有了强大的<code>groovy</code>，就可以实现基于表达式的动态数据验证，没有占位符，没有字符串替换，还支持注入方法，真是即简单又强大。<br>这是我最终实现的方法：</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查数据是否符合规则</span></span><br><span class="line"><span class="comment"> * @param rules 规则List</span></span><br><span class="line"><span class="comment"> * @param map 待校验数据</span></span><br><span class="line"><span class="comment"> * @return 不满足规则的rules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List check(List rules, def <span class="keyword">map</span>) &#123;</span><br><span class="line">    def sharedData = <span class="keyword">new</span> Binding()</span><br><span class="line">    def shell = <span class="keyword">new</span> GroovyShell(sharedData)</span><br><span class="line">    sharedData.setProperty(<span class="string">&quot;length&quot;</span>, &#123; <span class="built_in">String</span> s -&gt;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> s.length()</span><br><span class="line">    &#125;)</span><br><span class="line">    shareData.setProperty(<span class="string">&quot;notBlank&quot;</span>,&#123; <span class="built_in">String</span> s -&gt;</span><br><span class="line">    s != <span class="literal">null</span> &amp;&amp; s.trim().length() &gt; <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">map</span>.each &#123; k, v -&gt;</span><br><span class="line">        sharedData.setProperty(k, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rules.findAll &#123; !shell.evaluate(<span class="literal">it</span>.expression) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整测试代码参考：<a href="https://gist.github.com/aruis/d4a28b3cedfcc2a23a85ac67ca68adb7">https://gist.github.com/aruis/d4a28b3cedfcc2a23a85ac67ca68adb7</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>突破mac系统要求密码不能小于4个字符的限制</title>
      <link href="/2018/12/08/password_more_than_4_char_in_macos/"/>
      <url>/2018/12/08/password_more_than_4_char_in_macos/</url>
      
        <content type="html"><![CDATA[<ol><li><p>在终端执行<code>pwpolicy getaccountpolicies &gt; temp.xml</code></p></li><li><p>编辑temp.xml文件，例如<code>vim temp.xml</code></p></li><li><p>删除第一行<code>Getting global account policies</code>文字，保证这个文件以<code>&lt;?xml</code>开头</p></li><li><p>找到</p> <figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">string</span>&gt;policyAttributePassword matches <span class="string">&#x27;^$|.&#123;4,&#125;+&#x27;</span>&lt;/<span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure><p> 替换成</p> <figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">string</span>&gt;policyAttributePassword matches <span class="string">&#x27;^$|.&#123;1,&#125;+&#x27;</span>&lt;/<span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure><p> 保存</p></li><li><p><code>sudo pwpolicy setaccountpolicies temp.xml</code></p></li><li><p>此时就可以设置最少字符长度为1个密码了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完整卸载MacOS里的JDK</title>
      <link href="/2018/11/28/uninstall_jdk_in_macos/"/>
      <url>/2018/11/28/uninstall_jdk_in_macos/</url>
      
        <content type="html"><![CDATA[<p>首先，所有的资料在<a href="https://www.java.com/en/download/help/mac_uninstall_java.xml">java官方网站</a>都有提供，我这里做个搬运工，只罗列一下重点。</p><ol><li>下载<a href="https://javadl-esd-secure.oracle.com/update/jut/JavaUninstallTool.dmg">工具</a>，并运行之</li><li>打开终端，执行命令移除相关文件夹<ul><li>sudo rm -fr &#x2F;Library&#x2F;Internet\ Plug-Ins&#x2F;JavaAppletPlugin.plugin </li><li>sudo rm -fr &#x2F;Library&#x2F;PreferencePanes&#x2F;JavaControlPanel.prefPane </li><li>sudo rm -fr ~&#x2F;Library&#x2F;Application\ Support&#x2F;Oracle&#x2F;Java</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL日期字段同时实现新增默认值及修改默认值</title>
      <link href="/2018/10/15/MySQL_column_default_current_timestamp/"/>
      <url>/2018/10/15/MySQL_column_default_current_timestamp/</url>
      
        <content type="html"><![CDATA[<p>如果说<code>MySQL</code>有什么功能是值得我留恋的，那这个功能绝对能排第一。要知道在<code>PostgreSQL</code>实现这么个修改默认值，还非得写个触发器不可，对新手来说太不友好了（具体可参考<a href="https://www.kankanzhijian.com/2018/08/16/PostgreSQL_auto_modify_defaults_1/">PostgreSQL中实现更新默认值</a>）。<br>来看下在<code>MySQL</code>里怎么做，简单的一行</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> datalock <span class="keyword">ADD</span> t_update  <span class="type">timestamp</span> <span class="keyword">default</span> <span class="built_in">current_timestamp</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">current_timestamp</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;变动时间&#x27;</span>;</span><br></pre></td></tr></table></figure><p>就可以把新增默认值、修改默认值同时设置。如果只想设置修改默认值，可以更简单：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> datalock <span class="keyword">ADD</span> t_update  <span class="type">timestamp</span>  <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">current_timestamp</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;变动时间&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用postgrest全自动生成面向表的RESTful接口</title>
      <link href="/2018/10/10/postgrest/"/>
      <url>/2018/10/10/postgrest/</url>
      
        <content type="html"><![CDATA[<p>尝试使用了一下<code>postgrest</code>，用法非常简单，但是功能非常强大。不仅能生成相应的<code>RESTful</code>接口，更是连<code>swagger</code>文档都给准备好了，简直意外惊喜。<br>关于使用，如果有<code>docker</code>经验的话，直接看这个<code>compose</code>文件就好了</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># postgrest.yml</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="symbol">services:</span></span><br><span class="line"><span class="symbol">  server:</span></span><br><span class="line"><span class="symbol">    image:</span> postgrest/postgrest</span><br><span class="line"><span class="symbol">    ports:</span></span><br><span class="line">      - <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line"><span class="symbol">    links:</span></span><br><span class="line">      - db:db</span><br><span class="line"><span class="symbol">    environment:</span></span><br><span class="line"><span class="symbol">      PGRST_DB_URI:</span> postgres:<span class="comment">//app_user:password@db:5432/app_db</span></span><br><span class="line"><span class="symbol">      PGRST_DB_SCHEMA:</span> public</span><br><span class="line"><span class="symbol">      PGRST_DB_ANON_ROLE:</span> app_user <span class="meta">#In production this role should not be the same as the one used for the connection</span></span><br><span class="line"><span class="symbol">    depends_on:</span></span><br><span class="line">      - db</span><br><span class="line"><span class="symbol">  db:</span></span><br><span class="line"><span class="symbol">    image:</span> postgres</span><br><span class="line"><span class="symbol">    ports:</span></span><br><span class="line">      - <span class="string">&quot;5433:5432&quot;</span></span><br><span class="line"><span class="symbol">    environment:</span></span><br><span class="line"><span class="symbol">      POSTGRES_DB:</span> app_db</span><br><span class="line"><span class="symbol">      POSTGRES_USER:</span> app_user</span><br><span class="line"><span class="symbol">      POSTGRES_PASSWORD:</span> password</span><br><span class="line">  <span class="meta"># Uncomment this <span class="keyword">if</span> you want to persist the data.</span></span><br><span class="line">  <span class="meta"># volumes:</span></span><br><span class="line">  <span class="meta">#   - <span class="string">&quot;./pgdata:/var/lib/postgresql/data&quot;</span></span></span><br><span class="line"><span class="symbol">  swagger:</span></span><br><span class="line"><span class="symbol">    image:</span> swaggerapi/swagger-ui</span><br><span class="line"><span class="symbol">    ports:</span></span><br><span class="line">      - <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line"><span class="symbol">    expose:</span></span><br><span class="line">      - <span class="string">&quot;8080&quot;</span></span><br><span class="line"><span class="symbol">    environment:</span></span><br><span class="line"><span class="symbol">      API_URL:</span> http:<span class="comment">//127.0.0.1:3000/</span></span><br></pre></td></tr></table></figure><p>运行命令</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker<span class="literal">-compose</span> <span class="operator">-f</span> postgrest.yml up</span><br></pre></td></tr></table></figure><p>就可以顺利启动好了。浏览器访问<code>http://127.0.0.1:8080</code>，就能看到<code>swagger</code>的界面，而<code>RESTful</code>接口则运行在<code>http://127.0.0.1:3000</code>。<br>当然此时因为没有创建表，所以还没有接口可供使用。只要去数据库创建几张表，再回来刷新<code>swagger</code>页面，就能看到全套的<code>RESTful</code>接口喽。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备份mysql整库并还原到另外一处</title>
      <link href="/2018/10/08/mysql-dump-restore/"/>
      <url>/2018/10/08/mysql-dump-restore/</url>
      
        <content type="html"><![CDATA[<h3 id="全库"><a href="#全库" class="headerlink" title="全库"></a>全库</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqldump -uXXX -pXXX --host=XXX --port=3306 --all-databases --triggers --routines --events --add-drop-database  --skip-add-locks -C| mysql -uXXX -pXXX --host=XXX --port=3306 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="制定数据库"><a href="#制定数据库" class="headerlink" title="制定数据库"></a>制定数据库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uXXX -pXXX --host=XXX --port=3306 --databases db1 db2 --triggers --routines --events --add-drop-database  --skip-add-locks -C| mysql -uXXX -pXXX --host=XXX --port=3306 test</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>徐州贾汪马庄村</title>
      <link href="/2018/09/30/mazhuang-jiawang-xuzhou/"/>
      <url>/2018/09/30/mazhuang-jiawang-xuzhou/</url>
      
        <content type="html"><![CDATA[<p>这是去年（2017年），总书记来徐州考察时着重去的一个村庄。虽然谈不上风景优美，但是环境尚可，村里产的网红香包算是名副其实，最便宜要三十块钱一个，价格也还可以。<br><img src="/media/ORG_DSC04585.jpg"><br><img src="/media/ORG_DSC04583.jpg"><br><img src="/media/ORG_DSC04575.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中使用Python编写存储过程实现科学计算</title>
      <link href="/2018/09/29/PostgreSQL-python-function/"/>
      <url>/2018/09/29/PostgreSQL-python-function/</url>
      
        <content type="html"><![CDATA[<p>作为写进官方文档过程语言支持，<code>Python</code>可说是<code>PostgreSQL</code>中最适合写数据库函数的了。因为<code>Python</code>是宇宙最强胶水语言，能用<code>Python</code>就意味着打开了另一个世界的大门，比如<code>GPU计算</code>、<code>机器学习</code>什么的。当然这是后话了，今天我们先来个简单的，做些与科学计算有关的的东西（这应该也很少有人在数据库上来做）。需要这样几个步骤。</p><h3 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h3><p>至少要在服务上装备好<code>PostgreSQL 10</code>、<code>Python 3</code></p><h3 id="2-安装postgresql-plpython-10扩展"><a href="#2-安装postgresql-plpython-10扩展" class="headerlink" title="2. 安装postgresql-plpython-10扩展"></a>2. 安装<code>postgresql-plpython-10</code>扩展</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> install postgresql-plpython3-10</span><br></pre></td></tr></table></figure><h3 id="3-在PostgreSQL中启用扩展"><a href="#3-在PostgreSQL中启用扩展" class="headerlink" title="3. 在PostgreSQL中启用扩展"></a>3. 在PostgreSQL中启用扩展</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">extension</span> &quot;plpython3u&quot;;</span><br></pre></td></tr></table></figure><h3 id="4-尝试创建一个函数"><a href="#4-尝试创建一个函数" class="headerlink" title="4. 尝试创建一个函数"></a>4. 尝试创建一个函数</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> pymax(a <span class="type">integer</span>, b <span class="type">integer</span>)</span><br><span class="line">  <span class="keyword">returns</span> <span class="type">integer</span></span><br><span class="line"><span class="keyword">language</span> plpython3u</span><br><span class="line"><span class="keyword">as</span> $$<span class="language-ruby"></span></span><br><span class="line"><span class="language-ruby"><span class="keyword">if</span> a &gt; <span class="symbol">b:</span></span></span><br><span class="line"><span class="language-ruby">    <span class="keyword">return</span> a</span></span><br><span class="line"><span class="language-ruby"><span class="keyword">return</span> b</span></span><br><span class="line"><span class="language-ruby"><span class="variable">$$</span></span>;</span><br></pre></td></tr></table></figure><h3 id="5-执行函数"><a href="#5-执行函数" class="headerlink" title="5. 执行函数"></a>5. 执行函数</h3><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">studypg=# select pymax(2, 3);</span><br><span class="line"><span class="section"> pymax</span></span><br><span class="line"><span class="section">-------</span></span><br><span class="line"><span class="code">     3</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><p>结果完美</p><h3 id="6-尝试来点复杂的"><a href="#6-尝试来点复杂的" class="headerlink" title="6. 尝试来点复杂的"></a>6. 尝试来点复杂的</h3><p>这次引用<code>numpy</code>库，用来计算<code>以e为底的自然数对数</code>，其实就是<code>numpy</code>中封装好的<code>log</code>函数啦。</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or replace</span> <span class="keyword">function</span> pylog(x <span class="type">float</span>)</span><br><span class="line">  <span class="keyword">returns</span> <span class="type">float</span></span><br><span class="line"><span class="keyword">language</span> plpython3u</span><br><span class="line"><span class="keyword">as</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">return</span> np.log(x)</span></span><br><span class="line"><span class="language-pgsql">$$</span>;</span><br></pre></td></tr></table></figure><p>执行一下，效果完美</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">studypg=# select pylog(1);</span><br><span class="line"><span class="section"> pylog</span></span><br><span class="line"><span class="section">-------</span></span><br><span class="line"><span class="code">     0</span></span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">studypg=# select pylog(0.1);</span><br><span class="line"><span class="section">       pylog</span></span><br><span class="line"><span class="section">-------------------</span></span><br><span class="line"><span class="code"> -2.30258509299405</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure><p>如果遇到提示</p><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">[<span class="number">38000</span>] <span class="keyword">ERROR</span>: ImportError: No <span class="keyword">module</span> named <span class="comment">&#x27;numpy&#x27;</span></span><br></pre></td></tr></table></figure><p>说明服务器的<code>numpy</code>模块没安装，可以通过下面的命令安装</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> numpy</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此你已经学会了，如何在<code>PostgreSQL</code>中使用<code>Python</code>，以及借助<code>Python</code>生态的力量，去解决传统关系型数据库并未涉足的领域。希望能对你有所帮助。如果你钟爱<code>JavaScript</code>，可以看我之前写的<a href="https://www.kankanzhijian.com/2018/09/09/plv8_in_postgresql">用JavaScript在PostgreSQL中写存储过程</a>，也不失为一个有意思的尝试。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中的行级权限/数据权限/行安全策略</title>
      <link href="/2018/09/28/PostgreSQL-rowsecurity/"/>
      <url>/2018/09/28/PostgreSQL-rowsecurity/</url>
      
        <content type="html"><![CDATA[<p><code>PostgreSQL</code>中是可以针对不同用户，按行过滤数据的，这其实跟管理信息系统里经常提到的<code>数据权限</code>是干一个事情。但是由数据库自身提供这个功能，听起来还是很强大的。真要动手操作起来也并不复杂，主要有这么几个要点：</p><h3 id="1-开启行级权限"><a href="#1-开启行级权限" class="headerlink" title="1. 开启行级权限"></a>1. 开启行级权限</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 目标表名 <span class="keyword">ENABLE</span> <span class="keyword">ROW</span> <span class="keyword">LEVEL</span> <span class="keyword">SECURITY</span>;</span><br></pre></td></tr></table></figure><p>开启行级权限后，除了表的拥有者，其他用户都是默认否定权限，也就是不可能从表中查询到数据，当然其他<code>DML</code>操作也不行。</p><h3 id="2-创建策略"><a href="#2-创建策略" class="headerlink" title="2. 创建策略"></a>2. 创建策略</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">POLICY</span> 起个策略名 <span class="keyword">ON</span> 目标表名 <span class="keyword">TO</span> 目标角色名</span><br><span class="line">    <span class="keyword">USING</span> (一个能返回<span class="type">boolean</span>的表达式);</span><br></pre></td></tr></table></figure><p>当表达式返回<code>true</code>时，该行就是可见的，反之是隐藏的。如果是update或delete一个不符合策略的数据，不会报错，只会略过。</p><h3 id="3-精确到命令的策略"><a href="#3-精确到命令的策略" class="headerlink" title="3. 精确到命令的策略"></a>3. 精确到命令的策略</h3><p>策略是可以精确到<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>以及<code>DELETE</code>的，写在<code>TO</code>之前，用<code>FOR</code>打头，像这样</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">POLICY</span> 起个策略名 <span class="keyword">ON</span> 目标表名 <span class="keyword">FOR</span> 命令名(比如<span class="keyword">select</span>) <span class="keyword">TO</span> 目标角色名</span><br><span class="line">    <span class="keyword">USING</span> (一个能返回<span class="type">boolean</span>的表达式);</span><br></pre></td></tr></table></figure><p>如果不写命令的话，默认是<code>ALL</code></p><h3 id="4-由于支持命令级别的策略，实际的复杂度大大上升了"><a href="#4-由于支持命令级别的策略，实际的复杂度大大上升了" class="headerlink" title="4. 由于支持命令级别的策略，实际的复杂度大大上升了"></a>4. 由于支持命令级别的策略，实际的复杂度大大上升了</h3><p>听我细细讲来：</p><ul><li><code>select</code>、<code>delete</code>是面对现存数据的命令</li><li><code>insert</code>是面对新产生数据的命令</li><li><code>update</code>跨界，它既要面对现存数据，又要产生新数据</li></ul><p>这么看，上面只有一个<code>USING</code>表达式的思路就说不通了，在只有一个<code>USING</code>的情况下，它到底是描述<code>数据的可见性</code>问题还是描述<code>数据的合规性</code>问题呢？这就引出了<code>WITH CHECK</code>表达式。<code>USING</code>负责判断数据的可见性，<code>WITH CHECK</code>符合判断数据的合规性。这里拿<code>update</code>举例子比较合适</p><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">create policy my_policy on users</span><br><span class="line">  for update</span><br><span class="line">  to joe</span><br><span class="line">  using (user_name = current_user)</span><br><span class="line">  with<span class="built_in"> check </span>(age &gt; 18)</span><br></pre></td></tr></table></figure><p>这里<code>USING</code>的表达式限制了只有字段<code>user_name</code>等于当前用户名的数据才可以被编辑（current_user是系统内置变量）；而编辑后的结果，只有<code>age</code>大于18才可以成功存储。用过数据库约束的，现在肯定明白了，<code>with check</code>就是数据库约束嘛，只是这个约束不是面向表的，而是面向角色（用户）的。<br>这也就解释了当用户尝试<code>update</code>它没权限<code>update</code>的数据，并不会报错，而<code>update</code>的数据不满足<code>check</code>时，会收到一个错：</p><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ERROR:  </span>new row violates row-level security policy for table &quot;users&quot;</span><br></pre></td></tr></table></figure><h3 id="5-如果策略不止一个，那它们之间的关系是OR？还是AND？"><a href="#5-如果策略不止一个，那它们之间的关系是OR？还是AND？" class="headerlink" title="5. 如果策略不止一个，那它们之间的关系是OR？还是AND？"></a>5. 如果策略不止一个，那它们之间的关系是<code>OR</code>？还是<code>AND</code>？</h3><p>答案是默认情况是<code>OR</code>，这个叫<code>宽松策略</code>。如果引入<code>RESTRICTIVE</code>关键字就成为<code>限制性策略</code>。其用法如下</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">POLICY</span>  users_managers <span class="keyword">ON</span> users <span class="keyword">as RESTRICTIVE</span>  <span class="keyword">for</span> <span class="keyword">select</span>  <span class="keyword">TO</span> joe  <span class="keyword">using</span>(first_name=<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>所有<code>限制性策略</code>都是<code>AND</code>链接的，在跟<code>宽松策略</code>组合起来使用时，会这么一个情况</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">(宽松策略A <span class="keyword">or </span>宽松策略<span class="keyword">B) </span><span class="keyword">and </span>(限制性策略C <span class="keyword">and </span>限制性策略D)</span><br></pre></td></tr></table></figure><p>不过还有一点要注意，<strong>如果只有限制性策略时不行的，必须先有一个宽松策略才行，这个可以理解成<code>限制性策略</code>必须得跟别人<code>and</code>，如果不提供<code>宽松策略</code>的话，就是<code>and (空)</code>，所以结果只能是空</strong>。</p><h3 id="6-官方文档"><a href="#6-官方文档" class="headerlink" title="6. 官方文档"></a>6. 官方文档</h3><p><code>CREATE POLICY</code>的详细语法解析<a href="http://www.postgres.cn/docs/10/sql-createpolicy.html">在此</a><br><code>行级权限（行安全性策略）</code>的整体解释和示例代码<a href="http://www.postgres.cn/docs/10/ddl-rowsecurity.html">在此</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Safari 12不再支持不安全的扩展</title>
      <link href="/2018/09/27/Safari12_install_safariextz/"/>
      <url>/2018/09/27/Safari12_install_safariextz/</url>
      
        <content type="html"><![CDATA[<p>升级到<code>Safari 12</code>后，好几个浏览器扩展都直接挂了，当我尝试重新安装<code>惠惠购物助手</code>时，出现了如下提示：<br><img src="/media/15380151275481.jpg" alt="Safari浏览器不再支持不安全的扩展"></p><p>现在转过弯了，<code>Safari 12</code>肯定是更新了扩展安装策略。向<code>Chrome</code>的思路靠拢了，没经过官方审核的扩展无法安装。<br>道高一尺，魔高一丈。还是有办法绕过这个机制的。<br>网上搜了一些解决方案，大多没有配图，而且有些步骤还是比较模糊。下面我给出具体步骤：</p><ol><li><p>下载浏览器扩展，此处我以<code>youdaogouwu.safariextz</code>为例</p></li><li><p>解压<code>youdaogouwu.safariextz</code>，这里有个关键点，用老办法重命名后缀为<code>zip</code>是无法解压的。但是重命名后缀为<code>rar</code>就可以了。这可能跟你电脑里装的软件解压工具有关。我电脑里装的是<code>keka</code>。解压成功后如图：<img src="/media/15380172675854.jpg"></p></li><li><p>打开<code>Safari</code>的设置，找到<code>高级</code>，勾选<code>在菜单栏中显示“开发”菜单</code>，如图：<img src="/media/15380173560777.jpg"></p></li><li><p>在<code>开发</code>菜单中找到<code>显示扩展构建器</code>，如图：<img src="/media/15380174874853.jpg"></p></li><li><p>打开之，找到左下角的<code>➕</code>，选<code>添加扩展</code>，如图：<img src="/media/15380182351986.jpg"></p></li><li><p>之后在弹框中选择直接解压后文件中的文件夹<code>YoudaoGouwu.safariextension</code>，如图：<img src="/media/15380177660522.jpg"></p></li><li><p>之后就会在<code>扩展构建器</code>中看到<code>惠惠购物助手</code>了，然后点击右上角的运行，如图：<img src="/media/15380183216923.jpg"></p></li><li><p>按提示输入一次密码后大功告成，现在回到<code>Safari</code>的设置中，就可以看到<code>惠惠购物助手</code>已经安装完毕了：<img src="/media/15380180870297.jpg"></p></li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>上面解压缩的文件夹不可以删除，如果删除，当<code>Safari</code>重启后，扩展也会跟着丢失。所以记得好好保存。</p>]]></content>
      
      
      <categories>
          
          <category> 工具技巧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Java收费政策的解读</title>
      <link href="/2018/09/26/java_is_still_free/"/>
      <url>/2018/09/26/java_is_still_free/</url>
      
        <content type="html"><![CDATA[<p>随着<code>Java 11</code>的正式推出，关于<code>Java</code>收费的言论又开始甚嚣尘上。然后国外一众大神，写了这篇著名的<a href="https://itnext.io/java-is-still-free-c02aef8c9e04">Java Is Still Free</a>。我总结一下其中的重点，供你参考（这里只谈商业用途，这才是各位老板最关心的）：</p><ol><li><p>如果你在使用<code>Oracle JDK8</code> ，那么到<code>2019年1月</code>之后将不会获得免费的更新。如果需要更新就得考虑付费。如果不在乎更新的话，继续随便用，没毛病。</p></li><li><p>从<code>JDK 9</code>开始（    2017年9月发布），每六个月，就会发布一个大版本，如下表</p><table><thead><tr><th>版本</th><th>发布时间</th></tr></thead><tbody><tr><td>9</td><td>2017年9月</td></tr><tr><td>10</td><td>2018年3月</td></tr><tr><td>11</td><td>2018年9月</td></tr><tr><td>12</td><td>2019年3月</td></tr><tr><td>13</td><td>2019年9月</td></tr></tbody></table></li><li><p>一旦有新的大版本发布，上一个版本的<code>Oracle JDK</code>将不再提供免费的更新维护。此时你有三个选择：</p><ul><li>升级到最新的<code>Oracle JDK</code></li><li>使用<code>Open JDK</code></li><li>给<code>Oracle</code>付费，仍可对当前版本获得更新</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>不在乎更新的，随便耍</li><li>在乎更新的，并且能紧跟<code>Oracle</code>步伐的，没影响，继续用最新版的<code>Oracle JDK</code>就是</li><li>想及时获取补丁，但又不习惯半年升级一次大版本的，就用<code>Open JDK</code></li><li><code>Open JDK</code>的供应商很多，甚至自己编译都行，这里我推荐<a href="https://www.azul.com/downloads/zulu/">zulu</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中对用户重命名需要注意的</title>
      <link href="/2018/09/25/PostgreSQL_rename_notice/"/>
      <url>/2018/09/25/PostgreSQL_rename_notice/</url>
      
        <content type="html"><![CDATA[<p>在<code>PostgreSQL</code>中，如果需要对数据库用户重命名，其实很简单，就是</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="type">name</span> <span class="keyword">RENAME</span> <span class="keyword">TO</span> new_name</span><br></pre></td></tr></table></figure><p>但是你会收到一个提示</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">NOTICE</span>:  MD5 <span class="keyword">password</span> cleared because <span class="keyword">of</span> <span class="keyword">role</span> <span class="keyword">rename</span></span><br></pre></td></tr></table></figure><p>这里面传递了两个信息：</p><ol><li>改用户名，就是改角色名，因为在<code>PostgreSQL</code>中，用户等价于角色，唯一的区别就是，角色分可以登陆和不可以登陆的，而用户就是能登陆的角色。</li><li>改了用户名，密码就丢了。</li></ol><p>今天主要讨论的，就是上面第二点问题。为啥<strong>改个用户名，密码就给我干掉了？</strong>，这很违背常识。<br>但其实是有原因的：</p><ul><li>首先，<code>PostgreSQL</code>中存放的密码，是MD5加密的，当然是不可逆的，这个大家能理解。<br>  这个通过这条<code>SQL</code>能够查到  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> rolname,rolpassword <span class="keyword">FROM</span> pg_authid;</span><br></pre></td></tr></table></figure></li><li>但是<code>rolpassword</code>并不是<code>md5(password)</code>直接得出的，里面存的其实是  <figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;md5&quot;</span>+<span class="function"><span class="title">md5</span>(<span class="variable">username</span>+<span class="variable">password</span>)</span></span><br></pre></td></tr></table></figure>  这么一个情况，也就是说，如果你设置<code>joe</code>用户的密码是<code>xyz</code>的话，实际上<code>rolpassword</code>列存的值，相当于  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;md5&#x27;</span>||md5(<span class="string">&#x27;joe&#x27;</span>||<span class="string">&#x27;xyz&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li>这就解释了，为什么用户名改了，密码就丢了。因为用户名本就是密码的一部分，如果加密过后的值不跟着改变的话，新的用户名沿用固定的算法，是无法登陆的。而<code>PostgreSQL</code>永远也不会知道曾经的密码是多少，所以不能自动帮用户更新<code>rolpassword</code>，这就只能靠用户自己重新设置一次密码了。</li><li>说白了，<code>PostgreSQL</code>也是好心，她是有苦衷的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在git中使用submodule</title>
      <link href="/2018/09/23/submodule_in_git/"/>
      <url>/2018/09/23/submodule_in_git/</url>
      
        <content type="html"><![CDATA[<p>如果<code>clone</code>一个项目后，发现其中有<code>.gitmodules</code>文件，就说明这个项目是包含子项目的。这个文件的产生，是由于在一个<code>git</code>项目内，执行命令</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">submodule </span><span class="keyword">add </span>a_git_project_path rack</span><br></pre></td></tr></table></figure><p>最后一个参数是创建文件夹的名字，这个跟执行<code>git clone</code>时的用法一样。<br>当<code>clone</code>项目后发现存在<code>.gitmodules</code>文件后。可以注意观察下，相关的submodule对应的文件夹里，是没有内容的。此时需要通过</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">submodule </span>init</span><br><span class="line">git <span class="keyword">submodule </span>update</span><br></pre></td></tr></table></figure><p>分别初始化submodule和获取其数据。<br>有了<code>submodule</code>的存在，我们可以很方便的拆分一个大项目到若干小项目，方便多人合作开发。<br>下一次，我将就<code>submodule</code>的嵌套性展开测试。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中文文档正确的搜索方式</title>
      <link href="/2018/09/21/PostgreSQL_doc_search/"/>
      <url>/2018/09/21/PostgreSQL_doc_search/</url>
      
        <content type="html"><![CDATA[<p>今天介绍的主要是搜索引擎使用技巧，其实跟<code>PostgreSQL</code>关系不大，仅仅以对<code>PostgreSQL</code>的中文文档搜搜举个例子。<br>比如想了解<code>PostgreSQL</code>关于<code>string</code>类型的数据库内置函数。最直观的搜索方式，是去<code>google</code>搜<code>postgres string function</code>，这当然是一种符合直觉方式。通常情况下<code>google</code>给出的结果会不赖，如图：<img src="/media/15375090092852.jpg"><br>但是有个问题，默认搜到的内容都是英文的，这可能不利于中国的小伙伴细致地学习。但其实，我们已经有一个汉化过的文档版本，静静地躺在<a href="http://www.postgres.cn/">PostgreSQL 中文社区</a>，并且社区提供多个版本的汉化文档，比如：<a href="http://www.postgres.cn/docs/10/">10</a>、<a href="http://www.postgres.cn/docs/9.6/">9.6</a><br>我们最理想的，就是期望<code>google</code>能把关键词的搜索范围限制在中文文档的地址内。其实这对搜索引擎是个再常见不过的需求了，很多小伙伴也早就知道了，那就是<code>site:</code>。<br>当我们希望把<code>postgres string function</code>的搜索范围仅限制在中文文档<a href="http://www.postgres.cn/docs/10/">10</a>这个版本上时，仅需要在之前的搜索内容中增加<code>site</code>关键字限制范围，最终输入给<code>google</code>如下</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">postgres string <span class="keyword">function</span> site:http:<span class="regexp">//</span>www.postgres.cn<span class="regexp">/docs/</span><span class="number">10</span></span><br></pre></td></tr></table></figure><p><em>（其实上面的postgres也可以省略了）</em></p><p>来看看结果吧：<img src="/media/15375096548094.jpg"><br>现在看起来就很完美了，</p>]]></content>
      
      
      <categories>
          
          <category> 工具技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx中使用rewrite重定向</title>
      <link href="/2018/09/20/nginx_rewrite/"/>
      <url>/2018/09/20/nginx_rewrite/</url>
      
        <content type="html"><![CDATA[<p><code>nginx</code>中配置重定向，虽然有下面这种写法</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">return <span class="number">301</span> https:<span class="regexp">//</span>www.yourdomain.com<span class="variable">$request_uri</span>;</span><br></pre></td></tr></table></figure><p>但是仍不及<code>rewrite</code>好用强大。其基本语法是</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Syntax:</span>rewrite regex replacement [flag]<span class="comment">;</span></span><br><span class="line"><span class="symbol">Default:</span>—</span><br><span class="line"><span class="symbol">Context:</span>server, location, if</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> https://www.qxnaqy.com <span class="literal">permanent</span>;</span><br></pre></td></tr></table></figure><p><code>rewrite</code>后面紧跟的是正则表达式，用来匹配url。而<code>replacement</code>可以是<code>http</code>开头的绝对路径，就会触发重定向。如果不是绝对路径，则默认是触发重写。<br>重定向与重写的区别是，前者是浏览器有感知的，通过<code>302</code>、<code>301</code>通知浏览器url资源发生了变化，由浏览器再次发起请求，访问目标路径；后者是浏览器无感知的，由<code>nginx</code>延续接下来已改变的请求。<br>但是如果<code>flag</code>指定了<code>redirect</code>或者<code>permanent</code>时，一定是触发的重定向。<br>文档中关于<code>flag</code>的解释如下</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">last</span><br><span class="line">stops processing the <span class="keyword">current</span> <span class="keyword">set</span> <span class="keyword">of</span> ngx_http_rewrite_module directives <span class="keyword">and</span> starts a <span class="keyword">search</span> <span class="keyword">for</span> a <span class="built_in">new</span> <span class="keyword">location</span> matching the changed URI;</span><br><span class="line">break</span><br><span class="line">stops processing the <span class="keyword">current</span> <span class="keyword">set</span> <span class="keyword">of</span> ngx_http_rewrite_module directives <span class="keyword">as</span> <span class="keyword">with</span> the break directive;</span><br><span class="line">redirect</span><br><span class="line"><span class="keyword">returns</span> a <span class="keyword">temporary</span> redirect <span class="keyword">with</span> the <span class="number">302</span> code; used <span class="keyword">if</span> a replacement string does <span class="keyword">not</span> <span class="keyword">start</span> <span class="keyword">with</span> “http://”, “https://”, <span class="keyword">or</span> “$scheme”;</span><br><span class="line">permanent</span><br><span class="line"><span class="keyword">returns</span> a permanent redirect <span class="keyword">with</span> the <span class="number">301</span> code.</span><br></pre></td></tr></table></figure><p>也就是说，如果想做<code>301</code>重定向，务必使用<code>permanent</code>，如果想做<code>302</code>，根据<code>replacement</code>的内容来决定是否使用<code>redirect</code>。<br><code>last</code>的意思是，命中更改的<code>uri</code>之后，接着拿新的<code>uri</code>尝试匹配。这就会出现一种情况，当新的<code>uri</code>规则又满足之前匹配模式，就会进入一种死循环状态，所以就引入了<code>break</code>。可以参考文档中的这段</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">The full redirect URL is formed according to the request scheme (<span class="variable">$scheme</span>) and the server_name_in_redirect and port_in_redirect directives.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    rewrite ^(<span class="regexp">/download/</span>.*)<span class="regexp">/media/</span>(.*)\..*$ <span class="variable">$1</span><span class="regexp">/mp3/</span><span class="variable">$2</span>.mp3 last;</span><br><span class="line">    rewrite ^(<span class="regexp">/download/</span>.*)<span class="regexp">/audio/</span>(.*)\..*$ <span class="variable">$1</span><span class="regexp">/mp3/</span><span class="variable">$2</span>.ra  last;</span><br><span class="line">    return  <span class="number">403</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">But <span class="keyword">if</span> these directives are put inside the “<span class="regexp">/download/</span>” location, the last flag should be replaced by <span class="keyword">break</span>, or otherwise nginx will make <span class="number">10</span> cycles and return the <span class="number">500</span> error:</span><br><span class="line"></span><br><span class="line">location <span class="regexp">/download/</span> &#123;</span><br><span class="line">    rewrite ^(<span class="regexp">/download/</span>.*)<span class="regexp">/media/</span>(.*)\..*$ <span class="variable">$1</span><span class="regexp">/mp3/</span><span class="variable">$2</span>.mp3 <span class="keyword">break</span>;</span><br><span class="line">    rewrite ^(<span class="regexp">/download/</span>.*)<span class="regexp">/audio/</span>(.*)\..*$ <span class="variable">$1</span><span class="regexp">/mp3/</span><span class="variable">$2</span>.ra  <span class="keyword">break</span>;</span><br><span class="line">    return  <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用certbot-auto给nginx加上免费https证书</title>
      <link href="/2018/09/19/certbot-auto_nginx/"/>
      <url>/2018/09/19/certbot-auto_nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="准备python3环境"><a href="#准备python3环境" class="headerlink" title="准备python3环境"></a>准备python3环境</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 非唯一方法，仅供参考</span></span><br><span class="line">yum <span class="keyword">install </span>rh-python36</span><br><span class="line"><span class="keyword">scl </span>enable rh-python36 <span class="keyword">bash</span></span><br></pre></td></tr></table></figure><h3 id="准备certbot-auto工具"><a href="#准备certbot-auto工具" class="headerlink" title="准备certbot-auto工具"></a>准备<code>certbot-auto</code>工具</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">wget https:<span class="comment">//dl.eff.org/certbot-auto</span></span><br><span class="line">chmod +x certbot-<span class="built_in">auto</span></span><br></pre></td></tr></table></figure><h3 id="准备nginx站点"><a href="#准备nginx站点" class="headerlink" title="准备nginx站点"></a>准备nginx站点</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> nginx</span><br></pre></td></tr></table></figure><p>然后去<code>/etc/nginx/conf.d/</code>准备自己的站点配置文件，命名为<code>www.yourdomain.com.conf</code><br>最简单的配置内容如下：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       <span class="number">80</span> ;</span><br><span class="line">        server_name  www.yourdomain.com;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">location</span> <span class="title">/ &#123;</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">        error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">            <span class="keyword">location</span> <span class="title">= /40x</span>.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /<span class="number">50</span>x.html;</span><br><span class="line">            <span class="keyword">location</span> <span class="title">= /50x</span>.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="运行certbot-auto"><a href="#运行certbot-auto" class="headerlink" title="运行certbot-auto"></a>运行<code>certbot-auto</code></h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./certbot-auto</span> <span class="params">--nginx</span></span><br></pre></td></tr></table></figure><p>之后根据向导一步步操作即可，大概就是输入一下自己的有效邮箱，输入几个<code>Y</code>（同意），选一下刚创建的那个<code>nginx</code>配置文件就ok了。<br>如果出现</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">No supported Python <span class="keyword">package</span> <span class="title">available to install. Aborting bootstrap!</span></span><br></pre></td></tr></table></figure><p>可以尝试这个命令</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./certbot-auto</span> <span class="params">--nginx</span> <span class="params">--no-bootstrop</span></span><br></pre></td></tr></table></figure><h3 id="定时更新证书"><a href="#定时更新证书" class="headerlink" title="定时更新证书"></a>定时更新证书</h3><p>默认证书的有效期是90天，所以我们需要设置定时任务，隔断时间就<code>renew</code>下，通过<code>crontab -e</code>配置即可，内容如下</p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">3</span> * * * /root/letsencrypt/certbot-<span class="keyword">auto</span> renew --quiet</span><br></pre></td></tr></table></figure><p><code>renew</code>命令会在确定证书快要到期的时候，才真正<code>renew</code>证书的。</p><h3 id="其他技巧："><a href="#其他技巧：" class="headerlink" title="其他技巧："></a>其他技巧：</h3><ul><li><code>debug</code>，访问<a href="https://letsdebug.net/">https://letsdebug.net</a></li><li>查看证书情况（有效期），访问<a href="https://crt.sh/">https://crt.sh</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习入门 矩阵的乘法</title>
      <link href="/2018/09/18/deep_learning_start_matrix_dot/"/>
      <url>/2018/09/18/deep_learning_start_matrix_dot/</url>
      
        <content type="html"><![CDATA[<p>刚开始看<code>《深度学习入门 基于Python的理论与实现》</code>，非常好的一本书。<br>复习一个重要的知识点，矩阵的乘法：<img src="/media/IMG_6764.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ios12中关闭app内购</title>
      <link href="/2018/09/17/ios12_close_In-App_Purchase/"/>
      <url>/2018/09/17/ios12_close_In-App_Purchase/</url>
      
        <content type="html"><![CDATA[<p>之前版本的<code>IOS</code>中，是通过<code>访问限制</code>菜单，限制应用程序内购的。这个功能在<code>设置</code>-&gt;<code>通用</code>下可以找到。然后在<code>IOS12</code>中，我们已经找不到了。很显然，它被挪到了另一个地方。当然还是能找到的</p><h2 id="设置中，找到屏幕使用时间"><a href="#设置中，找到屏幕使用时间" class="headerlink" title="设置中，找到屏幕使用时间"></a>设置中，找到<code>屏幕使用时间</code></h2><p><img src="/media/IMG_7610.png" alt="IMG_7610"></p><h2 id="然后选择内容和隐私访问限制"><a href="#然后选择内容和隐私访问限制" class="headerlink" title="然后选择内容和隐私访问限制"></a>然后选择<code>内容和隐私访问限制</code></h2><p><img src="/media/IMG_7611.png" alt="IMG_7611"></p><h2 id="找到iTunes-Store与App-Store购买项目"><a href="#找到iTunes-Store与App-Store购买项目" class="headerlink" title="找到iTunes Store与App Store购买项目"></a>找到<code>iTunes Store与App Store购买项目</code></h2><p><img src="/media/IMG_7612.png" alt="IMG_7612"></p><h2 id="就可以管理是否允许内购了"><a href="#就可以管理是否允许内购了" class="headerlink" title="就可以管理是否允许内购了"></a>就可以管理是否允许内购了</h2><p><img src="/media/IMG_7613.png" alt="IMG_7613"></p>]]></content>
      
      
      <categories>
          
          <category> 工具技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reactive-pg-client中的数据库事务</title>
      <link href="/2018/09/16/transaction_in_reactive-pg-client/"/>
      <url>/2018/09/16/transaction_in_reactive-pg-client/</url>
      
        <content type="html"><![CDATA[<p>使用<code>reactive-pg-client</code>中的数据库事务有两种写法，一种是通过<code>PgConnection</code>的<code>begin</code>方法，开启一段数据库事务；另一种是通过<code>PgPool</code>的<code>begin</code>方法。<br>先来看第一种：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">pool.getConnection(res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line"></span><br><span class="line">    // <span class="keyword">Transaction</span> must use a <span class="keyword">connection</span></span><br><span class="line">    PgConnection conn = res.result();</span><br><span class="line"></span><br><span class="line">    // <span class="keyword">Begin</span> the <span class="keyword">transaction</span></span><br><span class="line">    PgTransaction tx = conn.<span class="keyword">begin</span>();</span><br><span class="line"></span><br><span class="line">    // Various statements</span><br><span class="line">    conn.query(&quot;INSERT INTO Users (first_name,last_name) VALUES (&#x27;Julien&#x27;,&#x27;Viet&#x27;)&quot;, ar -&gt; &#123;&#125;);</span><br><span class="line">    conn.query(&quot;INSERT INTO Users (first_name,last_name) VALUES (&#x27;Emad&#x27;,&#x27;Alblueshi&#x27;)&quot;, ar -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    // <span class="keyword">Commit</span> the <span class="keyword">transaction</span></span><br><span class="line">    tx.<span class="keyword">commit</span>(ar -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Transaction succeeded&quot;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Transaction failed &quot; + ar.cause().getMessage());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // <span class="keyword">Return</span> the <span class="keyword">connection</span> <span class="keyword">to</span> the pool</span><br><span class="line">      conn.<span class="keyword">close</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再看第二种：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">pool.<span class="keyword">begin</span>(res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line"></span><br><span class="line">    // <span class="keyword">Get</span> the <span class="keyword">transaction</span></span><br><span class="line">    PgTransaction tx = res.result();</span><br><span class="line"></span><br><span class="line">    // Various statements</span><br><span class="line">    tx.query(&quot;INSERT INTO Users (first_name,last_name) VALUES (&#x27;Julien&#x27;,&#x27;Viet&#x27;)&quot;, ar -&gt; &#123;&#125;);</span><br><span class="line">    tx.query(&quot;INSERT INTO Users (first_name,last_name) VALUES (&#x27;Emad&#x27;,&#x27;Alblueshi&#x27;)&quot;, ar -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    // <span class="keyword">Commit</span> the <span class="keyword">transaction</span> <span class="keyword">and</span> <span class="keyword">return</span> the <span class="keyword">connection</span> <span class="keyword">to</span> the pool</span><br><span class="line">    tx.<span class="keyword">commit</span>(ar -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Transaction succeeded&quot;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Transaction failed &quot; + ar.cause().getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到第二种写法更为精简，<code>Handler</code>内部直接可以拿到<code>PgTransaction</code>，不需要像第一种那样使用<code>PgConnection</code>的<code>begin</code>才能得到<code>PgTransaction</code>，并且因为第二种不存在直接操纵<code>PgConnection</code>，自然也省略了手动<code>close</code>的步骤。<br>经过我自己测试，有两点需要注意一下：</p><ul><li><code>PgTransaction</code>可以通过<code>abortHandler</code>方法，捕捉到事务失败（如果失败的话）的事件。</li><li>在使用事务的过程中，想通过<code>preparedQuery</code>使用预编译的<code>SQL</code>未能成功，目前原因未知。</li></ul><p>详细的演示代码，可以在我的<a href="https://github.com/aruis/studyvertx/blob/master/src/test/groovy/com/aruistar/studyvertx/ReactivePostgresClientTest.groovy">github</a>中找到。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reactive-pg-client实现数据库到应用程序的数据推送</title>
      <link href="/2018/09/15/reactive-pg-client_notify/"/>
      <url>/2018/09/15/reactive-pg-client_notify/</url>
      
        <content type="html"><![CDATA[<p>昨天聊过，依托<code>reactive-pg-client</code>可以做很多传统<code>JDBC</code>无法实现的事情，比如<code>PostgreSQL</code>的消息推送（<code>notify</code>和<code>listen</code>）。有了这种功能，我们就可以轻易实现从数据库层主向业务逻辑代码推送消息的功能。可以说，又一次为我们打开了新世界的大门。</p><h3 id="先来回顾下PostgreSQL的notify和listen"><a href="#先来回顾下PostgreSQL的notify和listen" class="headerlink" title="先来回顾下PostgreSQL的notify和listen"></a>先来回顾下<code>PostgreSQL</code>的<code>notify</code>和<code>listen</code></h3><p>主要参考<a href="http://www.postgres.cn/docs/10/sql-notify.html">官方文档</a>，其实非常简单，核心<code>SQL</code>就两句话：</p><ul><li>发消息：  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">NOTIFY channel_name<span class="comment">;</span></span><br></pre></td></tr></table></figure>  <code>NOTIFY</code>是一个关键字，后面跟着的第一参数是，频道的名字，这个是用户随便定义的，只要之后跟<code>LISTEN</code>的保持一致即可。<code>NOTIFY</code>还有第二个可选参数，就是消息内容，类型也必须是字符串，并且长度限制在<code>8000</code>字节。<br>  <code>NOTIFY channel_name message_body</code>还有一种等效的写法，也就是  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_notify(channel_name，message_body）</span><br></pre></td></tr></table></figure>  后者的好处是可以用到<code>SQL</code>的预编译特性。</li><li>收消息：  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">LISTEN channel_name<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul><p>这里补充几个知识点：</p><ul><li><code>NOTIFY</code>&#x2F;<code>LISTEN</code>这些语法不是<code>SQL</code> 标准，属于<code>PostgreSQL</code>特有的功能</li><li>跟<code>LISTEN</code>相反的，有<code>UNLISTEN</code>可供使用</li><li><code>NOTIFY</code>是广播模式，也就是所有同频道的<code>LISTEN</code>都能接收到信息</li><li>先<code>NOTIFY</code>，再<code>LISTEN</code>是没有效果的。这个也符合直觉。</li><li>想测试的话，最好借助<code>PostgreSQL</code>自带的<code>psql</code>环境，可以很容易测试，其他<code>SQL</code>客户端程序可能就没那么友好了。</li></ul><h3 id="有了PostgreSQL的基础知识储备，我们就可以用reactive-pg-client尝试一把了"><a href="#有了PostgreSQL的基础知识储备，我们就可以用reactive-pg-client尝试一把了" class="headerlink" title="有了PostgreSQL的基础知识储备，我们就可以用reactive-pg-client尝试一把了"></a>有了<code>PostgreSQL</code>的基础知识储备，我们就可以用<code>reactive-pg-client</code>尝试一把了</h3><p>直接上代码</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">pgClient.getConnection &#123;</span><br><span class="line">           def conn = it.result()</span><br><span class="line"></span><br><span class="line">           conn.notificationHandler(&#123; notification -&gt;</span><br><span class="line">               println(<span class="string">&quot;Received $&#123;notification.payload&#125; on channel $&#123;notification.channel&#125;&quot;</span>)</span><br><span class="line">               context.assertEquals(notification.payload, message)</span><br><span class="line">               context.assertEquals(notification.channel, channelName)</span><br><span class="line">               async.complete()</span><br><span class="line">           &#125;)</span><br><span class="line"></span><br><span class="line">           conn.preparedQuery(<span class="string">&quot;LISTEN $channelName&quot;</span>, &#123; ar -&gt;</span><br><span class="line">               println(<span class="string">&quot;Subscribed to channel&quot;</span>)</span><br><span class="line"></span><br><span class="line">               conn.preparedQuery(<span class="string">&#x27;&#x27;&#x27;select pg_notify($1,$2)&#x27;&#x27;&#x27;</span>, Tuple.of(channelName, message), &#123;&#125;)</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>没什么复杂的，通过<code>reactive-pg-client</code>拿到<code>connection</code>之后，先用这个<code>connection</code>注册个<code>notificationHandler</code>用来接收消息。但是此时还不够，还必须在同<code>connection</code>上执行<code>LISTEN</code>的<code>SQL</code>语句，才能保证之前的<code>notificationHandler</code>是有效的。至于<code>NOTIFY</code>语句并不要求非要用这个<code>connection</code>，这也是符合我们业务需求的。<br>以上完整代码，可以在我的<a href="https://github.com/aruis/studyvertx/blob/master/src/test/groovy/com/aruistar/studyvertx/ReactivePostgresClientTest.groovy">github</a>中找到。<br>上面我是在当前代码中，手动<code>NOTIFY</code>的，我们完全可以吧<code>NOTIFY</code>放在数据库的触发器、或者数据库定时任务中，就可以实现数据库到应用程序的数据推送了。另外经测试，<code>NOTIFY</code>与<code>LISTEN</code>两个语法在<code>JDBC</code>环境下也是可以执行成功的（<code>SQL</code>不会报错），只是<code>LISTEN</code>不会有任何效果就是了。</p><p>明天，我将演示基于<code>reactive-pg-client</code>的数据库事务demo。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能封神的数据库访问库reactive-pg-client初探</title>
      <link href="/2018/09/14/reactive-pg-client_start/"/>
      <url>/2018/09/14/reactive-pg-client_start/</url>
      
        <content type="html"><![CDATA[<p>不知道有没有人关注过TechEmpower的<code>Web Framework Benchmarks</code>（<a href="https://www.techempower.com/benchmarks/">https://www.techempower.com/benchmarks/</a> ），一种把各种<code>Web</code>后端开发技术都罗列起来，在同样的机器下跑最简单的业务逻辑，来对比各技术性能的竞赛。参与跑分的技术代码，都是开源的，甚至很多代码就是由<code>Web</code>技术本身的作者维护的。<br>虽说，跑分不能代表性能，性能更不能代表技术的优劣。但是有着么一个性能维度的粗浅比较，还是能带给我们不一样的收获。<br>比如，在<code>2018-06-06</code>的最新一场比拼中，<code>Vert.x</code>搭配<code>PostgreSQL</code>的组合，在部分比试时表现十分抢眼，性能一骑绝尘且大幅领先第二名。被它踩在脚下摩擦的对手，不乏我们熟知的技术方案，比如<code>go</code>、<code>nodejs</code>、<code>spring</code>、<code>php</code>，还有<code>mysql</code>、<code>mongodb</code>等数据库。（这里我无意引战，有兴趣的朋友可以查看具体<a href="https://www.techempower.com/benchmarks/#section=data-r16&hw=ph&test=db">跑分结果</a>及<a href="https://github.com/TechEmpower/FrameworkBenchmarks/tree/round16">相关代码</a>）<br>查看具体跑分<a href="https://github.com/TechEmpower/FrameworkBenchmarks/blob/724a773096f403d149cfaf59b8257465bbf70103/frameworks/Java/vertx/src/main/java/vertx/App.java">代码</a>可知，<code>Vert.x</code>之所以能位居榜首，与其使用的数据库客户端是密不可分的。作为一套基于<code>Java</code>的技术解决方案，<code>Vert.x</code>没有使用<code>Java</code>程序员所熟知的<code>JDBC</code>，而是使用了一种叫<a href="https://github.com/reactiverse/reactive-pg-client">reactive-pg-client</a>的技术。<br><code>reactive-pg-client</code>与<code>JDBC</code>最大的区别就是前者是针对<code>PostgreSQL</code>数据库单独开发的，利用了<code>PostgreSQL</code>异步特性，最大限度了挖掘了数据库的访问性能。<br>现在我们就来简单尝试下<code>reactive-pg-client</code>，首先添加依赖</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">compile</span> &#x27;io.reactiverse:reactive-pg-client:<span class="number">0</span>.<span class="number">10</span>.<span class="number">3</span>&#x27;</span><br></pre></td></tr></table></figure><p>准备<code>PgPoolOptions</code></p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">PgPoolOptions options = <span class="keyword">new</span> <span class="constructor">PgPoolOptions()</span></span><br><span class="line">  .set<span class="constructor">Port(5432)</span></span><br><span class="line">  .set<span class="constructor">Host(<span class="string">&quot;the-host&quot;</span>)</span></span><br><span class="line">  .set<span class="constructor">Database(<span class="string">&quot;the-db&quot;</span>)</span></span><br><span class="line">  .set<span class="constructor">User(<span class="string">&quot;user&quot;</span>)</span></span><br><span class="line">  .set<span class="constructor">Password(<span class="string">&quot;secret&quot;</span>)</span></span><br><span class="line">  .set<span class="constructor">MaxSize(5)</span>;</span><br></pre></td></tr></table></figure><p>接下来就可以用了</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the client pool</span></span><br><span class="line">PgPool client = PgClient.pool(<span class="keyword">options</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A simple query</span></span><br><span class="line">client.query(<span class="string">&quot;SELECT * FROM users WHERE id=&#x27;julien&#x27;&quot;</span>, ar -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">    PgRowSet result = ar.result();</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">&quot;Got &quot;</span> + result.<span class="keyword">size</span>() + <span class="string">&quot; rows &quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(<span class="string">&quot;Failure: &quot;</span> + ar.cause().getMessage());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now close the pool</span></span><br><span class="line">  client.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>典型的异步代码编写风格，正是由于该库先天异步的特性，我们可以用一个线程，就能控制多个数据库链接（The client is reactive and non blocking, allowing to handle many database connections with a single thread.），籍此获得更好的计算机资源利用率，从而提高性能。更多信息请查看官方文档<a href="https://reactiverse.io/reactive-pg-client/guide/java/">reactive-pg-client</a></p><p>明天，我将继续深入<code>reactive-pg-client</code>，带你尝试<code>PostgreSQL</code>独有的<code>NOTIFY</code>特性，实现从数据库端到业务程序段的数据主动推送。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给异步的Vert.x程序做单元测试</title>
      <link href="/2018/09/13/vertx_unit_test/"/>
      <url>/2018/09/13/vertx_unit_test/</url>
      
        <content type="html"><![CDATA[<p>异步的程序先天不好单元测试，尤其是按照传统的<code>JUnit</code>思路来弄，肯定是不行的。好在<code>Vert.x</code>想到了这一点，所以提供了<code>vertx-unit</code>包，专门考虑了对异步代码的测试。<br>使用起来也很简单，首先</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">testCompile</span> <span class="string">&quot;io.vertx:vertx-unit:3.5.3&quot;</span></span><br></pre></td></tr></table></figure><p>然后创建一个测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(VertxUnitRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUnitTestSuite</span> &#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSomething</span><span class="params">(TestContext context)</span> &#123;</span><br><span class="line">    context.assertFalse(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要是测试异步程序，只需要调用<code>TestContext</code>的<code>async()</code>方法即可。然后直到手动调用其<code>complete()</code>方法，整个测试过程才会结束。请看例子：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="built_in">void</span> <span class="title function_">testSomething</span>(<span class="params">TestContext context</span>) &#123;</span><br><span class="line">    def <span class="keyword">async</span> = context.<span class="title function_">async</span>()</span><br><span class="line">    <span class="title class_">Vertx</span>.<span class="title function_">vertx</span>().<span class="title function_">setTimer</span>(<span class="number">3000</span>, &#123;</span><br><span class="line">        context.<span class="title function_">assertFalse</span>(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">async</span>.<span class="title function_">complete</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>async</code>方法的注释写得还是很详细的</p><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">and</span> returns a <span class="keyword">new</span> <span class="keyword">async</span> object, the returned <span class="keyword">async</span> controls the completion <span class="keyword">of</span> the test. Calling the <span class="keyword">Async</span>.complete() completes the <span class="keyword">async</span> operation.</span><br><span class="line"></span><br><span class="line">The test <span class="keyword">case</span> will complete when all the <span class="keyword">async</span> objects have their <span class="keyword">Async</span>.complete() <span class="keyword">method</span> <span class="title function_">called</span> <span class="title function_">at</span> <span class="title function_">least</span> <span class="title function_">once</span>.</span><br><span class="line"></span><br><span class="line"><span class="title function_">This</span> <span class="title function_">method</span> <span class="title function_">shall</span> <span class="title function_">be</span> <span class="title function_">used</span> <span class="title function_">for</span> <span class="title function_">creating</span> <span class="title function_">asynchronous</span> <span class="title function_">exit</span> <span class="title function_">points</span> <span class="title function_">for</span> <span class="title function_">the</span> <span class="title function_">executed</span> <span class="title function_">test</span>.</span><br></pre></td></tr></table></figure><p>更多内容请参考官方文档：<a href="https://vertx.io/docs/vertx-unit/java/">vertx-unit</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再谈CompletableFuture</title>
      <link href="/2018/09/12/CompletableFuture_something/"/>
      <url>/2018/09/12/CompletableFuture_something/</url>
      
        <content type="html"><![CDATA[<p>今天是还之前欠的一个账，当时在<a href="https://www.kankanzhijian.com/2018/07/21/vertx_async_to_sync/">Vert.x异步方法转同步</a>这篇文章里，我提到其关键点是<code>CompletableFuture</code>类，今天我们就沿着当时的代码继续掰扯一下这个强大的类。<br>先来回顾下当时的代码</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import io<span class="selector-class">.vertx</span><span class="selector-class">.core</span><span class="selector-class">.Vertx</span></span><br><span class="line"></span><br><span class="line">import java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CompletableFuture</span></span><br><span class="line"></span><br><span class="line">String <span class="built_in">sayHello</span>() &#123;</span><br><span class="line">    CompletableFuture completableFuture = new <span class="built_in">CompletableFuture</span>()</span><br><span class="line"></span><br><span class="line">    Vertx vertx = Vertx<span class="selector-class">.vertx</span>()</span><br><span class="line">    vertx<span class="selector-class">.setTimer</span>(<span class="number">1000</span>, &#123;</span><br><span class="line">        completableFuture<span class="selector-class">.complete</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return completableFuture<span class="selector-class">.get</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">println</span><span class="params">(sayHello()</span></span>)</span><br></pre></td></tr></table></figure><p><code>vertx.setTimer</code>是个先天异步的东西，我们让它来模拟一个异步调用，你可以想象成从网络、磁盘或者其他什么接口，获取到那么一个字符串<code>hello world</code>。这么一个过程是异步的。然后在一个非异步程序的大环境下，后续的程序要等待这么一个结果。<br>此时我们用到了<code>CompletableFuture</code>，并且牵扯到其中的两个方法：<code>complete(T value)</code>、<code>get()</code>。</p><h4 id="complete-T-value"><a href="#complete-T-value" class="headerlink" title="complete(T value)"></a><code>complete(T value)</code></h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">If <span class="keyword">not</span> already completed, sets <span class="keyword">the</span> <span class="built_in">value</span> returned <span class="keyword">by</span> <span class="built_in">get</span>() <span class="keyword">and</span> related methods <span class="built_in">to</span> <span class="keyword">the</span> given <span class="built_in">value</span>.</span><br></pre></td></tr></table></figure><p>这个很好理解，就是给<code>completableFuture</code>塞一个完成的结果，供后续的方法调用获取，最典型的就是<code>get()</code></p><h4 id="get"><a href="#get" class="headerlink" title="get()"></a><code>get()</code></h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Waits <span class="keyword">if</span> necessary <span class="keyword">for</span> this future <span class="keyword">to</span> complete, <span class="keyword">and</span> <span class="keyword">then</span> returns <span class="keyword">its</span> <span class="literal">result</span>.</span><br></pre></td></tr></table></figure><p>这个<code>get()</code>方法源自于<code>Future</code>接口，是一个早在<code>Java 1.5</code>时代就提供的接口了。这个方法就是典型的阻塞式获取<code>Future</code>结果。放在上面的代码里，恰好能起到把<code>vert.x</code>的异步调用转换成同步的效果。但其实着不是什么好事，在<code>Java 8</code>中特意引入<code>CompletableFuture</code>就是为了解决阻塞问题，让异步发挥出更大的优势。</p><h4 id="发散一下"><a href="#发散一下" class="headerlink" title="发散一下"></a>发散一下</h4><p>抛开上面有意把异步转同步不说，我们来看看如果借助<code>CompletableFuture</code>，把<code>vert.x</code>的异步跟<code>Java 8</code>的异步有效结合，尝试代码如下：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import io<span class="selector-class">.vertx</span><span class="selector-class">.core</span><span class="selector-class">.Vertx</span></span><br><span class="line"></span><br><span class="line">import java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CompletableFuture</span></span><br><span class="line"></span><br><span class="line">CompletableFuture <span class="built_in">sayHello</span>() &#123;</span><br><span class="line">    CompletableFuture completableFuture = new <span class="built_in">CompletableFuture</span>()</span><br><span class="line"></span><br><span class="line">    Vertx vertx = Vertx<span class="selector-class">.vertx</span>()</span><br><span class="line">    vertx<span class="selector-class">.setTimer</span>(<span class="number">1000</span>, &#123;</span><br><span class="line">        completableFuture<span class="selector-class">.complete</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return completableFuture</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sayHello</span><span class="params">()</span></span><span class="selector-class">.whenCompleteAsync</span>(&#123; res, <span class="selector-tag">th</span> -&gt;</span><br><span class="line">    <span class="built_in">println</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简单改造过后，这就是一个遵循<code>Java 8</code>中<code>CompletableFuture</code>风格的异步使用方式。关键点在于<br><code>whenCompleteAsync(@NotNull BiConsumer&lt;? super T, ? super Throwable&gt; action)</code><br>方法，同时还有<br><code>whenComplete(@NotNull BiConsumer&lt;? super T, ? super Throwable&gt; action)</code><br>方法可供使用。这两个方法最大的区别是，前者会为<code>action</code>的执行上下文准备<code>ForkJoinPool</code>线程池环境；而后者会让<code>action</code>使用之前<code>completableFuture.complete()</code>所处的线程上下文。</p><h4 id="CompletableFuture是一个异常强大且复杂的类，本文所讲的东西不过是九牛一毛。这里推荐两个不错的帖子供大家参考："><a href="#CompletableFuture是一个异常强大且复杂的类，本文所讲的东西不过是九牛一毛。这里推荐两个不错的帖子供大家参考：" class="headerlink" title="CompletableFuture是一个异常强大且复杂的类，本文所讲的东西不过是九牛一毛。这里推荐两个不错的帖子供大家参考："></a><code>CompletableFuture</code>是一个异常强大且复杂的类，本文所讲的东西不过是九牛一毛。这里推荐两个不错的帖子供大家参考：</h4><ul><li><p><a href="https://colobu.com/2016/02/29/Java-CompletableFuture/">https://colobu.com/2016/02/29/Java-CompletableFuture/</a></p></li><li><p><a href="https://www.ibm.com/developerworks/cn/java/j-cf-of-jdk8/index.html">https://www.ibm.com/developerworks/cn/java/j-cf-of-jdk8/index.html</a></p><p>  其中第二篇文章涉及的代码，我已经整理了一份，你可以从这里获取<a href="https://gist.github.com/aruis/135f6e1fa678fc5024ea20db4b9b4eee">gist</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iTerm最佳实践</title>
      <link href="/2018/09/11/iTerm_best_practices/"/>
      <url>/2018/09/11/iTerm_best_practices/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-11%2010.09.15.png"></p><p><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-11%2009.16.40.png"><br><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-11%2009.19.37.png"></p><h3 id="另注两个最常用的快捷键："><a href="#另注两个最常用的快捷键：" class="headerlink" title="另注两个最常用的快捷键："></a>另注两个最常用的快捷键：</h3><h4 id="横向分屏-⌘D"><a href="#横向分屏-⌘D" class="headerlink" title="横向分屏 ⌘D"></a>横向分屏 <code>⌘D</code></h4><h4 id="纵向分屏-⇧⌘D"><a href="#纵向分屏-⇧⌘D" class="headerlink" title="纵向分屏 ⇧⌘D"></a>纵向分屏 <code>⇧⌘D</code></h4>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Groovy迭代器中的return陷阱</title>
      <link href="/2018/09/10/groovy_return_in_each/"/>
      <url>/2018/09/10/groovy_return_in_each/</url>
      
        <content type="html"><![CDATA[<p><code>groovy</code>从不会让人失望，如果有，那就是接下来我要说的这种情况：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">def</span> test(List list) &#123;</span><br><span class="line">    list.<span class="keyword">each</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (it &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">println</span> test(list)</span><br></pre></td></tr></table></figure><p>我们期望的结果<code>4</code>，也就是找到第一个比3大的数字就返回了，然而事与愿违，得到的结果是这样</p><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="string">[1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure><p>整个list都被打印了出来，其实<code>test</code>方法最终返回的东西是<code>list.each&#123;...&#125;</code>，而且<code>.each</code>方法的返回值是<code>the self List</code>，所以最后把<code>list</code>又原封不动打印了一遍也就不足为奇了。<br>那我们写的那行<code>return</code>干吗了，答案是，它既不会是方法返回，也不会使<code>each closure</code>返回，它在这里的作用跟<code>continue</code>类似，仅仅是让它后面的代码不在这次循环执行，仅此而已。</p><h4 id="那怎么才能打断一个each，然后让上面的方法提前return呢？"><a href="#那怎么才能打断一个each，然后让上面的方法提前return呢？" class="headerlink" title="那怎么才能打断一个each，然后让上面的方法提前return呢？"></a>那怎么才能打断一个<code>each</code>，然后让上面的方法提前<code>return</code>呢？</h4><p><strong>答案是，不能用<code>each</code>，得用<code>find</code>或者<code>any</code>之类的，</strong>有明显截断语义的迭代器。这里还是首推<code>find</code>，因为<code>any</code>返回值是<code>boolean</code>，能帮我们截断迭代，但是不适用于找东西的场景。</p><p>用<code>find</code>改造一下代码，如下</p><figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="variable">def</span> <span class="title function_">test</span>(<span class="params">List</span> <span class="params">list</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">list</span>.<span class="property">find</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">it</span> <span class="operator">&gt;</span> <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">it</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>groovy</code>方法中的<code>return</code>是可以省略的，更进一步，就写成这样</p><figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="variable">def</span> <span class="title function_">test</span>(<span class="params">List</span> <span class="params">list</span>) &#123;</span><br><span class="line">   <span class="variable">list</span>.<span class="property">find</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">it</span> <span class="operator">&gt;</span> <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">it</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然基于<code>find</code>的先天特性，那句<code>return it</code>也可以省略成这样</p><figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="variable">def</span> <span class="title function_">test</span>(<span class="params">List</span> <span class="params">list</span>) &#123;</span><br><span class="line">   <span class="variable">list</span>.<span class="property">find</span> &#123; <span class="variable">it</span> <span class="operator">&gt;</span> <span class="number">3</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次之前执行<code>println test(list)</code>，得到结果<code>4</code>，一切归于完美了。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>这里不得不说下<code>Kotlin</code>，它应付上面描述的场景就非常得心应手了。首先，默认情况下<code>return</code>就是代表让一个方法返回，这符合一个程序员的直觉。<br>在不想扩大<code>return</code>的打击范围，而仅仅只想结束一个<code>lambda</code>的时候，可以使用<code>标签返回</code>，类似这样</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>.<span class="keyword">forEach</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (it &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>@<span class="keyword">forEach</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面的语法糖，让你觉得有点故弄玄虚了，还可以使用更容易理解的匿名函数，就像这样</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list.forEach(<span class="function"><span class="title">fun</span><span class="params">(it)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (it &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>我是非常喜欢<code>groovy</code>的，她已经陪伴我8个年头了，几乎我手上所有的项目都离不开<code>groovy</code>的身影。我甚至用她写过<code>Android</code>程序。不过不得不承认，<code>Kotlin</code>作为后起之秀，的确在很多方向上更进一步，考虑的场景也更为全面。期待<code>groovy</code>的<code>3.0</code>能够发力一波。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用JavaScript在PostgreSQL中写存储过程</title>
      <link href="/2018/09/09/plv8_in_postgresql/"/>
      <url>/2018/09/09/plv8_in_postgresql/</url>
      
        <content type="html"><![CDATA[<p>首先交代一个概念，在<code>PostgreSQL</code>中，函数、存储过程都是一回事，创建语法都是<code>create function</code>。之所以本文标题使用<code>存储过程</code>的叫法，是为了方便其他数据库的使用者容易理解。<br>先来看看<code>PostgreSQL</code>默认支持的创建数据库函数的写法，如：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 把系统生成的uuid中的-替换成_</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> <span class="type">uuid</span>()</span><br><span class="line">  <span class="keyword">returns</span> <span class="type">text</span></span><br><span class="line"><span class="keyword">language</span> <span class="keyword">sql</span></span><br><span class="line"><span class="keyword">as</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">SELECT</span> replace(uuid_generate_v4()::<span class="type">text</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;_&#x27;</span>);</span></span><br><span class="line"><span class="language-pgsql">$$</span>;</span><br></pre></td></tr></table></figure><p>注意其中的<code>language</code>关键字，后面指明了该数据库函数所使用的语言，上面这个函数很简单，用纯<code>SQL</code>就能搞定，更多的时候，我们遇到的会复杂很多，就得用上过程化的SQL，也就是<code>plpgsql</code>（类似Oracle中的PL&#x2F;SQL），具体可以查看官方文档<a href="http://www.postgres.cn/docs/10/plpgsql.html">plpgsql</a>。<br>不过今天的主题不是<code>plpgsql</code>，而是<code>plv8</code>——基于<code>V8</code>引擎的在<code>PostgreSQL</code>中运行的过程化语言，其实就是用<code>JavaScript</code>在<code>PostgreSQL</code>中写数据库函数。<br><strong>那么为什么要用<code>Javascript</code>来写数据库函数呢？</strong>在我看来，至少有下面几个好处：</p><ol><li>熟悉的配方，熟悉的味道。<code>JavaScript</code>作为<code>Web</code>世界的一等公民，其教众众多。能用<code>JavaScript</code>来实现高级的数据库开发，可以大幅拉低数据库的学习曲线，进而<strong>降低人力成本</strong>。</li><li>获得<code>SQL</code>世界本身不具备的库函数，像这样：<img src="/media/15364987364827.jpg"><br> 还有这样：<br> <img src="/media/15364989242348.jpg"><br> 可以极大丰富数据库层面的功能实现，进而影响一个软件的架构设计。</li><li>更快的性能，众所周知<code>Google</code>主推的<code>V8</code>引擎是业界公认的顶尖性能怪兽。有它配合你的数据库使用真是如虎添翼。尤其是在业务系统的开发采用了并不是以性能为卖点的语言时（比如<code>Ruby</code>、<code>PHP</code>），把部分业务逻辑通过<code>JavaScript</code>在数据库中重构一边，说不定会有意想不到的效果。这比伤筋动骨地单纯在业务层摸索改进要容易得多。</li></ol><p>说了这么多，怎么才能在<code>PostgreSQL</code>中用上<code>JavaScript</code>呢？</p><ul><li>第一步肯定是在电脑上装好<code>PostgreSQL</code>，这个不再赘述</li><li><code>windows</code>用户，可以下载这里的安装包，<a href="http://www.postgresonline.com/journal/archives/379-PLV8-binaries-for-PostgreSQL-10-windows-both-32-bit-and-64-bit.html">http://www.postgresonline.com/journal/archives/379-PLV8-binaries-for-PostgreSQL-10-windows-both-32-bit-and-64-bit.html</a> </li><li><code>ubuntu</code>用户，<code>apt-get install postgresql-10-plv8</code></li><li>更多安装细节，请参考官方文档：<a href="https://plv8.github.io/">https://plv8.github.io</a> 以及 <a href="https://pgxn.org/dist/plv8/doc/plv8.html">https://pgxn.org/dist/plv8/doc/plv8.html</a></li><li>当然，如果你熟悉<code>docker</code>，可以使用我在<code>docker store</code>上分享的<code>lovearuis/postgres10_plv8</code>（<a href="https://store.docker.com/community/images/lovearuis/postgres10_plv8">地址</a>），只需要这么一个命令<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">run</span> <span class="attribute">--name</span>=postgres10_plv8 -d -p 5432:5432 lovearuis/postgres10_plv8</span><br></pre></td></tr></table></figure>  就可以在本机<code>5432</code>端口上运行一个装好<code>JavaScript</code>支持的最新版<code>PostgreSQL</code></li><li>安装完必要的<code>plv8</code>包之后，还要在数据库中执行<code>SQL</code>：<code>CREATE EXTENSION plv8;</code>，才能真正解锁<code>plv8</code>的洪荒之力。</li></ul><p>一切就绪之后，按照官方文档上举例的，先来个带<code>for</code>循环和生成<code>JSON</code>的耍耍，<code>SQL</code>如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> plv8_test(keys TEXT[], vals TEXT[]) <span class="keyword">RETURNS</span> JSON <span class="keyword">AS</span> $$</span><br><span class="line">  var o <span class="operator">=</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(var i<span class="operator">=</span><span class="number">0</span>; i<span class="operator">&lt;</span>keys.length; i<span class="operator">+</span><span class="operator">+</span>)&#123;</span><br><span class="line">o[keys[i]] <span class="operator">=</span> vals[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plv8 IMMUTABLE STRICT;</span><br></pre></td></tr></table></figure><p>尝试调用刚刚创建的<code>plv8_test</code>函数：</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> plv8_test(<span class="keyword">ARRAY</span>[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>], <span class="keyword">ARRAY</span>[<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;29&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>获得结果<img src="/media/15365022296404.jpg"><br>是不是美妙极了？☺️</p><h3 id="放大招"><a href="#放大招" class="headerlink" title="放大招"></a>放大招</h3><p>是不是看了上面的介绍，有点心痒难耐了。🤪<strong>其实<code>PostgreSQL</code>在内部可调用的过程化语言的支持远不仅于此。你完全可以用你心爱的<code>Python</code>、<code>Java</code>、<code>PHP</code>甚至是<code>R</code>、<code>Lua</code>从事<code>PostgreSQL</code>中的数据库函数开发。</strong><br>尤其是<code>Python</code>、<code>Java</code>，这两个语言几乎在<code>PostgreSQL</code>的<code>PL</code>环境下有最大的权限空间。想象这样一个场景：<br>一个别人做的项目（你没有源码，或者有源码跟没有也没啥区别），领导说要加个需求，当一个数据到达某种阀值时，要发短信给一个人（比如考试成绩低于60的时候，发个短信给学生家长）。这个时候，你不需要再打开开发环境，在别人的代码里面流离失所，久久不能自拔。你需要做的，就是打开这个项目的<code>PostgreSQL</code>（谢天谢地，它用了世界上最先进的开源数据库，尽管它的代码跟翔没什么区别），然后用<code>Java</code>在<code>PostgreSQL</code>中写个数据库函数（请求一个短信网关的http接口或者别的什么东西），最后套一个触发器（3行<code>SQL</code>）就什么都完成了。<br>这画面太美，我不敢想象啊，哈哈。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Google Trends了解某一技术的全球态势</title>
      <link href="/2018/09/08/Google_Trends/"/>
      <url>/2018/09/08/Google_Trends/</url>
      
        <content type="html"><![CDATA[<p>今天想介绍的东西很简单了，但却异常强大，就是<code>Google Trends</code>。使用方法非常简单，访问<a href="https://trends.google.com/trends/explore">trends.google.com</a>即可。<br>那么来看看我自己通过<code>Google Trends</code>发掘的一些有意思的事情吧。<br><img src="/media/15363698300629.jpg"><br><img src="/media/15363699317160.jpg"><br><img src="/media/15363701237412.jpg"><br><img src="/media/15363701562662.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA中那些锦上添花的小技巧</title>
      <link href="/2018/09/07/IntelliJ_IDEA_tips/"/>
      <url>/2018/09/07/IntelliJ_IDEA_tips/</url>
      
        <content type="html"><![CDATA[<p><code>IntelliJ IDEA</code>作为相当主流的<code>Java</code>开发工具，网上分享其使用技巧的如汗牛充栋。今天我从自己的角度，分享一些经常被人忽视，同时也不怎么重要的使用技巧，权作锦上添花之用。</p><h4 id="用Toolbox来管理IntelliJ-IDEA"><a href="#用Toolbox来管理IntelliJ-IDEA" class="headerlink" title="用Toolbox来管理IntelliJ IDEA"></a>用<code>Toolbox</code>来管理<code>IntelliJ IDEA</code></h4><p>自己安装<code>IntelliJ IDEA</code>诚然没什么难度，但是架不住其更新频率实在太高，而且有时候还没有升级包可用。所以通过<code>Toolbox</code>来保持<code>IntelliJ IDEA</code>永远在最新版本是一种相当有效的做法。</p><h4 id="用Dracula插件来美化代码配色"><a href="#用Dracula插件来美化代码配色" class="headerlink" title="用Dracula插件来美化代码配色"></a>用<code>Dracula</code>插件来美化代码配色</h4><p><img src="/media/15363162820957.jpg"><br>美化后的代码配色如上图，愿项目地址在此：<a href="https://draculatheme.com/jetbrains/">https://draculatheme.com/jetbrains/</a> 如何使用，该项目文档已经讲的很清楚了</p><h4 id="编辑VM-Options"><a href="#编辑VM-Options" class="headerlink" title="编辑VM Options"></a>编辑<code>VM Options</code></h4><p><code>IntelliJ IDEA</code>毕竟还是<code>Java</code>程序，想要发挥最大性能，还是需要好好维护<code>JVM</code>参数的。早期<code>IntelliJ IDEA</code>版本中，要维护<code>VM Options</code>是需要到该程序安装目录找到一个特殊文件手动编辑的。现在处理起来简单多了，只需要点菜单的这里，如图：<br><img src="/media/15363168799795.jpg"></p><p>就可以方便地在<code>IntelliJ IDEA</code>环境中编辑<code>VM Options</code>了。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免百度网盘客户端下载大文件并突破非会员限速</title>
      <link href="/2018/09/06/break_through_baiduwangpan/"/>
      <url>/2018/09/06/break_through_baiduwangpan/</url>
      
        <content type="html"><![CDATA[<p>在网盘市场洗过几次牌后的今天，百度网盘可以说是如今的头牌了。网上充斥的各种资源，几乎都在用百度网盘分享。但是百度这家公司怎么说呢，就是骨子里，有一点<code>X</code>，<em>你懂的</em>。遇到稍微大一点的文件，不让从浏览器直接下载不说，限速起来更是毫无人性。<br>不过正所谓道高一尺，魔高一丈。在互联网的江湖，一切皆有可能。今天我们就来介绍一种借助浏览器插件突破百度网盘限制的一种方法。</p><h3 id="1-安装浏览器插件tampermonkey"><a href="#1-安装浏览器插件tampermonkey" class="headerlink" title="1. 安装浏览器插件tampermonkey"></a>1. 安装浏览器插件<code>tampermonkey</code></h3><p>就和安装其他浏览器插件一样，没什么难度，可以去它的官网查看<a href="http://tampermonkey.net/">http://tampermonkey.net</a> 。看看官网是怎么介绍它的</p><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">Tampermonkey 是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera <span class="keyword">Next</span>, 和 Firefox。 </span><br></pre></td></tr></table></figure><h3 id="2-安装针对百度网盘的拓展脚本EX-百度云盘"><a href="#2-安装针对百度网盘的拓展脚本EX-百度云盘" class="headerlink" title="2. 安装针对百度网盘的拓展脚本EX-百度云盘"></a>2. 安装针对百度网盘的拓展脚本<code>EX-百度云盘</code></h3><p>项目地址：<a href="https://greasyfork.org/zh-CN/scripts/26638-ex-%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98">EX-百度云盘</a>，访问这个项目页面时，可以看到大大的<code>安装此脚本</code>按钮，大胆点击它就好了。</p><h3 id="3-访问任意一个百度网盘分享页面就能够发现惊喜了"><a href="#3-访问任意一个百度网盘分享页面就能够发现惊喜了" class="headerlink" title="3. 访问任意一个百度网盘分享页面就能够发现惊喜了"></a>3. 访问任意一个百度网盘分享页面就能够发现惊喜了</h3><p><img src="/media/15361965426250.jpg"><br>此时通过点击<code>普通下载</code>就能够突破百度网盘网页版对于大文件不允许下载的限制了</p><h3 id="4-突破速度限制"><a href="#4-突破速度限制" class="headerlink" title="4. 突破速度限制"></a>4. 突破速度限制</h3><p>接上图，通过<code>复制链接</code>按钮，我们就能获取该资源的原始下载链接，此时我们通过任意多线程下载工具（包括迅雷，但不怎么好用就是了），就能获得几乎峰值的下载速度了。<br><img src="/media/15361968542946.jpg"><br>截图中，我使用的工具是<code>Aria2GUI</code>，这是一款针对<code>mac OS</code>的下载工具（<a href="https://github.com/yangshun1029/aria2gui/releases">点此下载</a>）。如果你是<code>windows</code>用户，可以试试<code>IDM</code>或者<code>flashget</code>，如果动手能力强可以搜索<code>aria2 windows</code>关键词，打开新世界的大门。</p>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu里查看软件包信息</title>
      <link href="/2018/09/05/ubuntu_show_soft_info/"/>
      <url>/2018/09/05/ubuntu_show_soft_info/</url>
      
        <content type="html"><![CDATA[<p>以<code>postgresql-10-plv8</code>这个软件包为例，需要知道软件包的一些必要信息，比如版本、项目主页、大小、简单说明之类的，可以用如下命令查看：</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">apt</span> show postgresql-<span class="number">10</span>-plv8</span><br></pre></td></tr></table></figure><p>对于早期版本的ubuntu（&lt;14.04），可以使用这个命令</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">apt-<span class="keyword">cache </span><span class="keyword">show </span>postgresql<span class="number">-10</span>-plv8</span><br></pre></td></tr></table></figure><p>另外一种方式也是极好的，就是利用<code>aptitude</code>，前提是你先安装了它，那么就可以这么用：</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">aptitude</span> show postgresql-<span class="number">10</span>-plv8</span><br></pre></td></tr></table></figure><p><code>aptitude</code>比前者强的地方是它能告诉你该软件包是否已经安装</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradle插件下载不下来的解决方案</title>
      <link href="/2018/09/04/gradle_plugin_download_error/"/>
      <url>/2018/09/04/gradle_plugin_download_error/</url>
      
        <content type="html"><![CDATA[<p>字符乱码和互联网不互联，是困扰中国程序员的两大问题。我就在使用<code>gradle</code>的时候，会遇到官方插件下载不下来的情况。<br>比如使用<code>org.hidetake.ssh</code>插件时，如果按照文档所述，直接这样写</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  <span class="built_in">id</span> <span class="string">&#x27;org.hidetake.ssh&#x27;</span> version <span class="string">&#x27;2.9.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候就会遇到网络问题，因为此时要去访问<code>gradle.org</code>官网去申请插件，而不知道什么时候这个网络就不通了。<br>此时我们可以通过细化<code>buildscript</code>的<code>repositories</code>来解决问题，也就是在<code>plugins</code>之前，增加<code>buildscript</code>的配置内容，整体代码如下</p><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        <span class="keyword">maven</span> &#123;</span><br><span class="line">            url <span class="string">&quot;http://maven.aliyun.com/nexus/content/groups/public&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">plugins</span> &#123;</span><br><span class="line">    <span class="built_in">id</span> <span class="string">&quot;org.hidetake.ssh&quot;</span> version <span class="string">&quot;2.9.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>这里我们通过使用阿里云的<code>maven</code>服务器地址，理论上还能在国内获得更快的资源访问速度。</em></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim必知必会</title>
      <link href="/2018/09/03/vim_note/"/>
      <url>/2018/09/03/vim_note/</url>
      
        <content type="html"><![CDATA[<h3 id="普通模式下光标移动"><a href="#普通模式下光标移动" class="headerlink" title="普通模式下光标移动"></a>普通模式下光标移动</h3><ul><li><p><code>h</code>：左移一个字符</p></li><li><p><code>j</code>：下移一行</p></li><li><p><code>k</code>：上移一行</p></li><li><p><code>l</code>：右移一个字符</p></li><li><p><code>PageDown</code>(<code>Ctrl+F</code>)：下翻一屏</p></li><li><p><code>PageUp</code>（<code>Ctrl+B</code>）上翻一屏</p></li><li><p><code>G</code>：移动到最后一行</p></li><li><p><code>num G</code>：移动到第<em>num</em>行</p></li><li><p><code>gg</code>：移动到第一行</p></li></ul><h3 id="命令模式下的命令"><a href="#命令模式下的命令" class="headerlink" title="命令模式下的命令"></a>命令模式下的命令</h3><ul><li><code>q</code>：退出</li><li><code>q!</code>：放弃修改，退出</li><li><code>w filename</code>：保存到另外一个文件</li><li><code>wq</code>：保存并退出</li></ul><h3 id="普通模式下的编辑命令"><a href="#普通模式下的编辑命令" class="headerlink" title="普通模式下的编辑命令"></a>普通模式下的编辑命令</h3><ul><li><code>x</code>：删除光标位置的的字符</li><li><code>dd</code>：删除光标所在行</li><li><code>dw</code>：删除光标所在单词</li><li><code>d$</code>：删除光标至行尾</li><li><code>J</code>：删除光标所在行的换行符</li><li><code>u</code>：撤销操作</li><li><code>a</code>：在光标后追加数据</li><li><code>A</code>：在光标所在行末尾追加数据</li><li><code>r char</code>：用<em>char</em>替换光标所在字符</li><li><code>R text</code>：用<em>text</em>替换光标所在位置数据</li></ul><h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><ul><li><code>y</code>复制，跟<code>d</code>类似，<code>yw</code>复制一个单词，<code>y$</code>复制到行尾</li><li><code>p</code>粘贴<br>还有个特别好用的就是<code>v</code>模式，可以通过敲<code>v</code>进入，然后就可以移动光标批量选择内容，按<code>y</code>复制，之后合适的位置<code>p</code>进行粘贴</li></ul><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><ul><li><code>:s/old/new/</code>替换一处</li><li><code>:%s/old/new/g</code>替换所有</li><li><code>:%s/old/new/gc</code>以交互询问的方式，替换所有</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh中文乱码</title>
      <link href="/2018/09/02/ssh_chinese_garbled/"/>
      <url>/2018/09/02/ssh_chinese_garbled/</url>
      
        <content type="html"><![CDATA[<p>ssh远程到服务器后，遇到中文乱码，建议通过<code>locale</code>检查当前的字符集，如果遇到<code>LC_ALL=</code>无值，十有八九是要出问题的。<br>此时可以通过执行<code>export  LC_ALL=zh_CN.UTF-8</code>临时解决。<br>当然，把上面这句添加到<code>.bash_profile</code>中，就可以永久解决了。 就像这样</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .bash_profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the aliases and functions</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">        . ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific environment and startup programs</span></span><br><span class="line"></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="built_in">export</span>  LC_ALL=zh_CN.UTF-8</span><br></pre></td></tr></table></figure><p>补充一点，用<code>en_US.UTF-8</code>代替上文的<code>zh_CN.UTF-8</code>也是同样有效的。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相当靠谱的FastDFS Docker镜像</title>
      <link href="/2018/09/01/fastdfs_docker/"/>
      <url>/2018/09/01/fastdfs_docker/</url>
      
        <content type="html"><![CDATA[<p>该项目是我在网上搜的，迄今为止个人感觉最靠谱的<code>FastDFS</code>镜像，项目地址<a href="https://github.com/luhuiguo/fastdfs-docker">https://github.com/luhuiguo/fastdfs-docker</a></p><p>开启一个<code>tracker</code></p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker run -dti --network=host --name tracker -v <span class="regexp">/var/</span>fdfs<span class="regexp">/tracker:/</span>var<span class="regexp">/fdfs luhuiguo/</span>fastdfs tracker</span><br></pre></td></tr></table></figure><p>开启一个<code>storage</code></p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker run -dti --network=host --name storage0 -e TRACKER_SERVER=<span class="number">192.168</span>.<span class="number">0.88</span>:<span class="number">22122</span> -v <span class="regexp">/var/</span>fdfs<span class="regexp">/storage0:/</span>var<span class="regexp">/fdfs luhuiguo/</span>fastdfs storage</span><br></pre></td></tr></table></figure><p>开启一个<code>storage</code>，并指定<code>Group</code></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -dti <span class="attribute">--network</span>=host --name storage2 -e <span class="attribute">TRACKER_SERVER</span>=10.1.5.85:22122 -e <span class="attribute">GROUP_NAME</span>=group2 -e <span class="attribute">PORT</span>=22222 -v /var/fdfs/storage2:/var/fdfs luhuiguo/fastdfs storage</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> FastDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一个八岁小女孩</title>
      <link href="/2018/08/31/eight_years_girl/"/>
      <url>/2018/08/31/eight_years_girl/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/FullSizeRender.jpeg" alt="摄于兴义机场"></p><p>在贵阳飞回徐州的飞机上，坐在我旁边的是一个胖乎乎的小女孩。飞行的前半程，我一直有个疑问，就是谁和她通行的，总不可能一个二三年级的小学生独自坐飞机，而且还是要飞个上千公里的这种。<br>直到看到她自己去跟空姐沟通午餐事宜，自己从书包里拿出一张毛爷爷来支付自己的午餐。我才明白，原来她是一个人坐飞机的。心中暗暗赞叹。<br>后来简单跟她聊了一会，得知她今年八岁。因为父母离异，分居两地，她从四岁时就开始了这种独自往返于贵阳与徐州的生活。这的确听起来让人觉得可怜，毕竟孩子是无辜的，但却没什么其他办法。<br>我留了一张有我们俩人的自拍照，但没有问她名字。只能在心里默默祝福她，希望未来能越来越好。</p><p>最后记录一下我俩的对话：<br>她：你说世界上坏人多么？<br>我：多，但是没有好人多。</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>«写给大家看的设计书»中最关键的九个字</title>
      <link href="/2018/08/30/non-designers-design-book/"/>
      <url>/2018/08/30/non-designers-design-book/</url>
      
        <content type="html"><![CDATA[<p>«写给大家看的设计书»书如其名，是一本非常适合外行看的设计书。这本书再版多次，足以证明其优秀，推荐给可能会遇到UI设计需求的程序员同胞看。<br>全书的核心思想就是四个原则，如果你没时间看书，只要牢记这四大原则，也是能够获益良多的。</p><h3 id="对比-（Contrast）"><a href="#对比-（Contrast）" class="headerlink" title="对比 （Contrast）"></a>对比 （Contrast）</h3><p>对比的目的是强调重点，所以也不要为了对比而对比。通过对比的设计，突出你想表达的，让受众能更容易地发现重点。</p><h3 id="重复-（Repetition）"><a href="#重复-（Repetition）" class="headerlink" title="重复 （Repetition）"></a>重复 （Repetition）</h3><p>不是单指字面上的重复，按我的理解，用“呼应”更为贴切。颜色也好、图形也好、甚至字体等等，通过一定的重复产生呼应的效果。给人一种精心设计的感觉。</p><h3 id="对齐-（Alignment）"><a href="#对齐-（Alignment）" class="headerlink" title="对齐 （Alignment）"></a>对齐 （Alignment）</h3><p>这个很多人都有感触的。我想说的是，对齐其实也是某个维度的重复，其实跟第二条原则是重叠的。只是对齐是最容易做到，也是最应该做到的，故而单独拿出以示其重要性。</p><h3 id="亲密性-（Proximity）"><a href="#亲密性-（Proximity）" class="headerlink" title="亲密性 （Proximity）"></a>亲密性 （Proximity）</h3><p>这个翻译，还挺让人晕的。简单的说，就是把有共性的事物聚类，形成视觉单元（<em>visual unit</em>）。</p><p>以上四原则摘自<a href="https://item.jd.com/11824338.html">«写给大家看的设计书»</a>，但是解读是我自己根据理解补充的。话说回来，当你回过头审视这几个原则的时候，会发现这甚至跟写作文、写诗歌、写小说有点像。要有起伏，要有重点，要前后呼应。是不是很有意思呢？</p>]]></content>
      
      
      <categories>
          
          <category> 设计相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在SpringBoot中使用groovy.sql.SQL高效开发</title>
      <link href="/2018/08/29/groovy-sql-SQL-in-spring-boot/"/>
      <url>/2018/08/29/groovy-sql-SQL-in-spring-boot/</url>
      
        <content type="html"><![CDATA[<p>某种情况下，其实就想用<code>Spring Boot</code>提供的那种即开即用的开发体验，但是我真的对<code>Spring</code>保姆式的一揽子工程不怎么感冒。尤其是数据库<code>JDBC</code>这块。常见的<code>Java</code>系里提到的技术，我真的一个都不想用，我最钟爱的数据库类库其实就是<code>groovy.sql.SQL</code>，简单而强大，配合<code>Groovy</code>之后，再也没有繁琐的<code>Java Bean</code>和无边无际的<code>get</code>、<code>set</code>。<br>想了解更多<code>groovy.sql.SQL</code>欢迎查看官方文档：<a href="http://groovy-lang.org/databases.html">http://groovy-lang.org/databases.html</a><br>今天我们还是着重说一下，怎么在<code>Spring Boot</code>的框架下融入<code>groovy.sql.SQL</code>，话不多说，上代码：</p><h4 id="gradle-build"><a href="#gradle-build" class="headerlink" title="gradle.build"></a>gradle.build</h4><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;1.5.15.RELEASE&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;war&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;groovy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> <span class="string">&#x27;com.aruistar&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    groovy_version = <span class="string">&quot;2.5.2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">&quot;org.springframework.boot:spring-boot-starter-web&quot;</span>)</span><br><span class="line"><span class="comment">//    providedRuntime(&quot;org.springframework.boot:spring-boot-starter-tomcat&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">&quot;org.codehaus.groovy:groovy:$groovy_version&quot;</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">&quot;org.codehaus.groovy:groovy-sql:$groovy_version&quot;</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">&quot;org.codehaus.groovy:groovy-json:$groovy_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">&#x27;com.alibaba&#x27;</span>, name: <span class="string">&#x27;druid&#x27;</span>, version: <span class="string">&#x27;1.1.10&#x27;</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">&#x27;mysql&#x27;</span>, name: <span class="string">&#x27;mysql-connector-java&#x27;</span>, version: <span class="string">&#x27;5.1.46&#x27;</span></span><br><span class="line"></span><br><span class="line">    testCompile <span class="string">&quot;org.codehaus.groovy:groovy-test:$groovy_version&quot;</span></span><br><span class="line">    testCompile(<span class="string">&quot;org.springframework.boot:spring-boot-starter-test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="程序入口Application"><a href="#程序入口Application" class="headerlink" title="程序入口Application"></a>程序入口Application</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aruistar</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"><span class="keyword">import</span> groovy.sql.Sql</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.support.SpringBootServletInitializer</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> <span class="keyword">extends</span> <span class="title class_">SpringBootServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> SpringApplicationBuilder <span class="title function_">configure</span><span class="params">(SpringApplicationBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(Application.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;app.datasource&quot;)</span></span><br><span class="line">    DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().type(DruidDataSource.class).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Sql <span class="title function_">db</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Sql</span>(dataSource())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="配置文件application-yml"><a href="#配置文件application-yml" class="headerlink" title="配置文件application.yml"></a>配置文件application.yml</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">pool-size:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="用上Sql的Controller"><a href="#用上Sql的Controller" class="headerlink" title="用上Sql的Controller"></a>用上Sql的Controller</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aruistar.controller</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> groovy.sql.Sql</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/open&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Sql db</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    def <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        db.firstRow(<span class="string">&quot;select 1)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这套方案用上了<code>Spring</code>，也用上了数据库连接池<code>druid</code>，所以项目整体是足够健壮的。如果你的项目本来就是基于<code>Spring</code>技术栈的，那我强烈推荐你试试结合<code>Groovy</code>的这套打法。可以大幅提升开发效率。<br><strong>亲自跑一下<code>Groovy</code>项目，用用她提供的<code>SQL</code>类，我想你会爱上她的</strong></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上墙纪念</title>
      <link href="/2018/08/28/vertx_example_contributors/"/>
      <url>/2018/08/28/vertx_example_contributors/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/15354179433179.jpg"><br><a href="https://github.com/vert-x3/vertx-examples">vertx-examples</a>项目合并了我一次<code>PR</code>，所以我的ID出现在<a href="https://github.com/vert-x3/vertx-examples/graphs/contributors">contributors</a>里了。应该是为数不多的亚裔面孔。嗨皮。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> contributors </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradle中的sourceCompatibility与targetCompatibility</title>
      <link href="/2018/08/27/sourceCompatibility_and_targetCompatibility_in_gradle/"/>
      <url>/2018/08/27/sourceCompatibility_and_targetCompatibility_in_gradle/</url>
      
        <content type="html"><![CDATA[<p><code>Gradle</code>中有两个属性，我也是一知半解。今天正好要练习下<code>Java10</code>，那就先把这两个属性的问题测试透了再说。那就是<code>sourceCompatibility</code>和<code>targetCompatibility</code>。<br>简单的说，<code>sourceCompatibility</code>属性跟编译环境有关，而<code>targetCompatibility</code>属性跟运行环境有关。<br>至少有这么几个原则，是不能违背的：</p><ol><li><code>sourceCompatibility</code>关系到你使用到的<code>Java</code>语法特性及库</li><li><code>sourceCompatibility</code>不能比<code>targetCompatibility</code>大</li><li><code>targetCompatibility</code>不能比目标客户端运行环境的<code>JavaVersion</code>大</li><li><code>targetCompatibility</code>不能比当前<code>Gradle</code>使用的<code>JavaVersion</code>大</li></ol><p>总结起来就是这样</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">代码用的语言特性对应的JavaVersion </span><br><span class="line">≦ <span class="keyword">sourceCompatibility</span> </span><br><span class="line">≦ <span class="keyword">targetCompatibility</span> </span><br><span class="line">≦ Gradle使用的JavaVersion </span><br><span class="line">≦ 客户端环境的JavaVersion</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中关于SCHEMA和SEARCH_PATH的一些技巧</title>
      <link href="/2018/08/26/postgresql_schema_and_search_path/"/>
      <url>/2018/08/26/postgresql_schema_and_search_path/</url>
      
        <content type="html"><![CDATA[<h4 id="1-extension最好放在单独的schema里，就像这样"><a href="#1-extension最好放在单独的schema里，就像这样" class="headerlink" title="1. extension最好放在单独的schema里，就像这样"></a>1. <code>extension</code>最好放在单独的<code>schema</code>里，就像这样</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> schema &quot;extension_schema&quot;;</span><br><span class="line"><span class="keyword">create</span> extension &quot;ltree&quot; schema extension_schema;</span><br></pre></td></tr></table></figure><h4 id="2-业务上不相干的表，建议也放在单独的schema中，比如这样"><a href="#2-业务上不相干的表，建议也放在单独的schema中，比如这样" class="headerlink" title="2.业务上不相干的表，建议也放在单独的schema中，比如这样"></a>2.业务上不相干的表，建议也放在单独的<code>schema</code>中，比如这样</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> schema &quot;metadata_schema&quot;;</span><br><span class="line"><span class="keyword">create</span> schema &quot;platform_schema&quot;;</span><br><span class="line"><span class="keyword">create</span> schema &quot;platform_schema&quot;;</span><br></pre></td></tr></table></figure><h4 id="3-可选-从数据库设计的角度来说，不同schema中的表名是可以重名的。但是我们有时候要反其道而行之，就是要任何情况下表名不同，方便编写SQL的时候，可以方便的省略schema。这样就需要借助触发器了。像这样"><a href="#3-可选-从数据库设计的角度来说，不同schema中的表名是可以重名的。但是我们有时候要反其道而行之，就是要任何情况下表名不同，方便编写SQL的时候，可以方便的省略schema。这样就需要借助触发器了。像这样" class="headerlink" title="3.[可选]从数据库设计的角度来说，不同schema中的表名是可以重名的。但是我们有时候要反其道而行之，就是要任何情况下表名不同，方便编写SQL的时候，可以方便的省略schema。这样就需要借助触发器了。像这样"></a>3.[<em>可选</em>]从数据库设计的角度来说，不同<code>schema</code>中的表名是可以重名的。但是我们有时候要反其道而行之，就是要任何情况下表名不同，方便编写<code>SQL</code>的时候，可以方便的省略<code>schema</code>。这样就需要借助触发器了。像这样</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> table_create()</span><br><span class="line">  <span class="keyword">returns</span> event_trigger</span><br><span class="line"><span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">        table_name       <span class="type">VARCHAR</span>;</span><br><span class="line">        short_table_name <span class="type">VARCHAR</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> object_identity</span><br><span class="line">  <span class="keyword">INTO</span> table_name</span><br><span class="line">  <span class="keyword">FROM</span> pg_event_trigger_ddl_commands();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> substr(table_name, <span class="built_in">position</span>(<span class="string">&#x27;.&#x27;</span> <span class="keyword">IN</span> table_name) <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">INTO</span> short_table_name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">INTO</span> is_exist</span><br><span class="line">  <span class="keyword">FROM</span> pg_catalog.pg_stat_user_tables</span><br><span class="line">  <span class="keyword">WHERE</span> relname <span class="operator">=</span> short_table_name :: <span class="type">VARCHAR</span>;</span><br><span class="line"></span><br><span class="line">  IF is_exist</span><br><span class="line">  <span class="keyword">THEN</span></span><br><span class="line">    RAISE EXCEPTION <span class="string">&#x27;%  already exists. event:%, command:%. abort.&#x27;</span>, table_name, TG_EVENT, TG_TAG;</span><br><span class="line">  <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EVENT <span class="keyword">TRIGGER</span> etgr_table_create</span><br><span class="line"><span class="keyword">ON</span> ddl_command_end</span><br><span class="line"><span class="keyword">WHEN</span> TAG <span class="keyword">IN</span> (<span class="string">&#x27;CREATE TABLE&#x27;</span>)</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> table_create();</span><br></pre></td></tr></table></figure><h4 id="4-现在schema已经够多了，但是用户连接到PostgreSQL的时候，默认只会去-user跟public这两个schema去寻找表，如果要访问别的schema还要在用到的时候采用schema-table的方式。这点在配置文件postgresql-conf中也可以看到"><a href="#4-现在schema已经够多了，但是用户连接到PostgreSQL的时候，默认只会去-user跟public这两个schema去寻找表，如果要访问别的schema还要在用到的时候采用schema-table的方式。这点在配置文件postgresql-conf中也可以看到" class="headerlink" title="4.现在schema已经够多了，但是用户连接到PostgreSQL的时候，默认只会去$user跟public这两个schema去寻找表，如果要访问别的schema还要在用到的时候采用schema.table的方式。这点在配置文件postgresql.conf中也可以看到"></a>4.现在<code>schema</code>已经够多了，但是用户连接到<code>PostgreSQL</code>的时候，默认只会去<code>$user</code>跟<code>public</code>这两个<code>schema</code>去寻找表，如果要访问别的<code>schema</code>还要在用到的时候采用<code>schema.table</code>的方式。这点在配置文件<code>postgresql.conf</code>中也可以看到</h4><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#search_path = <span class="string">&#x27;&quot;$user&quot;, public&#x27;</span>        # schema names</span><br></pre></td></tr></table></figure><p>聪明的你已经猜到，只需要修改配置文件中的这个<code>search_path</code>，就可以让用户访问表的时候不必带上<code>schema</code>。<br>但是我倒不建议这么做。因为这个配置文件是全局的。我们可能会有多个<code>database</code>运行于此，而他们有着不相干的<code>schema</code>，都写在这个配置文件里面显然不合适。我们应该通过下面的方式设置</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database &quot;your_database&quot; <span class="keyword">set</span> search_path <span class="operator">=</span> metadata_schema,metadata_schema,platform_schema,public;</span><br></pre></td></tr></table></figure><p>这样就可以精确到对一个库设置它的默认<code>search_path</code>了。设置完毕后，重新建立数据库连接，执行<code>show search_path;</code>可以查看设置结果。<br>除了上面通过<code>alter database</code>之外，<code>alter role</code>也能起到类似的效果，还靠小伙伴们自行发掘了。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh连接保活，mosh初体验</title>
      <link href="/2018/08/25/mosh/"/>
      <url>/2018/08/25/mosh/</url>
      
        <content type="html"><![CDATA[<p>传统的<code>ssh</code>最恼人的就是放着不动，没多久就丢了。有时候<code>tail -f</code>跟踪一个日志，一会日志没动静，可能<code>ssh</code>就已经阵亡了，而我还没反应过来，还琢磨着日志该出来了。烦。<br>前两天研究<code>iTerm2</code>的时候，看到有人分享<code>mosh</code>的相关知识，提到它最大的优点就是<code>ssh</code>保活。马上决定一试。</p><ol><li><p>服务端安装</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> mosh</span><br></pre></td></tr></table></figure></li><li><p>防火墙放行端口，端口从<code>60000</code>排队起步，根据同时可能产生的连接数量，适当放行几个就好</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=60000-60010/udp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>客户端同样安装<code>mosh</code></p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>mosh</span><br></pre></td></tr></table></figure></li><li><p>客户端使用</p> <figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mosh</span> -ssh=<span class="string">&quot;ssh -p 3322&quot;</span> root@<span class="number">192.168.0.88</span></span><br></pre></td></tr></table></figure><p> 上面的<code>-ssh</code>命令主要是用在<code>ssh</code>端口不是开在<code>22</code>的情况下，需要指定端口。因为<code>mosh</code>自己的<code>-p</code>是指的<code>mosh</code>自身要用的<code>udp</code>端口。<br> 另外，如果你维护了<code>～/.ssh/config</code>文件的话，那么恭喜你，<code>mosh</code>可以直接读取这个<code>config</code>，也就是说，之前<code>ssh a_server</code>可以无缝替换成<code>mosh a_server</code></p></li><li><p>排错，如果遇到客户端访问不了服务器，并且有如下提示</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">locale: Cannot <span class="built_in">set</span> LC_CTYPE <span class="keyword">to</span><span class="built_in"> default </span>locale: <span class="literal">No</span> such file <span class="keyword">or</span> directory</span><br><span class="line">locale: Cannot <span class="built_in">set</span> LC_ALL <span class="keyword">to</span><span class="built_in"> default </span>locale: <span class="literal">No</span> such file <span class="keyword">or</span> directory</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line"><span class="built_in">..</span>.<span class="built_in"></span></span><br><span class="line"><span class="built_in">Connection </span><span class="keyword">to</span> xxx.xxx.xxx.xxx closed.</span><br><span class="line">/usr/local/bin/mosh: Did <span class="keyword">not</span> <span class="built_in">find</span> mosh<span class="built_in"> server </span>startup message. (Have you installed mosh on your server?)</span><br></pre></td></tr></table></figure><p> 可以尝试在服务器上的<code>~/.bashrc</code>文件追加这两行解决</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">LANG</span>=en_US.UTF-8</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">LC_ALL</span>=en_US.UTF-8</span><br></pre></td></tr></table></figure></li><li><p>最后说下实际体验感受<br> 的确大大延长了<code>ssh</code>的可用时间，但是像网上说的能坚持个个把月，很遗憾我并没有那么幸运，不过<code>mosh</code>仍然是个值得推荐的工具。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javalin又一个小而美的Java Web框架</title>
      <link href="/2018/08/24/javalin/"/>
      <url>/2018/08/24/javalin/</url>
      
        <content type="html"><![CDATA[<p><code>Javalin</code>是<code>JVM</code>平台下一个上手极为容易的<code>Web</code>框架。有这么几个显著的特点：</p><ol><li>简单便捷，不论是概念上还是真正上手开发，给人的感觉就是轻松写意</li><li>灵活，可以兼容同步和异步两种编程思路</li><li>小，即使是打成一个可以独立运行的<code>fat-jar</code>，大小才<code>4～5M</code>，就算把常用的<code>log</code>、<code>jdbc</code>等常用库放进去，估计也到不了<code>10M</code></li></ol><p>官方支持的语言是<code>Java</code>和<code>Kotlin</code>，当然还有跟<code>Java</code>无缝兼容的<code>Groovy</code>，这个相当于买一赠一了。下面我们直接看一下<code>Kotlin</code>简单demo</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> con.aruistar.studyjavalin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.javalin.Javalin</span><br><span class="line"></span><br><span class="line">data <span class="keyword">class</span> <span class="title class_">User</span>(val name: String, val id: Int)</span><br><span class="line"></span><br><span class="line">fun <span class="title function_">main</span><span class="params">(args: Array&lt;String&gt;)</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">app</span> <span class="operator">=</span> Javalin.create().start(<span class="number">7000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="type">val</span> <span class="variable">map</span> <span class="operator">=</span> hashMapOf&lt;String, Int&gt;()</span><br><span class="line">    map.put(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    map.put(<span class="string">&quot;two&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    app.get(<span class="string">&quot;/&quot;</span>) &#123; ctx -&gt; ctx.result(<span class="string">&quot;Hello World&quot;</span>) &#125;</span><br><span class="line">    app.get(<span class="string">&quot;/json&quot;</span>) &#123; ctx -&gt; ctx.json(User(<span class="string">&quot;Alex&quot;</span>, <span class="number">1</span>)) &#125;</span><br><span class="line">    app.get(<span class="string">&quot;/json/map&quot;</span>) &#123; ctx -&gt; ctx.json(map) &#125;</span><br><span class="line">    app.after &#123; ctx -&gt;</span><br><span class="line">        println(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">        println(ctx.resultString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有一种简单到没朋友的感觉，我想这段代码我不多解释，大家也都看得懂。其他特性还有很多，这里我从文档上摘录几个比较实用的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">get(<span class="string">&quot;/hello/*/and/*&quot;</span>, ctx -&gt; &#123;</span><br><span class="line">    ctx.result(<span class="string">&quot;Hello: &quot;</span> + ctx.splat(<span class="number">0</span>) + <span class="string">&quot; and &quot;</span> + ctx.splat(<span class="number">1</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">app.routes(() -&gt; &#123;</span><br><span class="line">    path(<span class="string">&quot;users&quot;</span>, () -&gt; &#123;</span><br><span class="line">        get(UserController::getAllUsers);</span><br><span class="line">        post(UserController::createUser);</span><br><span class="line">        path(<span class="string">&quot;:id&quot;</span>, () -&gt; &#123;</span><br><span class="line">            get(UserController::getUser);</span><br><span class="line">            patch(UserController::updateUser);</span><br><span class="line">            delete(UserController::deleteUser);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">app.exception(NullPointerException.class, (e, ctx) -&gt; &#123;</span><br><span class="line">    <span class="comment">// handle nullpointers here</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">app.error(<span class="number">404</span>, ctx -&gt; &#123;</span><br><span class="line">    ctx.result(<span class="string">&quot;Generic 404 message&quot;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更多功能请查看官方文档<a href="https://javalin.io/documentation">javalin</a></p><h3 id="最后说一下我个人对这个框架的一些看法"><a href="#最后说一下我个人对这个框架的一些看法" class="headerlink" title="最后说一下我个人对这个框架的一些看法"></a>最后说一下我个人对这个框架的一些看法</h3><p>如果你是个<code>Java</code>程序员，还从来没有用过<code>Spring</code>以外的<code>WEB</code>框架，那我推荐你试试<code>Javalin</code>；但如果你是站在公司立场，要为下一个项目做技术选型的话，我更建议你用经受过多年市场考验的<a href="http://vertx.io/">Vert.x</a>。<br>如果你的项目中已经用过<a href="http://sparkjava.com/">SparkJava</a>了，那我觉得<code>Javalin</code>应该也在你的备选技术清单里。<br>如果你是<code>node.js</code>程序员，想涉猎一下<code>Java</code>方面的开发，<code>Javalin</code>可能是个不错的尝试，因为从中你能找到<code>koa</code>的影子，我想你会觉得无比亲切。</p><hr><p>本文demo已上传至<a href="https://github.com/aruis/studyjavalin">https://github.com/aruis/studyjavalin</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一个因为JDBC及PostgreSQL过于优秀而导致的坑</title>
      <link href="/2018/08/23/defect_jdbc_postgresql/"/>
      <url>/2018/08/23/defect_jdbc_postgresql/</url>
      
        <content type="html"><![CDATA[<p>假设存在这么一张表，记录全国各地大学的名称，以及所处的行政区划</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 大学信息表</span><br><span class="line">(</span><br><span class="line">    id <span class="type">varchar</span> <span class="keyword">DEFAULT</span> uuid_generate_v4() <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    v_name <span class="type">varchar</span>,</span><br><span class="line">    v_所处行政区划代码 <span class="type">varchar</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中，行政区划是国家标准的，也就是你身份证开头的6位，能够精确到区、县的。两位一个级别，前六位，可以笼统的概括成，省及、市级、县级，当然还有直辖市、特别行政区什么的，先不必深究，暂且简化这个逻辑就好了。<br>现在问题来了，如果想统计各省份大学的数量，是不是该用这条<code>SQL</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">left</span>(v_所处行政区划代码, <span class="number">2</span>), <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> 大学信息表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">left</span>(v_所处行政区划代码, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>对需求敏感的小伙伴肯定看出来了，上面的<code>2</code>在设计接口的时候应该设计成参数，万一要统计各城市的大学数量，直接传<code>4</code>不就好了。<br>所以在<code>Java</code>中，我们大约会写这么一段代码</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PreparedStatement pstmt <span class="operator">=</span> conn.prepareStatement(&quot;&quot;&quot;</span><br><span class="line">select left(v_所处行政区划代码, ?), count(*) as num</span><br><span class="line">from 大学信息表</span><br><span class="line">group by left(v_所处行政区划代码, ?);</span><br><span class="line">&quot;&quot;&quot;);</span><br><span class="line"></span><br><span class="line">pstmt.setInt(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">pstmt.setInt(<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>就是用两处<code>?</code>占位，然后传入相同的参数。<strong>可惜事与愿违，这段<code>SQL</code>一定是报错的</strong>，会有提示</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">column</span> &quot;大学信息表.v_所处行政区划代码&quot; must appear <span class="keyword">in</span> the <span class="keyword">GROUP</span> <span class="keyword">BY</span> clause <span class="keyword">or</span> be used <span class="keyword">in</span> an aggregate <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>简单的说，数据库不认为<code>select</code>中的<code>left(v_所处行政区划代码, ?)</code>跟<code>group by</code>中的<code>left(v_所处行政区划代码, ?)</code>是一个东西，所以认为我们在查询了一个没有<code>group by</code>也没有聚合函数的数据，属于<code>SQL</code>语法错误。<br>下面尝试分析原因：</p><ol><li>原始<code>SQL</code>在<code>PostgreSQL</code>中独立执行，完全没问题，所以肯定不是<code>PostgreSQL</code>的问题</li><li>用<code>Python</code>（<code>psycopg2</code>）实现了同样的逻辑，然而没有报错，所以还得从<code>JDBC</code>+<code>PostgreSQL</code>上找原因</li><li>去数据库服务器看日志，发现问题，当<code>JDBC</code>请求的时候，后台日志是<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">STATEMENT:</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">left</span>(v_所处行政区划代码, $<span class="number">1</span>), <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num</span><br><span class="line"><span class="keyword">from</span> 大学信息表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">left</span>(v_所处行政区划代码, $<span class="number">2</span>)</span><br><span class="line">DETAIL:  parameters: $<span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span>, $<span class="number">2</span> <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span></span><br></pre></td></tr></table></figure> 而当<code>Python</code>请求时，后台日志是<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">left</span>(v_所处行政区划代码, <span class="number">2</span>), <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num</span><br><span class="line"><span class="keyword">from</span> 大学信息表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">left</span>(v_所处行政区划代码, <span class="number">2</span>)</span><br></pre></td></tr></table></figure> 是不是有一种见了鬼的感觉，</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在使用<code>JDBC</code>操作<code>PostgreSQL</code>时，<code>JAVA</code>中的<code>prepareStatement</code>会精准换算成<code>PostgreSQL</code>中的<a href="http://www.postgres.cn/docs/10/sql-prepare.html">PREPARE</a>，而在<code>PREPARE</code>的时候，参数还没给出，所以<code>PostgreSQL</code>会认为<code>select</code>的<code>left(v_所处行政区划代码, $1)</code>并未参与<code>group by</code>，因而<code>PREPARE</code>报错，导致最终<code>SQL</code>执行失败。<br>而在<code>psycopg2</code>+<code>PostgreSQL</code>的环境中，并没有像<code>JDBC</code>那样充分利用<code>PostgreSQL</code>的<code>PREPARE</code>特性，而是在程序侧就换算好了<code>SQL</code>语句，所以反而不会报错。<br><em>显然，是<code>JDBC</code>的设计更细致，但是却给自己挖了个坑</em></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL打开SQL日志</title>
      <link href="/2018/08/22/PostgreSQL_show_SQL_logs/"/>
      <url>/2018/08/22/PostgreSQL_show_SQL_logs/</url>
      
        <content type="html"><![CDATA[<p>找到<code>PostgreSQL</code>安装目录所在的地方，编辑配置文件<code>postgresql.conf</code><br>确保</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log_destination</span> = <span class="string">&#x27;stderr&#x27;</span></span><br></pre></td></tr></table></figure><p>这样可以打开日志功能<br>然后找到<code>atement</code>设置成<code>all</code></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log_statement</span> = <span class="string">&#x27;all&#x27;</span></span><br></pre></td></tr></table></figure><p>重启服务之后就可以跟踪到所有的<code>SQL</code>语句了。</p><p>当然其他还有很多配置，可以进行更细致的定制，可以参考官方文档<a href="http://www.postgres.cn/docs/10/runtime-config-logging.html">错误报告和日志</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>groovy中的正则使用</title>
      <link href="/2018/08/21/groovy_regular/"/>
      <url>/2018/08/21/groovy_regular/</url>
      
        <content type="html"><![CDATA[<h4 id="判断是否与正则匹配"><a href="#判断是否与正则匹配" class="headerlink" title="判断是否与正则匹配"></a>判断是否与正则匹配</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">def res = <span class="string">&quot;522300000000&quot;</span> ==~ <span class="regexp">/\d*0&#123;8&#125;$/</span></span><br><span class="line"><span class="regexp">//</span> res is true</span><br></pre></td></tr></table></figure><h4 id="从字符串中找到匹配的内容"><a href="#从字符串中找到匹配的内容" class="headerlink" title="从字符串中找到匹配的内容"></a>从字符串中找到匹配的内容</h4><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> res = <span class="string">&quot;hello110,world&quot;</span> =~ <span class="regexp">/\d+/</span></span><br><span class="line"><span class="keyword">println</span>(res[<span class="number">0</span>])</span><br><span class="line"><span class="comment">//res[0] is 110</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黔西南州兴义市马岭河峡谷半日游</title>
      <link href="/2018/08/20/xingyi-malinghe/"/>
      <url>/2018/08/20/xingyi-malinghe/</url>
      
        <content type="html"><![CDATA[<p>最近在贵州出差，一个小城市，兴义市，隶属于黔西南布依族苗族自治州。周末去了趟当地的景点——马岭河峡谷，感觉不错，几处瀑布意境各不相同。随手拍了几张照片，聊作纪念。<br><img src="/media/IMG_7384.jpg"><br><img src="/media/IMG_7284.jpg"><br><img src="/media/IMG_7350.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux防火墙常用命令</title>
      <link href="/2018/08/19/Linux_firewall-cmd/"/>
      <url>/2018/08/19/Linux_firewall-cmd/</url>
      
        <content type="html"><![CDATA[<ol><li><p>安装防火墙</p> <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> firewalld</span><br></pre></td></tr></table></figure></li><li><p>永久放行端口</p> <figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">firewall</span><span class="literal">-</span><span class="comment">cmd</span> <span class="literal">--</span><span class="comment">add</span><span class="literal">-</span><span class="comment">port=54321/tcp</span> <span class="literal">--</span><span class="comment">permanent</span></span><br></pre></td></tr></table></figure><p> <em>临时的话，把–permanent去掉</em></p></li><li><p>使配置生效</p> <figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">firewall-cmd <span class="comment">--reload</span></span><br></pre></td></tr></table></figure></li><li><p>移除放行端口</p> <figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">firewall</span><span class="literal">-</span><span class="comment">cmd</span> <span class="literal">--</span><span class="comment">remove</span><span class="literal">-</span><span class="comment">port=54321/tcp</span> <span class="literal">--</span><span class="comment">permanent</span></span><br></pre></td></tr></table></figure></li><li><p>查看所有放行端口</p> <figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">firewall-cmd <span class="comment">--list-ports</span></span><br></pre></td></tr></table></figure></li></ol><p>这里只列出最简单的一些用法，更多高阶用法请查看官方文档：<a href="https://firewalld.org/documentation/man-pages/firewall-cmd.html">https://firewalld.org/documentation/man-pages/firewall-cmd.html</a>        </p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免开发环境在GitHub站点上快速给开源项目贡献代码</title>
      <link href="/2018/08/18/github-pull-request/"/>
      <url>/2018/08/18/github-pull-request/</url>
      
        <content type="html"><![CDATA[<p>给开源项目贡献代码应该算是进阶程序员的一条必经之路。今天我就简单介绍一下，如何在不clone代码，不使用本地开发环境的情况下，给GitHub上的开源项目贡献代码。<br>还没有GitHub账号的小伙伴，就抓紧注册个吧，其他就没有任何必要条件了。</p><h3 id="第一步，发现问题"><a href="#第一步，发现问题" class="headerlink" title="第一步，发现问题"></a>第一步，发现问题</h3><p>这个我可教不了，只能介绍一下我自己的经验，就是多看，多想。比如我今天举例的就是<code>JVM</code>下知名项目<code>Vert.x</code>，官方维护的<a href="https://github.com/vert-x3/vertx-examples">vertx-examples</a>，我发现他在介绍<code>gradle-redeploy</code>的时候，其中<code>build.gradle</code>有一段写得就不够严谨，他是这么写的：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vert.x will call this task on changes</span></span><br><span class="line"><span class="function">def doOnChange</span></span><br><span class="line"><span class="function"><span class="title">if</span> (<span class="params">System.getProperty(<span class="string">&quot;os.name&quot;</span></span>).<span class="title">toLowerCase</span>().<span class="title">contains</span>(<span class="params"><span class="string">&quot;windows&quot;</span></span>))</span> &#123;</span><br><span class="line">  doOnChange = <span class="string">&#x27;.\\gradlew classes&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doOnChange = <span class="string">&#x27;./gradlew classes&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过我之前博客的小伙伴应该知道，操作系统的文件分割符，<code>Java</code>中是提供静态方法等多种方式来获取的，不需要通过自己手动判断操作系统的名字来自己实现。所以我决定把这段代码优化一下。也就是这篇博客的起因。</p><h3 id="第二步，Fork代码"><a href="#第二步，Fork代码" class="headerlink" title="第二步，Fork代码"></a>第二步，<code>Fork</code>代码</h3><p>点这里即可：<br><img src="/media/%E7%B2%98%E8%B4%B4%E7%9A%84%E5%9B%BE%E7%89%872018_8_18_14_23.png"><br><code>Fork</code>成功之后，会自动进入到自己命名空间下的项目<br><img src="/media/15345735455740.jpg"></p><h3 id="第三步，创建分支"><a href="#第三步，创建分支" class="headerlink" title="第三步，创建分支"></a>第三步，创建分支</h3><p><code>GitHub</code>上的<code>Pull Request</code>都是基于分支的，也就是说想要贡献代码，要先创建一个分支，在上面承载你的代码变更。其实做起来也相当简单，如图：<img src="/media/%E7%B2%98%E8%B4%B4%E7%9A%84%E5%9B%BE%E7%89%872018_8_18_14_28.png"></p><h3 id="第四步，修改代码"><a href="#第四步，修改代码" class="headerlink" title="第四步，修改代码"></a>第四步，修改代码</h3><p>之后就会进入到自己新建的分支，找到要修改的代码后，点编辑按钮，如图<img src="/media/%E7%B2%98%E8%B4%B4%E7%9A%84%E5%9B%BE%E7%89%872018_8_18_14_32.png"></p><p>把我之前说的代码改成：</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">def <span class="attr">doOnChange</span> = <span class="string">&quot;.<span class="subst">$&#123;File.separator&#125;</span>gradlew classes&quot;</span></span><br></pre></td></tr></table></figure><p>一行搞定，是不是简单多了。<br>编辑完代码后，在屏幕最下方，提交代码，注意要写一个理由充分的提交注释，证明你改变代码的必要性<br><img src="/media/15345741245811.jpg"></p><h3 id="第五步，发起Pull-Request"><a href="#第五步，发起Pull-Request" class="headerlink" title="第五步，发起Pull Request"></a>第五步，发起<code>Pull Request</code></h3><p>把修改<code>commit</code>之后，回到自己的项目首页，就可以看到一句提示，问你要不要把刚修改的那个分支去跟原始项目比较，并且发起<code>pull request</code>，如图<img src="/media/%E7%B2%98%E8%B4%B4%E7%9A%84%E5%9B%BE%E7%89%872018_8_18_14_39.png"></p><p>点击这个按钮后，进入最后的<code>Open a pull request</code>界面，再次要把提交说明写到位，就可以点<code>Create pull request</code>按钮正式发起贡献代码请求了。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>基本开源项目都有自动化的代码审查，比如单元测试、格式规范检查之类的，发起<code>PR</code>之后也要留意观看，万一发现自己代码有问题，还可以继续更改</li><li>之后还回到自己分支，产生的更改，就不用重新发起<code>PR</code>了，只要<code>commit</code>之后，之前的<code>PR</code>可以直接看到</li><li>一旦<code>PR</code>成功，就可以在原始项目的<code>contributors</code>中找到自己的账户了。希望你到时候可以榜上有名；）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中实现更新默认值（二）</title>
      <link href="/2018/08/17/PostgreSQL_auto_modify_defaults_2/"/>
      <url>/2018/08/17/PostgreSQL_auto_modify_defaults_2/</url>
      
        <content type="html"><![CDATA[<p>今天我们用<code>表继承</code>+<code>触发器</code>的方案，来实现表中的更新默认值。这也许是<code>PostgreSQL</code>里最佳的解决方案。</p><h4 id="一-创建一张表，作为父表"><a href="#一-创建一张表，作为父表" class="headerlink" title="一. 创建一张表，作为父表"></a>一. 创建一张表，作为父表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> basic_update</span><br><span class="line">(</span><br><span class="line">  t_update <span class="type">timestamp</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="二-创建一个函数，用作最后负责修改t-update使用"><a href="#二-创建一个函数，用作最后负责修改t-update使用" class="headerlink" title="二. 创建一个函数，用作最后负责修改t_update使用"></a>二. 创建一个函数，用作最后负责修改<code>t_update</code>使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> update_modified_column()</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  NEW.t_update <span class="operator">=</span> now();</span><br><span class="line">  <span class="keyword">RETURN</span> <span class="keyword">NEW</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$</span><br><span class="line"><span class="keyword">language</span> <span class="string">&#x27;plpgsql&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="三-创建一个函数，用来给继承了basic-update的表新增一个触发器，怼上第二步的函数"><a href="#三-创建一个函数，用来给继承了basic-update的表新增一个触发器，怼上第二步的函数" class="headerlink" title="三. 创建一个函数，用来给继承了basic_update的表新增一个触发器，怼上第二步的函数"></a>三. 创建一个函数，用来给继承了<code>basic_update</code>的表新增一个触发器，怼上第二步的函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> table_create()</span><br><span class="line">  <span class="keyword">returns</span> event_trigger</span><br><span class="line"><span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span> oid           <span class="type">INT</span>;</span><br><span class="line">        table_name    <span class="type">VARCHAR</span>;</span><br><span class="line">        parent_tables <span class="type">VARCHAR</span> [];</span><br><span class="line">        is_update     BOOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> object_identity</span><br><span class="line">      <span class="keyword">INTO</span> table_name <span class="keyword">FROM</span> pg_event_trigger_ddl_commands();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> objid</span><br><span class="line">      <span class="keyword">INTO</span> oid <span class="keyword">FROM</span> pg_event_trigger_ddl_commands();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> get_parent_tables_by_oid(oid)</span><br><span class="line">      <span class="keyword">INTO</span> parent_tables;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> parent_tables :: TEXT [] @<span class="operator">&gt;</span> <span class="string">&#x27;&#123;basic_update&#125;&#x27;</span> :: TEXT []</span><br><span class="line">      <span class="keyword">INTO</span> is_update;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  IF is_update</span><br><span class="line"></span><br><span class="line">  <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">EXECUTE</span> <span class="string">&#x27;CREATE TRIGGER tgr_auto_t_update&#x27;</span></span><br><span class="line">            <span class="operator">||</span> <span class="string">&#x27; BEFORE UPDATE ON  &#x27;</span></span><br><span class="line">            <span class="operator">||</span> table_name</span><br><span class="line">            <span class="operator">||</span> <span class="string">&#x27; FOR EACH ROW EXECUTE PROCEDURE update_modified_column()&#x27;</span>;</span><br><span class="line">  <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h4 id="四-创建一个建表时的触发器，接管创建表的时机，怼上第三步的函数"><a href="#四-创建一个建表时的触发器，接管创建表的时机，怼上第三步的函数" class="headerlink" title="四. 创建一个建表时的触发器，接管创建表的时机，怼上第三步的函数"></a>四. 创建一个建表时的触发器，接管创建表的时机，怼上第三步的函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EVENT <span class="keyword">TRIGGER</span> etgr_table_create</span><br><span class="line"><span class="keyword">ON</span> ddl_command_end</span><br><span class="line"><span class="keyword">WHEN</span> TAG <span class="keyword">IN</span> (<span class="string">&#x27;CREATE TABLE&#x27;</span>)</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> table_create();</span><br></pre></td></tr></table></figure><h4 id="五-所有操作已经完成，可以创建一个表测试了"><a href="#五-所有操作已经完成，可以创建一个表测试了" class="headerlink" title="五. 所有操作已经完成，可以创建一个表测试了"></a>五. 所有操作已经完成，可以创建一个表测试了</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test</span><br><span class="line">(</span><br><span class="line">  id        <span class="type">varchar</span> <span class="keyword">default</span> uuid_generate_v4() <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">    <span class="keyword">constraint</span> test_pkey</span><br><span class="line">    <span class="keyword">primary</span> key,</span><br><span class="line">  text      <span class="type">varchar</span>,</span><br><span class="line">  t_create  <span class="type">timestamp</span> <span class="keyword">default</span> now()</span><br><span class="line">)</span><br><span class="line">  inherits (basic_update);</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test (<span class="type">text</span>)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> test</span><br><span class="line"><span class="keyword">set</span> <span class="type">text</span> = <span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中实现更新默认值（一）</title>
      <link href="/2018/08/16/PostgreSQL_auto_modify_defaults_1/"/>
      <url>/2018/08/16/PostgreSQL_auto_modify_defaults_1/</url>
      
        <content type="html"><![CDATA[<p>业务系统中，经常会在设计表的时候，考虑这两个字段：新增时间、修改时间。前者用数据库的基础功能即可实现，后者就要采取一些手段了。<br>在<code>PostgreSQL</code>中的最佳实践是采用触发器，捕捉<code>UPDATE</code>实践，虽然听起来很可怕，但其实并不难。</p><ol><li><p>首先创建一个函数，作用就是给一行数据，追加某个值（这里我用的字段名是<code>t_update</code>）</p> <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR REPLACE</span> <span class="keyword">FUNCTION</span> update_modified_column()</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="type">TRIGGER</span> <span class="keyword">AS</span> $$<span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">BEGIN</span></span></span><br><span class="line"><span class="language-pgsql">  <span class="built_in">NEW</span>.t_update = now();</span></span><br><span class="line"><span class="language-pgsql">  <span class="keyword">RETURN</span> <span class="built_in">NEW</span>;</span></span><br><span class="line"><span class="language-pgsql"><span class="keyword">END</span>;</span></span><br><span class="line"><span class="language-pgsql">$$</span></span><br><span class="line"><span class="keyword">language</span> <span class="string">&#x27;plpgsql&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>然后就是把这个函数怼到触发器上</p> <figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TRIGGER tgr_auto_t_update</span><br><span class="line">  BEFORE UPDATE</span><br><span class="line">  <span class="keyword">ON</span> a_table</span><br><span class="line">  <span class="keyword">FOR</span> <span class="keyword">EACH</span> ROW EXECUTE <span class="keyword">PROCEDURE</span> <span class="title function_">update_modified_column</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li></ol><p>这样就大功告成了。但是如果有很多表的话，感觉还是有重复劳动，不够优雅。明天我将结合昨天提到的表继承，最大化的减少工作量，用更优雅的方法实现更新默认值的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中用递归CTE获取一张表的所有祖先表</title>
      <link href="/2018/08/15/PostgreSQL_with_recursive/"/>
      <url>/2018/08/15/PostgreSQL_with_recursive/</url>
      
        <content type="html"><![CDATA[<p>今天介绍两个知识点：</p><ol><li>PostgreSQL的表继承</li><li>PostgreSQL中的可递归CTE</li></ol><h3 id="表继承"><a href="#表继承" class="headerlink" title="表继承"></a>表继承</h3><p>表继承是PostgreSQL独有的功能，就是在<code>create table</code>的时候可以通过<code>inherits</code>关键字指定若干个父表，如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test</span><br><span class="line">(</span><br><span class="line">  id       <span class="type">varchar</span> <span class="keyword">default</span> uuid_generate_v4() <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">    <span class="keyword">constraint</span> test_pkey</span><br><span class="line">    <span class="keyword">primary</span> key,</span><br><span class="line">  text     <span class="type">varchar</span>,</span><br><span class="line">  t_create <span class="type">timestamp</span> <span class="keyword">default</span> now()</span><br><span class="line">)</span><br><span class="line">  inherits (basic_update);</span><br></pre></td></tr></table></figure><p>继承父表，有如下几个特性：</p><ul><li>父表的字段会自动加入子表中来</li><li>父表上的所有检查约束和非空约束都将自动被它的后代所继承， 除非使用 NO INHERIT子句明确指定。其他类型的约束（唯一、主键和外键约束）则不会被继承</li><li>插入子表的数据，在父表中默认是可以查询到的，除非在对父表查询时，表名前加入<code>only</code>修饰符</li></ul><h3 id="递归CTE"><a href="#递归CTE" class="headerlink" title="递归CTE"></a>递归CTE</h3><p>可选的RECURSIVE修饰符将WITH从单纯的句法便利变成了一种在标准SQL中不能完成的特性。通过使用RECURSIVE，一个WITH查询可以引用它自己的输出。一个非常简单的例子是计算从1到100的整数合的查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> t(n) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> n<span class="operator">+</span><span class="number">1</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> n <span class="operator">&lt;</span> <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(n) <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure><h3 id="回到今天的主题，PostgreSQL中用递归CTE获取一张表的所有祖先表"><a href="#回到今天的主题，PostgreSQL中用递归CTE获取一张表的所有祖先表" class="headerlink" title="回到今天的主题，PostgreSQL中用递归CTE获取一张表的所有祖先表"></a>回到今天的主题，PostgreSQL中用递归CTE获取一张表的所有祖先表</h3><p>这里我直接通过创建一个函数来封装这个功能，具体逻辑就在函数中，相信有前面两个知识点的铺垫，小伙伴们应该也能看懂了</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> get_parent_tables_by_oid(me <span class="type">integer</span>)</span><br><span class="line">  <span class="keyword">returns</span> <span class="type">character</span> <span class="type">varying</span> []</span><br><span class="line"><span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span> parent_tables <span class="type">VARCHAR</span> [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> x <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_inherits <span class="keyword">WHERE</span> inhrelid <span class="operator">=</span> me</span><br><span class="line"></span><br><span class="line">      <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">SELECT</span> pg_inherits.<span class="operator">*</span> <span class="keyword">FROM</span> x</span><br><span class="line">                                  <span class="keyword">JOIN</span> pg_inherits <span class="keyword">ON</span> x.inhparent <span class="operator">=</span> pg_inherits.inhrelid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">array_agg</span>(pg_stat_user_tables.relname)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">INTO</span> parent_tables</span><br><span class="line"></span><br><span class="line">  <span class="keyword">FROM</span> x</span><br><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> pg_stat_user_tables <span class="keyword">ON</span> x.inhparent <span class="operator">=</span> pg_stat_user_tables.relid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">RETURN</span> parent_tables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$$;</span><br></pre></td></tr></table></figure><p>其中<code>inhrelid</code>是<code>PostgreSQL</code>中的一种元数据，可以理解成表的<code>id</code>，在知道表名的情况下怎么知道它的<code>id</code>呢，可以去元数据里面查，如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> relid <span class="keyword">FROM</span> pg_stat_user_tables <span class="keyword">WHERE</span> relname <span class="operator">=</span> <span class="string">&#x27;a_table&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vert.x项目监测代码变化自动冷重启</title>
      <link href="/2018/08/14/Vert-x_redeploy/"/>
      <url>/2018/08/14/Vert-x_redeploy/</url>
      
        <content type="html"><![CDATA[<p>传统的Java Web开发一般都会提供热重载的方式，方便开发人员在代码发生变化的时候，无需手动重启应用，就可以刷新到效果。用惯了的人，在用<code>Vert.x</code>开发的时候多少会有点不习惯，不过<code>Vert.x</code>程序启动速度还是很可观的，所以也勉强能忍。<br>后来通读文档的时候，发现有个关于<code>redeploy</code>的介绍，似乎能用，又似乎不好用的，直到看到官方的<a href="https://github.com/vert-x3/vertx-examples/tree/master/gradle-redeploy">Vert.x 3.2 Gradle redeploy project</a>总算豁然开朗了。<br>核心代码无非下面几行</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vert.x watches for file changes in all subdirectories</span></span><br><span class="line"><span class="comment">// of src/ but only for files with .java extension</span></span><br><span class="line">def watchForChange = <span class="string">&#x27;src/**/*.java&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Vert.x will call this task on changes</span></span><br><span class="line">def doOnChange</span><br><span class="line"><span class="keyword">if</span> (System.getProperty(<span class="string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="string">&quot;windows&quot;</span>)) &#123;</span><br><span class="line">  doOnChange = <span class="string">&#x27;.\\gradlew classes&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doOnChange = <span class="string">&#x27;./gradlew classes&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &#123;</span><br><span class="line">  args = [<span class="string">&#x27;run&#x27;</span>, mainVerticleName, <span class="string">&quot;--redeploy=<span class="subst">$watchForChange</span>&quot;</span>, <span class="string">&quot;--launcher-class=<span class="subst">$mainClassName</span>&quot;</span>, <span class="string">&quot;--on-redeploy=<span class="subst">$doOnChange</span>&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也尝试了一下，的确可用，但是这个官方示例还是有个地方写的不好，就是关于文件分割符的判断，恰好这个在我之前的帖子里面提到过，见<a href="https://www.kankanzhijian.com/2018/07/26separator_in_java/">编写跨操作系统Java代码时动态获取文件分隔符</a><br>所以上面的<code>gradle</code>代码关于<code>doOnChange</code>声明就可以简化成下面的样子了</p><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">def <span class="attr">doOnChange</span> = <span class="string">&quot;.<span class="subst">$&#123;File.separator&#125;</span>gradlew classes&quot;</span></span><br></pre></td></tr></table></figure><p>测试成功</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>家长的责任及义务</title>
      <link href="/2018/08/13/Parental_responsibilities_and_obligations/"/>
      <url>/2018/08/13/Parental_responsibilities_and_obligations/</url>
      
        <content type="html"><![CDATA[<h2 id="身为家长，到底能为孩子做些什么，什么又是最重要的呢"><a href="#身为家长，到底能为孩子做些什么，什么又是最重要的呢" class="headerlink" title="身为家长，到底能为孩子做些什么，什么又是最重要的呢"></a>身为家长，到底能为孩子做些什么，什么又是最重要的呢</h2><h3 id="我认为按重要程度，依次有这几点"><a href="#我认为按重要程度，依次有这几点" class="headerlink" title="我认为按重要程度，依次有这几点"></a>我认为按重要程度，依次有这几点</h3><ol><li>和睦温馨的家庭氛围</li><li>不论工作、学习如何辛苦，始终不忘身体健康是第一要务</li><li>活到老学到老的人生态度</li><li>能够支持孩子从事学习活动的经济基础</li></ol>]]></content>
      
      
      <categories>
          
          <category> 文艺中年 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教育子女 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一个Vert.x的自定义Launcher</title>
      <link href="/2018/08/12/my_luancher_in_vertx/"/>
      <url>/2018/08/12/my_luancher_in_vertx/</url>
      
        <content type="html"><![CDATA[<p>在<code>Vert.x</code>的官方example中，<code>mainClassName</code>一般是指定的<code>io.vertx.core.Launcher</code>，但是在实际应用中，如果我们也不加思索的用这个<code>Launcher</code>就会损失好多定制性，比如：</p><ul><li>blockedThreadCheckInterval（检查线程block定时时间间隔）</li><li>warningExceptionTime（block多久后开始打印堆栈信息）</li><li>maxEventLoopExecuteTime（允许<code>EventLoop</code>的最长执行时间）</li></ul><p>这些设置都是要在<code>Vertx</code>实例化之前准备好的，只要不是Embedded应用（也就是自己调用<code>Vertx.vertx()</code>），那就只剩接管<code>Launcher</code>这条路了，下面分享一个<code>groovy</code>版的自定义<code>Launcher</code></p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.vertx.core.Launcher</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.VertxOptions</span><br><span class="line"><span class="keyword">import</span> org.slf4j.bridge.SLF4JBridgeHandler</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">AruisLauncher</span> extends <span class="type">Launcher</span> &#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    static &#123;</span></span><br><span class="line"><span class="class">        <span class="type">SLF4JBridgeHandler</span>.removeHandlersForRootLogger();</span></span><br><span class="line"><span class="class">        <span class="type">SLF4JBridgeHandler</span>.install();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    static void main(<span class="type">String</span>[] <span class="title">args</span>) &#123;</span></span><br><span class="line"><span class="class">        new <span class="type">AruisLauncher</span>().dispatch(<span class="title">args</span>)</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    @<span class="type">Override</span></span></span><br><span class="line"><span class="class">    void beforeStartingVertx(<span class="type">VertxOptions</span> <span class="title">options</span>) &#123;</span></span><br><span class="line"><span class="class">        options.setWarningExceptionTime(10L * 1000 * 1000000)</span></span><br><span class="line"><span class="class">        options.setBlockedThreadCheckInterval(2000)</span></span><br><span class="line"><span class="class">        options.setMaxEventLoopExecuteTime(2L * 1000 * 1000000)</span></span><br><span class="line"><span class="class">        options.workerPoolSize = 20</span></span><br><span class="line"><span class="class">        super.beforeStartingVertx(<span class="title">options</span>)</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>在这个<code>Launcher</code>中，我还额外做了几件事：</p><ul><li>用<code>slf4j</code>接管了<code>Vert.x</code>的日志</li><li>提供一个<code>main</code>方法，方便<code>IDE</code>开发环境启动</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用pg_cron定时刷新PostgreSQL的物化视图</title>
      <link href="/2018/08/11/pg_cron_and_materialized_view/"/>
      <url>/2018/08/11/pg_cron_and_materialized_view/</url>
      
        <content type="html"><![CDATA[<p>在<code>PostgreSQL</code>中可以很轻松的创建物化视图，但是却没有自动刷新物化视图的机制。通常来说，不外乎两种方式，一种是通过触发器，另一种就是定时任务调度。今天我们就来说说第二种方式。<br>主要借助一个名为<a href="https://github.com/citusdata/pg_cron">pg_cron</a>的扩展。<br>安装方法在官方介绍里面已经说的很清楚了，不再赘述，这里提醒一点，安装完后，是需要修改<code>postgresql.conf</code>配置文件，并重启<code>PostgreSQL</code>服务的。具体修改如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">shared_preload_libraries</span> = <span class="string">&#x27;pg_cron&#x27;</span></span><br><span class="line"><span class="attr">cron.database_name</span> = <span class="string">&#x27;postgres&#x27;</span></span><br></pre></td></tr></table></figure><p>第二行的指定<code>cron</code>的元数据相关信息存放的数据库，是可以改成其他的。这里要明确一个概念，<code>cron</code>安装的数据库，和它要控制的数据库没有什么必然联系，并不因为说安装在了<code>postgres</code>库，就不能调度其他库了，这个在后续具体配置的时候，就能明白了。<br>做完上述步骤，保证<code>PostgreSQL</code>服务重启过后，就可以用<code>psql</code>或其他工具连接到<code>cron.database_name</code>对应的数据，执行</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTENSION</span> pg_cron;</span><br></pre></td></tr></table></figure><p>如果不在指定的库执行的话，会遇到错误</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Jobs must be scheduled <span class="keyword">from</span> the <span class="keyword">database</span> configured <span class="keyword">in</span> cron.database_name, since the pg_cron background worker reads job descriptions <span class="keyword">from</span> this <span class="keyword">database</span>.</span><br></pre></td></tr></table></figure><p>届时注意即可。<br>一切准备就绪后，就可以使用了，使用方式相当简单。这里我用一个查询<code>now()</code>的物化视图做演示</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">materialized</span> <span class="keyword">view</span> now <span class="keyword">as</span> <span class="keyword">select</span> now();</span><br><span class="line"><span class="keyword">SELECT</span> cron.schedule(<span class="string">&#x27;26 * * * *&#x27;</span>, <span class="string">&#x27;refresh materialized view now;&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这就实现了每小时26分的时候去刷新物化视图，也就是意味着，任意时候执行</p><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> now;</span><br></pre></td></tr></table></figure><p>获得的结果，都是距离此刻最近的26分，而不是当前时间。<br>那么，已经创建的任务，该如何管理呢。其实很简单，定时任务数据都存放在<code>cron.job</code>表中，我们看看里面的数据就明白了。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">+<span class="params">---------</span>+<span class="params">------------</span>+<span class="params">--------------------------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+</span><br><span class="line">| jobid   | schedule   | <span class="keyword">command</span>                        | nodename   | nodeport   | database   | username   |</span><br><span class="line">|<span class="params">---------</span>+<span class="params">------------</span>+<span class="params">--------------------------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>|</span><br><span class="line">| 1       | 26 * * * * | refresh materialized view now; | localhost  | 5432       | analyze    | postgres   |</span><br><span class="line">+<span class="params">---------</span>+<span class="params">------------</span>+<span class="params">--------------------------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+</span><br></pre></td></tr></table></figure><p>如果要取消一个任务，就需要拿到<code>jobid</code>，然后执行下面这句就好了。</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cron.unschedule(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL修改FDW相关配置</title>
      <link href="/2018/08/10/PostgreSQL_alert_foreign_server/"/>
      <url>/2018/08/10/PostgreSQL_alert_foreign_server/</url>
      
        <content type="html"><![CDATA[<p>必要的时候要修改<code>PostgreSQL</code>中配置的外部服务器。有个<code>ALTER SERVER</code>命令是专门应对这种场景的。比如我的外部数据源服务器地址换了，只需要改下之前配置的<code>host</code>地址即可，<code>SQL</code>如下</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SERVER</span> foreign_server <span class="keyword">OPTIONS</span> (<span class="keyword">set</span> host <span class="string">&#x27;192.168.0.88&#x27;</span>);</span><br></pre></td></tr></table></figure><p>更多内容可以查看官方文档[<a href="http://www.postgres.cn/docs/9.6/sql-alterserver.html]">http://www.postgres.cn/docs/9.6/sql-alterserver.html]</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中的distinct on</title>
      <link href="/2018/08/09/PostgreSQL_distinct-on/"/>
      <url>/2018/08/09/PostgreSQL_distinct-on/</url>
      
        <content type="html"><![CDATA[<p>想象有这么一张表，存放若干学生不同课程的考试成绩，需求是，找出每门课程中，成绩最好的学生。原始表大概如下：</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+--------------------------------------+-----------------+----------------+-----------+</span><br><span class="line">|<span class="string"> id                                   </span>|<span class="string"> v_studentname   </span>|<span class="string"> v_coursename   </span>|<span class="string"> i_score   </span>|</span><br><span class="line">|<span class="string">--------------------------------------+-----------------+----------------+-----------</span>|</span><br><span class="line">|<span class="string"> fb9fe43a-6f57-4f92-8678-139167693e72 </span>|<span class="string"> 张三            </span>|<span class="string"> 语文           </span>|<span class="string"> 91        </span>|</span><br><span class="line">|<span class="string"> 0898afd7-4253-496e-9190-36fae14bddf2 </span>|<span class="string"> 张三            </span>|<span class="string"> 数学           </span>|<span class="string"> 77        </span>|</span><br><span class="line">|<span class="string"> 2a1f810d-55ee-42cc-ac17-ee970154cecb </span>|<span class="string"> 张三            </span>|<span class="string"> 英语           </span>|<span class="string"> 90        </span>|</span><br><span class="line">|<span class="string"> fa975cd4-af5f-49d0-a89e-6f88665629eb </span>|<span class="string"> 李四            </span>|<span class="string"> 语文           </span>|<span class="string"> 88        </span>|</span><br><span class="line">|<span class="string"> 8833a07c-de8d-4b15-aa34-d9340c2e82c3 </span>|<span class="string"> 李四            </span>|<span class="string"> 数学           </span>|<span class="string"> 87        </span>|</span><br><span class="line">|<span class="string"> 1a9dfbdf-7c44-45d7-8141-590203aa26a9 </span>|<span class="string"> 李四            </span>|<span class="string"> 英语           </span>|<span class="string"> 89        </span>|</span><br><span class="line">|<span class="string"> cd3ec937-0ab9-4745-ad1a-c9f85839eaeb </span>|<span class="string"> 王五            </span>|<span class="string"> 语文           </span>|<span class="string"> 89        </span>|</span><br><span class="line">|<span class="string"> 431b7ccd-3a25-4ff4-9cc2-2e9f111f5c06 </span>|<span class="string"> 王五            </span>|<span class="string"> 数学           </span>|<span class="string"> 91        </span>|</span><br><span class="line">|<span class="string"> 8021e41d-09f5-49fb-a9e2-750d14bbff50 </span>|<span class="string"> 王五            </span>|<span class="string"> 英语           </span>|<span class="string"> 79        </span>|</span><br><span class="line">+--------------------------------------+-----------------+----------------+-----------+</span><br></pre></td></tr></table></figure><h2 id="传统方案"><a href="#传统方案" class="headerlink" title="传统方案"></a>传统方案</h2><p>传统的方法，要找每门课程成绩最好的学生的话，需要借助聚合函数，而且要几步操作：</p><ol><li>找到每门课程的最好成绩 <figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> v_coursename, <span class="built_in">max</span>(i_score)</span><br><span class="line"><span class="keyword">from</span> achievement</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> v_coursename;</span><br></pre></td></tr></table></figure></li><li>再跟<code>achievement</code>表<code>join</code>，才能找到该课程最高分对应的学生姓名。即使在有<code>CTE</code>支持的情况下，实现起来也很复杂 <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> cte <span class="keyword">as</span> (<span class="keyword">select</span> v_coursename, max(i_score) <span class="keyword">as</span> i_score <span class="keyword">from</span> achievement <span class="keyword">group</span> <span class="keyword">by</span> v_coursename)</span><br><span class="line"><span class="keyword">select</span> cte.*, achievement.v_studentname</span><br><span class="line"><span class="keyword">from</span> cte</span><br><span class="line">       <span class="keyword">join</span> achievement <span class="keyword">on</span> cte.i_score = achievement.i_score <span class="keyword">and</span> cte.v_coursename = achievement.v_coursename</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> cte.v_coursename;</span><br></pre></td></tr></table></figure> 要是没有<code>CTE</code>的支持，估计用纯数据库实现，就捉襟见肘了。</li></ol><h2 id="使用distinct-on的方案"><a href="#使用distinct-on的方案" class="headerlink" title="使用distinct on的方案"></a>使用distinct on的方案</h2><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">on</span> (v_coursename) * </span><br><span class="line"><span class="keyword">from</span> achievement</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> v_coursename, i_score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>一句话解决，是不是很开森。</p><h4 id="原理回顾"><a href="#原理回顾" class="headerlink" title="原理回顾"></a>原理回顾</h4><p><code>DISTINCT ON</code>是将结果集按指定字段值的去重，具体实现方法是先对结果集按照<code>DISTINCT ON</code>指定的字段进行排序，然后筛选出每个字段第一次出现时所在的记录，其余的记录都剔除。<br><code>ON</code>修饰符支持多列，运算时会基于多列的总体唯一性进行去重操作。同时查询语句必须要有<code>ORDER BY</code>，并且要保证排序字段从左至右的的顺序，应该是跟<code>DISTINCT ON</code>命中字段顺序相符合，当然<code>ORDER BY</code>可以追加更多的字段。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux软硬链接使用心得</title>
      <link href="/2018/08/08/Linux_ln/"/>
      <url>/2018/08/08/Linux_ln/</url>
      
        <content type="html"><![CDATA[<p><code>ln</code>命令，涉及到的软硬链接的核心概念已经被阐述的很多了。但是用的时候，到底用软链接，还是用硬链接，有时候还是会让人摸不着头绪。所以我尝试总结几点：</p><ol><li>软硬链接都能起到原始文件只占用一份磁盘资源的目的</li><li>硬链接不能针对文件夹，软链接无此限制</li><li>硬链接可以起到备份的作用，只要有硬链接在，原始文件就能访问；软链接无此效果</li><li>不论软链接，硬链接，<code>chmod</code>做的权限变更都具有传递性</li><li>软链接有个坑，如果原始文件删除之后，再创建一个同名的文件，软链接还会莫名其妙建立链接，这可能不一定是我们需要的</li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL删除数据库时提示other session using the database</title>
      <link href="/2018/08/07/PostgreSQL_drop_database_other-session-using-the-database/"/>
      <url>/2018/08/07/PostgreSQL_drop_database_other-session-using-the-database/</url>
      
        <content type="html"><![CDATA[<p>PostgreSQL中，如果想drop一个正在被人连接的数据库，是不可以的。提示如下：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">postgres=# <span class="keyword">drop</span> <span class="keyword">database</span> ka;</span><br><span class="line">ERROR:  <span class="keyword">database</span> &quot;ka&quot; <span class="keyword">is</span> being accessed <span class="keyword">by</span> other users</span><br><span class="line">DETAIL:  There <span class="keyword">is</span> <span class="number">1</span> other <span class="keyword">session</span> <span class="keyword">using</span> the <span class="keyword">database</span></span><br></pre></td></tr></table></figure><p>应对方法是要通过<code>pg_terminate_backend</code>系统内置函数，把对应库在线连接给清理掉，使用方法如下：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_terminate_backend(pg_stat_activity.pid)</span><br><span class="line">    <span class="keyword">FROM</span> pg_stat_activity</span><br><span class="line">    <span class="keyword">WHERE</span> pg_stat_activity.datname = <span class="string">&#x27;ka&#x27;</span></span><br><span class="line">      <span class="keyword">AND</span> pid &lt;&gt; pg_backend_pid();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cordova插件中定制build.gradle的方法</title>
      <link href="/2018/08/06/cordova_plugin_gradle/"/>
      <url>/2018/08/06/cordova_plugin_gradle/</url>
      
        <content type="html"><![CDATA[<p>编写<code>cordova</code>插件的时候，有时候要有进一步设置<code>build.gradle</code>文件的需求，比如追加个依赖什么的。这中问题，可以通过设置<code>cordova</code>的<code>plugin.xml</code>来解决的。分为如下几个步骤：</p><ol><li>编写cordova.build文件，文件名可以随便叫，内容就放你需要追加的个性化内容，比如我的是 <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        <span class="selector-tag">main</span> &#123;</span><br><span class="line">            jniLibs<span class="selector-class">.srcDirs</span> = <span class="selector-attr">[<span class="string">&#x27;libs&#x27;</span>]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在<code>plugin.xml</code>文件中<code>&lt;platform name=&quot;android&quot;&gt;&lt;/platform&gt;</code>区域内追加配置 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;framework <span class="attribute">src</span>=<span class="string">&quot;src/android/cordova.gradle&quot;</span> <span class="attribute">custom</span>=<span class="string">&quot;true&quot;</span> <span class="attribute">type</span>=<span class="string">&quot;gradleReference&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li></ol><p>更多信息可以查阅文档 <a href="https://cordova.apache.org/docs/en/latest/plugin_ref/spec.html">https://cordova.apache.org/docs/en/latest/plugin_ref/spec.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cordova </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Geb的京东抢券</title>
      <link href="/2018/08/05/grab_a_ticket_use_geb/"/>
      <url>/2018/08/05/grab_a_ticket_use_geb/</url>
      
        <content type="html"><![CDATA[<p>前面介绍过<a href="http://gebish.org/">Geb</a>是个好东西，可以用它实现web前端的自动化测试，自然用来解放双手，抢个券什么的不在话下。<br>这次我们主要瞄准京东。最佳的实验场所是京东的移动web版，即<a href="https://m.jd.com/">https://m.jd.com/</a>，大概分为以下几个步骤：</p><ol><li>打开京东首页</li><li>点击登录按钮</li><li>填写登录用户名密码并登录</li><li>调整到需要抢券的页面</li><li>找到抢券按钮开抢</li></ol><p>下面贴一个，618某活动的抢券代码（现在已经下线了），仅供参考。</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"> static def checkin(String username, String password) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FirefoxBinary firefoxBinary = <span class="keyword">new</span> <span class="constructor">FirefoxBinary()</span>;</span><br><span class="line"><span class="comment">//        firefoxBinary.addCommandLineOptions(&quot;--headless&quot;);</span></span><br><span class="line">        FirefoxOptions firefoxOptions = <span class="keyword">new</span> <span class="constructor">FirefoxOptions()</span>;</span><br><span class="line">        firefoxOptions.set<span class="constructor">Binary(<span class="params">firefoxBinary</span>)</span>;</span><br><span class="line"></span><br><span class="line">        def browser = <span class="keyword">new</span> <span class="constructor">Browser(<span class="params">driver</span>: <span class="params">new</span> FirefoxDriver(<span class="params">firefoxOptions</span>)</span>)</span><br><span class="line"></span><br><span class="line">        browser.<span class="keyword">with</span> &#123;</span><br><span class="line"></span><br><span class="line">            go <span class="string">&quot;https://m.jd.com&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="constructor">$(<span class="string">&quot;.jd-search-icon-login&quot;</span>)</span>.click<span class="literal">()</span></span><br><span class="line"></span><br><span class="line">            <span class="constructor">$(<span class="string">&quot;#username&quot;</span>)</span>.value(username)</span><br><span class="line">            <span class="constructor">$(<span class="string">&quot;#password&quot;</span>)</span>.value(password)</span><br><span class="line"></span><br><span class="line">            <span class="constructor">$(<span class="string">&quot;#loginBtn&quot;</span>)</span>.click<span class="literal">()</span></span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line">            go <span class="string">&quot;https://pro.m.jd.com/mall/active/qKRVTAJL7v93L71TkJebPv5GJnE/index.html&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="constructor">$(<span class="string">&quot;#m_1_14&quot;</span>)</span>.children<span class="literal">()</span>.each &#123;</span><br><span class="line">                it.click<span class="literal">()</span></span><br><span class="line">                sleep(<span class="number">500</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>补充几个说明：</p><ol><li>我用的是<code>Firefox</code>浏览器。所以需要电脑事先装好该浏览器。</li><li>只装浏览器还不够，还需要相应的<code>WebDriver</code>驱动。如果找不到程序会报错的，可以根据错误提示下载该驱动。然后要把本地驱动文件地址设置一下，方便<code>Geb</code>识别，代码如下<code> System.setProperty(&quot;webdriver.gecko.driver&quot;, &quot;/root/geckodriver&quot;)</code></li><li><strong>无节目的Linux服务器可不可用呢？答案是可以</strong>，在安装完上面两样东西之后，只需要代码里添加<code>firefoxBinary.addCommandLineOptions(&quot;--headless&quot;);</code>就可以启动无界面的<code>Firefox</code>了</li></ol><h4 id="友情提醒"><a href="#友情提醒" class="headerlink" title="友情提醒"></a>友情提醒</h4><p>工具抢券也好、代码抢券也好，都是一种对普通消费者不公平的存在。建议学会之后，自用练手即可，切勿以此牟利。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM下最好用的前端自动化测试工具Geb</title>
      <link href="/2018/08/04/Geb/"/>
      <url>/2018/08/04/Geb/</url>
      
        <content type="html"><![CDATA[<p>接触了<code>Angular</code>才知道前端有个端到端测试的说法，然后了解到有<code>WebDriver</code>这种神奇的存在，瞬间打开了新世纪的大门。后来几经寻觅，终于发现一个运行在<code>JVM</code>中的前端测试工具，那就是<a href="http://gebish.org/">Geb</a>。<br>来段代码：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> geb.Browser</span><br><span class="line"> </span><br><span class="line">Browser.drive &#123;</span><br><span class="line">    go &quot;http://myapp.com/login&quot;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">assert</span> $(&quot;h1&quot;).text() == &quot;Please Login&quot;</span><br><span class="line">     </span><br><span class="line">    $(&quot;form.login&quot;).<span class="keyword">with</span> &#123;</span><br><span class="line">        username = &quot;admin&quot;</span><br><span class="line">        <span class="keyword">password</span> = &quot;password&quot;</span><br><span class="line">        <span class="keyword">login</span>().click()</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">assert</span> $(&quot;h1&quot;).text() == &quot;Admin Section&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很易懂，一个有<code>Java</code>与<code>jQuery</code>基础的人应该非常容易上手。<br>还记得那个阿里员工抢月饼事件么，估计看了新闻之后，前端程序员都会觉得0门槛，但是后端程序员，可能就会觉得自己的技术栈鞭长莫及了。有了<code>Geb</code>，我们能做的事情会更多，也会更加方便。下一篇，我将介绍如何用<code>Geb</code>来实现京东抢券。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Geb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中的几中常见索引及应用场景</title>
      <link href="/2018/08/03/PostgreSQL_indexs/"/>
      <url>/2018/08/03/PostgreSQL_indexs/</url>
      
        <content type="html"><![CDATA[<h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h2><p><code>B-tree</code>是关系型数据库中，最常见的索引，也是<code>PostgreSQL</code>中经常采用的默认索引。主要应对场景：</p><ul><li>主键</li><li>唯一性约束</li><li>等值比较</li><li>范围查询</li><li>null判断</li></ul><h2 id="GiST"><a href="#GiST" class="headerlink" title="GiST"></a>GiST</h2><p>全称Generalized Search Tree，大白话就是通用搜索树。这是一种<strong>有损</strong>索引，主要应对非结构化数据，比如空间、全文检索什么的。主要应对场景：</p><ul><li>几何类型数据</li><li>范围类型数据</li><li>ltree类型数据</li><li>总之就是要用到不局限于<code>&lt;、&lt;=、=、 &gt;=、&gt;</code>这几种操作符时，要考虑<code>GiST</code>索引</li><li><code>GiST</code>跟<code>B-tree</code>并不矛盾，可以把<code>GiST</code>当作一种补充来用，效果更好</li></ul><h2 id="GIN"><a href="#GIN" class="headerlink" title="GIN"></a>GIN</h2><p>全称Generalized Inverted Index，通用逆序索引。它是从<code>GiST</code>派生出来的一种索引，比<code>GiST</code>最大的优势是无损，也就是说如果要查询的数据都被索引，就可以从索引中直接获取查询结果。<code>GIN</code>索引的缺点是更新操作时，多出一个字段值复制的动作，这点不及<code>GiST</code>的速度快。另外就是它不能对大对象类型索引，比如hstore、text里面有大对象，就不适合用<code>GIN</code>了。主要应对场景：</p><ul><li>jsonb数据类型</li><li>数组数据类型</li><li>配合<code>create extension pg_trgm</code>对<code>varchar</code>模糊查询</li></ul><h2 id="SP-GiST"><a href="#SP-GiST" class="headerlink" title="SP-GiST"></a>SP-GiST</h2><p>SP是Space-Partitioning的简写，也就是说本索引是基于空间分区树算法的GiST索引。与<code>GiST</code>的应用场领域高度重叠，好处就是针对某些领域的特定算法，其效率要高一些。目前支持该索引的类型主要有：</p><ul><li>point</li><li>box</li><li>text</li><li>range</li><li>network</li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>PostgreSQL已将<code>Hash</code>索引列为不推荐使用状态。只能实现<code>=</code>运算相关判断。</p><p>想了解更多索引的应用范围，完全可以在<code>PostgreSQL</code>的元数据中找到答案。尝试执行这个<code>SQL</code>吧</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> am.amname <span class="keyword">AS</span> index_method,</span><br><span class="line">       opf.opfname <span class="keyword">AS</span> opfamily_name,</span><br><span class="line">       amop.amopopr::<span class="type">regoperator</span> <span class="keyword">AS</span> opfamily_operator</span><br><span class="line"><span class="keyword">FROM</span> pg_am am, pg_opfamily opf, pg_amop amop</span><br><span class="line"><span class="keyword">WHERE</span> opf.opfmethod = am.oid <span class="keyword">AND</span></span><br><span class="line">      amop.amopfamily = opf.oid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> index_method, opfamily_name, opfamily_operator</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中varchar类型like前置%查询命中索引的方法</title>
      <link href="/2018/08/02/PostgreSQL_select_varchar_like_front_/"/>
      <url>/2018/08/02/PostgreSQL_select_varchar_like_front_/</url>
      
        <content type="html"><![CDATA[<p>上一篇中，我们学习了<code>PostgreSQL</code>中想要让<code>varchar</code>类型支持<code>like</code>查询能够命中索引，需要注意的地方。但是即便是创建索引时，指定了操作符类<code>varchar_pattern_ops</code>，在使用<code>like</code>查询的时候，还是只能保证<code>sometext%</code>这种查询能够命中索引，但是<code>%sometext</code>这种是无能为力的，见下图。<br><img src="/media/15331709094483.jpg"><br><img src="/media/15331709707728.jpg"><br>所以如果需要支持<code>%sometext</code>方式的索引查询，还需要再做点工作：</p><ol><li><code>create extension pg_trgm;</code></li><li><pre><code>CREATE INDEX log_action_v_uri_index  ON  log_action using gist (v_uri gist_trgm_ops); <figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 上面`gist`索引时有损的，后来研究支持，发现`gin`更合适，速度更快 **强烈推荐**</span><br></pre></td></tr></table></figure>CREATE INDEX table_name_md5_index  ON table_name using gin (md5 gin_trgm_ops);<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">然后重新执行<span class="code">`explain`</span>，就能看到命中索引了</span><br><span class="line">![](<span class="link">/media/15331719609935.jpg</span>)</span><br><span class="line"></span><br><span class="line">关于<span class="code">`btree`</span>索引与<span class="code">`gist`</span>索引的应用场景，我们以后再探讨。 现在我们先看看同样支持<span class="code">`sometext%`</span>查询命中索引的情况下，我们该用哪种呢。</span><br><span class="line"><span class="bullet">1.</span> 首先是查询速度，这次我们换百万行的数据来测试</span><br><span class="line"><span class="bullet">    *</span> 先看<span class="code">`btree`</span>的![](<span class="link">/media/15331926585276.jpg</span>)</span><br><span class="line"><span class="bullet">    *</span> 再看<span class="code">`gist`</span>的![](<span class="link">/media/15331926156740.jpg</span>)</span><br><span class="line"><span class="bullet">    *</span> 直观来看，采用<span class="code">`gist`</span>索引规划期给的时间是更快的。但是如果采用<span class="code">`explain analyse`</span>尝试获取真实结果的话，答案就恰恰相反了</span><br><span class="line"><span class="bullet">    *</span> 先看<span class="code">`btree`</span>![](<span class="link">/media/15331929892802.jpg</span>)</span><br><span class="line"><span class="bullet">    *</span> 再看<span class="code">`gist`</span>![](<span class="link">/media/15331930513697.jpg</span>)</span><br><span class="line"><span class="bullet">    *</span> 结果匪夷所思，在<span class="code">`gist`</span>索引的情况下，不论怎么测试，最终的<span class="code">`Execution time`</span>都保持在500ms以上。而<span class="code">`btree`</span>实际执行时间才1ms多。我尝试重启数据库，来保证数据没有缓存，但是<span class="code">`btree`</span>反馈的实际执行时间也不过就11ms多，之后又会下降了1ms量级。这其中的原因，是因为<span class="code">`gist`</span>是一种有损索引，所以不能像<span class="code">`btree`</span>索引那样，直接把值取出来。</span><br><span class="line"><span class="bullet">    *</span> <span class="strong">**结论：通常情况下btree的查询速度会远好于gist，但是如果gist索引列只参与条件判断，不参与select，gist的速度还是比较理想的**</span></span><br><span class="line"><span class="bullet">2.</span> 然是是创建索引的速度</span><br><span class="line"><span class="bullet">    *</span> 先看<span class="code">`btree`</span>![](<span class="link">/media/15331936107582.jpg</span>)</span><br><span class="line"><span class="bullet">    *</span> 再看<span class="code">`gist`</span>![](<span class="link">/media/15331936413004.jpg</span>)</span><br><span class="line"><span class="bullet">    *</span> <span class="strong">**结论：创建索引的速度，btree远好于gist**</span></span><br><span class="line"><span class="bullet">3.</span> 还有功能上<span class="strong">**gist索引不支持=查询，也就是如果除了模糊匹配，还需要精确匹配的话，必须引入btree索引**</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 总结</span></span><br><span class="line"><span class="bullet">*</span> <span class="code">`varchar`</span>类型，如果需要模糊查询，需要这么来</span><br></pre></td></tr></table></figure> CREATE INDEX table_name_md5_index_btree ON table_name (md5 text_pattern_ops); <figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">    但是此方案只支持`左锚定`</span><br><span class="line">* 如果需要不局限于`左锚定`的模糊查询，还需要这么来</span><br></pre></td></tr></table></figure> create extension pg_trgm; CREATE INDEX table_name_md5_index  ON table_name using gin (md5 gin_trgm_ops);</code></pre></li></ol><ul><li>如果还需要精确等值查询，请务必保留<code>btree</code>索引</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL中varchar类型支持like查询索引</title>
      <link href="/2018/08/01/PostgreSQL_select_varchar_like_index/"/>
      <url>/2018/08/01/PostgreSQL_select_varchar_like_index/</url>
      
        <content type="html"><![CDATA[<p>之前在使用<code>PostgreSQL</code>中的<code>varchar</code>类型时想当然的以为用最基本的索引创建语句创建的索引，就支持<code>like</code>查询的。<br>类似这句：</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> log_action_v_uri_index <span class="keyword">ON</span> log_action (v_uri);</span><br></pre></td></tr></table></figure><p>但是看过<code>explain</code>才知道，单凭这样的索引，在<code>like</code>搜索的时候，仍然是顺序全表扫描，如图：<br><img src="/media/15330845808519.jpg"><br>后来google了一下解决方案，原来是创建索引的时候追加一下参数，应该这么创建</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> log_action_v_uri_index <span class="keyword">ON</span> log_action (v_uri varchar_pattern_ops);</span><br></pre></td></tr></table></figure><p>然后对同样的语句再次<code>explain</code>结果如下：<br><img src="/media/15330848868005.jpg"><br>可以看到，已经命中索引了。<br>这其中涉及到一个重要的知识点，就是<code>PostgreSQL</code>的索引<em>操作符类</em> ，其标准语法为</p><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> name <span class="keyword">ON</span> <span class="keyword">table</span> (column opclass [sort <span class="keyword">options</span>] [, ...]);</span><br></pre></td></tr></table></figure><p>这个<code>opclass</code>可以针对不同的数据类型和查询方式提供多种多样的方案，<br><img src="/media/15330861199315.jpg"><br>可以看到光<code>btree</code>索引有关的操作符类就非常多，有些<code>is_default</code>是<code>true</code>也就是正好列类型吻合的话，这个操作符类就不要特意说明了。而<code>varchar</code>或者<code>text</code>的默认用的是<code>text_ops</code>，它支持的查询方式仅有<br><img src="/media/15330876281185.jpg"><br>所以想用模糊查询的话，还是得用<code>text_pattern_ops</code>或者<code>varchar_pattern_ops</code>(这哥俩是一个东西)，它支持正则模糊匹配，也支持<code>like %</code>的方式<br><img src="/media/15330878032471.jpg"></p><ul><li>更多信息，可以查看官方文档<a href="http://www.postgres.cn/docs/9.6/indexes-opclass.html">操作符类和操作符族</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA中的SQL Explain</title>
      <link href="/2018/07/31/IntelliJ-IDEA_SQL-Explain/"/>
      <url>/2018/07/31/IntelliJ-IDEA_SQL-Explain/</url>
      
        <content type="html"><![CDATA[<p>善于利用<code>SQL</code>的<code>explain</code>是<code>SQL</code>调整优化的必经之路。但是遇到复杂的<code>SQL</code>，查看<code>explain</code>结果也是有点困难的。比如这样的：<br><img src="/media/15329969004233.jpg"><br>好在很多数据库的客户端都提供了图形化的表现形式，比如<code>PostgreSQL</code>的<code>pgAdmin4</code>就能看到如下效果：<br><img src="/media/15329972711011.jpg"><br>不过如果有个工具，能够hold住所有主流的关系型数据库的话，就更嗨皮了。答案就是<code>IntelliJ IDEA</code>。如果你还没有尝试过其自带的<code>Database</code>功能的话，推荐现在就试一下。在屏幕右侧应该能找到。<br><img src="/media/15329976430336.jpg"><br>只需要按照向导添加相应的数据库连接就好了。不过这个功能免费的社区版是没有的。<br>创建完数据库链接后，通过此按钮打开<code>SQL Console</code>窗口<br><img src="/media/15329978378217.jpg"><br>然后在里面就可以愉快的编写<code>SQL</code>了。<br>先来一段：<br><img src="/media/15329983218004.jpg"><br>现在我们可以尝试通过<code>IntelliJ IDEA</code>执行一次<code>explain</code>了。</p><ul><li>先把光标移动到需要<code>explain</code>的<code>SQL</code>上</li><li>右键呼出菜单，找到<img src="/media/15329984643618.jpg">   执行之</li><li>就能看到效果了<img src="/media/15329985590089.jpg"></li><li>点击<code>Show Visualisation</code>可以呼出图形化展示<img src="/media/15329987110873.jpg"></li><li>如果觉得这个功能实用的话，可以给它设置一个快捷键，方法如下<ul><li>呼出<code>Find Action...</code>窗口（快捷键：⇧⌘A），在<code>Help</code>菜单下能找到</li><li>搜索到<code>explain</code><img src="/media/15329989448215.jpg"></li><li>按快捷键⌥↩︎，或者windows下的<code>alt+回车</code></li><li>就可以设置一个快捷键了<img src="/media/15329990816786.jpg"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启动Docker容器后要注意的时区问题</title>
      <link href="/2018/07/30/timezone_in_docker/"/>
      <url>/2018/07/30/timezone_in_docker/</url>
      
        <content type="html"><![CDATA[<p>对于中国用户来说，一般的docker容器启动后，如果执行<code>docker  exec -it xxxx date</code>会发现打印出来的时间，比当前北京时间早八个小时。所以需要调整容器的时区，主要有两个命令（要在容器内部执行）：</p><ul><li><code>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></li><li><code>echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</code></li></ul><p>其中第一个命令就能解决不少问题，比如我用<code>PostgreSQL</code>的话，<code>select now()</code>就可以通过第一条命令修正。但是<code>Tomcat</code>等java相关的程序，还需要第二条命令，才能获得正确的时间。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat中URL中文乱码问题</title>
      <link href="/2018/07/29/tomcat_url_chinese_garbled/"/>
      <url>/2018/07/29/tomcat_url_chinese_garbled/</url>
      
        <content type="html"><![CDATA[<p>找到</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;Connector connectionTimeout<span class="operator">=</span><span class="string">&quot;20000&quot;</span> port<span class="operator">=</span><span class="string">&quot;8080&quot;</span> protocol<span class="operator">=</span><span class="string">&quot;HTTP/1.1&quot;</span> redirectPort<span class="operator">=</span><span class="string">&quot;8443&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>追加配置为</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attribute">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attribute">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attribute">redirectPort</span>=<span class="string">&quot;8443&quot;</span> <span class="attribute">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乱码 </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被忽略的IntelliJ IDEA常用快捷键</title>
      <link href="/2018/07/28/IntelliJ-IDEA_hot_keys/"/>
      <url>/2018/07/28/IntelliJ-IDEA_hot_keys/</url>
      
        <content type="html"><![CDATA[<ul><li>跳转到方法声明处 （Go to declaration） ⌘B</li><li>快速查看声明（Open quick definition lookup）⇧⌘I</li><li>快速查看文档（Quick documentation lookup）^J</li><li>块级注释（Comment&#x2F;uncomment with block comment）^⇧&#x2F;</li><li>查找被调用处（Show usages）⌥⌘F7</li><li>在本文件高亮引用，可以用在return上（Highlight usages in file）⇧⌘F7</li><li>弹出重构窗口 ⌥⇧⌘T</li><li>补全代码（Complete statement）⇧⌘↩︎</li><li>查找功能（Find Action…）⇧⌘A，紧接着如果要给找到的功能设置快捷键，就继续⌥↩︎</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作macOS启动U盘命令</title>
      <link href="/2018/07/27/macos_bootable_usb/"/>
      <url>/2018/07/27/macos_bootable_usb/</url>
      
        <content type="html"><![CDATA[<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo <span class="regexp">/Applications/</span>Install\ macOS\ High\ Sierra.app<span class="regexp">/Contents/</span>Resources<span class="regexp">/createinstallmedia --volume /</span>Volumes<span class="regexp">/Sierra --applicationpath /</span>Applications/Install\ macOS\ High\ Sierra.app --nointeraction</span><br></pre></td></tr></table></figure><p>其中<code>/Volumes/Sierra</code>的<code>Sierra</code>是U盘的命名。如下图所示。<br><img src="/media/15326512660951.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写跨操作系统Java代码时动态获取文件分隔符</title>
      <link href="/2018/07/26/separator_in_java/"/>
      <url>/2018/07/26/separator_in_java/</url>
      
        <content type="html"><![CDATA[<h3 id="大概有以下几种思路"><a href="#大概有以下几种思路" class="headerlink" title="大概有以下几种思路"></a>大概有以下几种思路</h3><ol><li><code>File.separator</code>系统相关的默认名称分隔符，为方便起见，表示为字符串。 该字符串包含单个字符，即separatorChar。</li><li><code>FileSystems.getDefault().getSeparator()</code>返回名称分隔符，表示为字符串。<br>名称分隔符用于分隔路径字符串中的名称。 实现可能支持多个名称分隔符，在这种情况下，此方法返回特定于实现的默认名称分隔符。 通过调用toString（）方法创建路径字符串时使用此分隔符。<br>对于默认提供程序，此方法返回与java.io.File.separator相同的分隔符。</li><li><code>System.getProperty(&quot;file.separator&quot;)</code></li></ol><p>正常情况下，选择第一种，就ok了。第二种是在Java7时代追加的，功能更为强大。第三种也不错，因为额外提供通过<code>-Dfile.separator=</code>参数来指定的特性。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux免密登录不起作用解决办法</title>
      <link href="/2018/07/25/linux_ssh_key/"/>
      <url>/2018/07/25/linux_ssh_key/</url>
      
        <content type="html"><![CDATA[<p>已经把公钥添加到<code>~/.ssh/authorized_keys</code>文件之后，有时候依然无法实现免密码登录。后来才发现，是因为有些文件的权限放大了。想想也是，如果<code>authorized_keys</code>文件，是其他用户也能编辑的。那岂不是多了个后门，可以帮助其他用户绕到当前用户了。<br>所以重点在于几个关键文件是否把权限集中在自己手上，并且无论如何是不允许其他用户编辑的。<br>总结为以下几条命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>有时候，光有上面两句还搞不定，我发现还得追加一句</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">chmod</span> <span class="number">755</span> ~</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小诗一首</title>
      <link href="/2018/07/24/xuzhou_xiari/"/>
      <url>/2018/07/24/xuzhou_xiari/</url>
      
        <content type="html"><![CDATA[<p><img src="/media/DSC04458.jpg"></p><h3 id="都谓彭城多霾日，"><a href="#都谓彭城多霾日，" class="headerlink" title="都谓彭城多霾日，"></a>都谓彭城多霾日，</h3><h3 id="落笔春城溅靛青。"><a href="#落笔春城溅靛青。" class="headerlink" title="落笔春城溅靛青。"></a>落笔春城溅靛青。</h3><h3 id="天公莫要惜颜色，"><a href="#天公莫要惜颜色，" class="headerlink" title="天公莫要惜颜色，"></a>天公莫要惜颜色，</h3><h3 id="几许蔚蓝伴我行。"><a href="#几许蔚蓝伴我行。" class="headerlink" title="几许蔚蓝伴我行。"></a>几许蔚蓝伴我行。</h3><h4 id="——戊戌年六月偶瞥于徐州"><a href="#——戊戌年六月偶瞥于徐州" class="headerlink" title="——戊戌年六月偶瞥于徐州"></a>——戊戌年六月偶瞥于徐州</h4>]]></content>
      
      
      <categories>
          
          <category> 文艺中年 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA在Winodws下Gradle乱码问题</title>
      <link href="/2018/07/23/IntelliJ-IDEA_Winodws_Gradle_garbled/"/>
      <url>/2018/07/23/IntelliJ-IDEA_Winodws_Gradle_garbled/</url>
      
        <content type="html"><![CDATA[<p>恐怕没有哪个中国程序员没被字符编码的问题坑过吧。本以为把能设置字符集的地方，都设置成<code>UTF-8</code>就不会踩坑。可是现实是残酷的。<br>比如在中文windows系统环境下，如果使用IntelliJ IDEA开发工具，同时跑gradle项目，那就要小心了。<br>需要在<br><code>File | Settings | Build, Execution, Deployment | Gradle</code><br>下，找到<code>Gradle VM options</code>，然后填入配置<code>-Dfile.encoding=UTF-8</code></p><p>还有一种方法，可以通过修改gradle.bat这个文件来实现，改文件通常存放于，<code>GRADLE_HOME</code>下的<code>bin</code>目录，找到<code>set DEFAULT_JVM_OPTS=</code>修改为<br><code>set DEFAULT_JVM_OPTS=&quot;-Dfile.encoding=UTF-8&quot;</code><br>即可。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
            <tag> 乱码 </tag>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL里一条SQL统计合计与小计</title>
      <link href="/2018/07/22/postgres_select_total_subtotal_one_sql/"/>
      <url>/2018/07/22/postgres_select_total_subtotal_one_sql/</url>
      
        <content type="html"><![CDATA[<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">CASE</span> <span class="keyword">WHEN</span> GROUPING(student) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">THEN</span> <span class="string">&#x27;合计&#x27;</span></span><br><span class="line">  <span class="keyword">ELSE</span> student <span class="keyword">END</span>,</span><br><span class="line">  <span class="keyword">CASE</span> <span class="keyword">WHEN</span>  GROUPING(student) &lt;&gt; <span class="number">1</span> <span class="keyword">and</span> GROUPING(course) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">THEN</span> <span class="string">&#x27;小计&#x27;</span></span><br><span class="line">  <span class="keyword">ELSE</span> course <span class="keyword">END</span>,</span><br><span class="line">  sum(score.score)</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (student, course)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> GROUPING(student) <span class="keyword">DESC</span> ,student <span class="keyword">DESC</span>, GROUPING(course) <span class="keyword">DESC</span> ,course <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vert.x异步方法转同步</title>
      <link href="/2018/07/21/vertx_async_to_sync/"/>
      <url>/2018/07/21/vertx_async_to_sync/</url>
      
        <content type="html"><![CDATA[<p>以前用Vert.x的时候就有这样的疑问，如果我提供的方法是基于Vert.x异步实现的。如何被一个同步的应用调用呢，比如Spring。当时我一度以为要自己开一个线程，然后不断轮询结果，之后再返回，通过这样，把一个异步的方法，包装成同步的方法。<br>后来在使用<code>vertx-pac4j</code>的时候，无意中看到它源码中，也有我上面说的场景使用。就在<code>org.pac4j.vertx.context.session.VertxSessionStore</code>类的这一段：</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   <span class="keyword">public</span> Session getSession(<span class="keyword">String</span> sessionId) &#123;</span><br><span class="line">       final CompletableFuture&lt;io.vertx.ext.web.Session&gt; vertxSessionFuture = <span class="keyword">new</span> <span class="type">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">       sessionStore.<span class="keyword">get</span>(sessionId, asyncResult -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (asyncResult.succeeded()) &#123;</span><br><span class="line">               vertxSessionFuture.complete(asyncResult.result());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               vertxSessionFuture.completeExceptionally(asyncResult.cause());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       final CompletableFuture&lt;Session&gt; pac4jSessionFuture = vertxSessionFuture.thenApply(session -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">VertxSession</span>(session);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> pac4jSessionFuture.<span class="keyword">get</span>();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException|ExecutionException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">TechnicalException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以明显看到<code>sessionStore.get</code>是的常规的Vert.x异步调用。<br>基于这种应用方式，我尝试用<code>groovy</code>模仿写了一下，效果显著，代码如下：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import io<span class="selector-class">.vertx</span><span class="selector-class">.core</span><span class="selector-class">.Vertx</span></span><br><span class="line"></span><br><span class="line">import java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CompletableFuture</span></span><br><span class="line"></span><br><span class="line">String <span class="built_in">sayHello</span>() &#123;</span><br><span class="line">    CompletableFuture completableFuture = new <span class="built_in">CompletableFuture</span>()</span><br><span class="line"></span><br><span class="line">    Vertx vertx = Vertx<span class="selector-class">.vertx</span>()</span><br><span class="line">    vertx<span class="selector-class">.setTimer</span>(<span class="number">3000</span>, &#123;</span><br><span class="line">        completableFuture<span class="selector-class">.complete</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return completableFuture<span class="selector-class">.get</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">println</span><span class="params">(sayHello()</span></span>)</span><br></pre></td></tr></table></figure><p>上面这种写法，主要还是依赖了java1.8的<code>CompletableFuture</code>类，后续我会单独开文章讲解这个类的使用。今天就先到这里吧。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在cas登录成功页面显示用户名</title>
      <link href="/2018/07/20/cas_show_username_in_login_success_page/"/>
      <url>/2018/07/20/cas_show_username_in_login_success_page/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.apereo.org/projects/cas">CAS</a>这种本来业务场景就很细分，再加上其上古时代存续至今的特质。估计还在用它的公司已经不多了。间接导致，其中文资料比较匮乏。<br>领导说，想再cas成功后的欢迎页，也就是<code>casGenericSuccess.jsp</code>页面，可以显示<code>欢迎:xxx</code>的字样。<br>不得不说，这个需求非常常规。然而不仅cas默认没有实现，甚至翻遍google，都很难找到满意的答案。比较有参考价值的可能就是<a href="https://groups.google.com/forum/#!topic/jasig-cas-user/q_pjYXCe7ko">google groups</a>上的这篇。居然要借助额外的jar包(还是个已停止维护的)才能实现。不得已，只能自己想办法。<br>现在给出我的思路：</p><ol><li>在<code>deployerConfigContext.xml</code>文件中，找到<code>authenticationHandlers</code>参数，其应该对应一个类。十有八九，那个类是你自己实现的，如果不是，可以自己继承一下原有参数配置的类。</li><li>然后在那个类里的<code>authenticate</code>方法，可以通过追加<code>HttpSession session = RequestContextHolder.getRequestAttributes().getSessionMutex().session as HttpSession</code>这么一行，获取到<code>session</code>，这就嗨皮了。</li><li>可以在<code>authenticate</code>方法需要返回<code>true</code>的时候，之前增加一行<code>session.setAttribute(&quot;username&quot;,balabala);</code>，这样我们就顺利把username塞到<code>session</code>里的</li><li>最后，修改<code>casGenericSuccess.jsp</code>，在需要显示用户名的地方，加入<code>&lt;%=session.getAttribute(&quot;username&quot;)%&gt;</code>，就可以实现在登录成功页面显示用户名了</li><li>如果想显示更复杂数据内容，可以留意下<code>deployerConfigContext.xml</code>里面的<code>credentialsToPrincipalResolvers</code>所对应的类。它的时间节点是判定用户登录成功之后，组织用户信息用的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS系统使用Shadowsocks搭建代理服务</title>
      <link href="/2018/07/19/CentOS_Shadowsocks/"/>
      <url>/2018/07/19/CentOS_Shadowsocks/</url>
      
        <content type="html"><![CDATA[<ol><li>确认pip是否安装，命令<code>pip help</code>，返回如图信息，说明已安装<br><img src="/media/15319616591142.jpg"><br>如果返回下图，说明未安装<br><img src="/media/15319617008516.jpg"><br>未安装需要执行以下子步骤：<ul><li><code>yum -y install epel-release</code></li><li><code>yum update</code></li><li><code>yum install python-pip</code></li></ul></li><li>通过pip安装shadowsocks，命令<code>pip install shadowsocks</code></li><li>准备shadowsocks的配置文件，找个地方放就行，比如<code>/root/shadowsocks.json</code>，文件内容如下：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span> <span class="number">1988</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;local_address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;local_port&quot;</span><span class="punctuation">:</span> <span class="number">1080</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xyz&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="number">300</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aes-256-cfb&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;fast_open&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;workers&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure> 其中<code>server_port</code>、<code>passoword</code>、<code>method</code>三个参数比较重要，分别对应:代理服务所在端口、链接密码、加密方式，回头要用到。</li><li>准备好配置文件之后，就可以启动shadowsocks服务了，命令为<code>ssserver -c /root/shadowsocks.json -d start</code>，至此shadowsocks服务启动完毕，然后就可以用客户端连接了。</li><li>客户端下载地址在都在github上，这里给出最常用的mac版和windows版<ul><li><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases">mac</a></li><li><a href="https://github.com/shadowsocks/shadowsocks-windows/releases">windows</a></li></ul></li><li>客户端安装完毕，就可以配置服务器连接了，这里给个参考配置：<br> <img src="/media/15319627604059.jpg"><br>地址就是服务器所在的地址，备注随意，剩下的三个配置，正好对应上面提过的配置。</li><li>确定shadowsocks client是启动状态，就可以享受不一样的网络了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Gradle自动发布程序至Linux服务器</title>
      <link href="/2018/07/18/gradle_task_use_ssh/"/>
      <url>/2018/07/18/gradle_task_use_ssh/</url>
      
        <content type="html"><![CDATA[<p>你的重复劳动，一定能找“人”帮你做，聪明的程序员一定是拒绝重复的。由于公司条件限制，暂时用不上<code>jenkins</code>，先拿<code>gradle</code>救救急也是不错的。今天要实现的是，通过gradle发布静态站点到服务器。这样可以和上回的<a href="http://www.kankanzhijian.com/2018/07/17/gradle_build_vue/">用Gradle打包Vue前端程序</a>保持一定的连贯性。当然本帖拿来发布<code>war</code>包也是ok的。</p><ul><li>首先追加gradle插件，参考写法</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    <span class="built_in">id</span> <span class="string">&#x27;org.hidetake.ssh&#x27;</span> version <span class="string">&#x27;2.9.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">  <span class="keyword">repositories</span> &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">&#x27;org.hidetake:gradle-ssh-plugin:2.9.0&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply plugin: <span class="string">&#x27;org.hidetake.ssh&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>配置插件</li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">remotes &#123;</span><br><span class="line">    webServer &#123;</span><br><span class="line">        host = <span class="string">&#x27;192.168.1.100&#x27;</span></span><br><span class="line">        <span class="keyword">user</span> = <span class="string">&#x27;develop&#x27;</span></span><br><span class="line">        port = <span class="number">22</span></span><br><span class="line">        <span class="keyword">password</span> = <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得密码服务器密码明文写在这里不安全，可以用公钥ssh的方案，那么这里可以用<code>identity = file(&#39;id_rsa&#39;)</code>代替掉<code>password = &#39;xyz&#39;</code></p><ul><li>配置完Gradle SSH Plugin，就可以自己写<code>task</code>实现上传文件了。下面贴段我的</li></ul><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> deployPortal &#123;</span><br><span class="line">    <span class="keyword">group</span> = <span class="string">&#x27;release&#x27;</span></span><br><span class="line">    dependsOn zipPortal</span><br><span class="line">    <span class="keyword">doLast</span> &#123;</span><br><span class="line">        ssh.run &#123;</span><br><span class="line">            session(remotes.webServer) &#123;</span><br><span class="line">                put <span class="keyword">from</span>: <span class="string">&quot;$buildDir/portal.zip&quot;</span>, <span class="keyword">into</span>: <span class="string">&quot;/home/develop/&quot;</span></span><br><span class="line">                <span class="keyword">def</span> result = execute <span class="string">&#x27;unzip -o  /home/develop/portal.zip -d /home/develop/portal/&#x27;</span></span><br><span class="line">                <span class="keyword">println</span>(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个task的主要作用就是把压缩好的静态站点上传至服务器，然后再解压缩。重点就两句话，第一句<code>put from: &quot;本地文件&quot;, into: &quot;服务器路径&quot;</code>，实现文件上传功能。第二句<code>execute &#39;执行shell命令&#39;</code>，实现通过shell命令，解压缩文件。</p><ul><li>至于中间那句<code>dependsOn zipPortal</code>表示执行发布task之前，先要把文件准备好，这个<code>zipPortal</code>task我是这么写的  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">task <span class="title function_">zipPortal</span>(<span class="params"><span class="keyword">type</span>: Zip</span>) &#123;</span><br><span class="line">    <span class="title function_">dependsOn</span>(<span class="string">&#x27;:portal:build&#x27;</span>)</span><br><span class="line">    <span class="keyword">from</span> <span class="string">&#x27;portal/www&#x27;</span></span><br><span class="line">    archiveName <span class="string">&#x27;portal.zip&#x27;</span></span><br><span class="line">    destinationDir buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>换句话说，如果你是要上传<code>war</code>包的话，可能就不是<code>dependsOn zipPortal</code>而是<code>dependsOn war</code>了。其他的地方，大同小异。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Gradle打包Vue前端程序</title>
      <link href="/2018/07/17/gradle_build_vue/"/>
      <url>/2018/07/17/gradle_build_vue/</url>
      
        <content type="html"><![CDATA[<p>我这边打包和发布程序，属于重度依赖Gradle的状态。所以纵容前端程序游离在这个体系外，不利于团队的整体协作。于是有了这篇文章。<br>其实很简单，首先我们需要一个以Gradle为基石的项目，把前后端项目组织成这样</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">myproject</span><br><span class="line">├── <span class="keyword">build.gradle</span></span><br><span class="line"><span class="keyword"></span>├── frontend</span><br><span class="line">│   ├── <span class="keyword">build</span></span><br><span class="line"><span class="keyword"></span>│   ├── index.html</span><br><span class="line">│   ├── node_modules</span><br><span class="line">│   ├── package.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span>│   └── src</span><br><span class="line">├── <span class="keyword">javaweb</span></span><br><span class="line"><span class="keyword"></span>│   ├── <span class="keyword">build</span></span><br><span class="line"><span class="keyword"></span>│   ├── <span class="keyword">build.gradle</span></span><br><span class="line"><span class="keyword"></span>│   ├── out</span><br><span class="line">│   └── src</span><br><span class="line">└── settings.gradle</span><br></pre></td></tr></table></figure><p>其中<code>frontend</code>文件夹就是<code>vue</code>项目的存放路径，我们先在此文件夹中，追加文件<code>build.gradle</code>，放至在package.json隔壁。填上很简单的内容：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  <span class="built_in">id</span> <span class="string">&quot;com.palantir.npm-run&quot;</span> <span class="built_in">version</span> <span class="string">&quot;0.5.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代表这个项目要用到gradle-npm-run的插件<br>然后修改settings.gradle，追加一行<br><code>include &#39;frontend&#39;</code>，这样gradle就能顺利识别vue前端项目了，并且依靠插件，我们获得了这几个task<br><img src="/media/15317809896046.jpg" alt="-w148"><br>其中<code>build</code>就可以实现通过<code>gradle frontend:build</code>的命令，实现gradle对vue项目的打包了。<br>明天，我将继续讲解，如何用gardle实现像Linux服务器，敬请期待。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> gradle </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux挂载新磁盘（适用阿里云、华为云）</title>
      <link href="/2018/07/16/linux_mount/"/>
      <url>/2018/07/16/linux_mount/</url>
      
        <content type="html"><![CDATA[<p>公司项目用的是华为的云服务器，刚申请了新的硬盘资源，需要手动分区挂载。虽然华为没给啥资料，但是不是还有阿里云嘛。所以结合阿里云的资料。我们就可以在华为云实操一把了。附里云资料地址<a href="https://help.aliyun.com/document_detail/25426.html?spm=a2c4g.11186623.2.4.nTZpwz">Linux 格式化和挂载数据盘</a></p><ol><li><code>fdisk -l</code>查看服务器是否识别到新硬盘的接入，一般会在最后，返回<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">磁盘 <span class="regexp">/dev/</span>xvde：<span class="number">536.9</span> GB, <span class="number">536870912000</span> 字节，<span class="number">1048576000</span> 个扇区</span><br><span class="line">Units = 扇区 of <span class="number">1</span> * <span class="number">512</span> = <span class="number">512</span> bytes</span><br><span class="line">扇区大小(逻辑<span class="regexp">/物理)：512 字节 /</span> <span class="number">512</span> 字节</span><br><span class="line">I<span class="regexp">/O 大小(最小/</span>最佳)：<span class="number">512</span> 字节 / <span class="number">512</span> 字节</span><br></pre></td></tr></table></figure>说明识别到一个500多G的硬盘，记录下这个硬盘设备号<code>/dev/xvde</code>(这是个变量，你那里不一定跟我一样)</li><li><code>fdisk /dev/xvde</code>对上面的新硬盘进行分区操作，这是一个交互式命令，首先输入<code>n</code>，也就是创建新分区的意思，如果就打算分一个区的话，后续就按根据提示输入一路回车，到如下界面：<img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-16%2009.20.59.png" alt="屏幕快照 2018-07-16 09.20.59"><br>此时输入<code>wq</code>将分区表写入磁盘，并退出。会收到提示：<br><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-16%2009.22.56.png" alt="屏幕快照 2018-07-16 09.22.56"></li><li><code>fdisk -l</code>再次执行此命令，可以看到新分区信息（一般在最后）<br><img src="/media/15317042937460.jpg"></li><li><code>mkfs.ext4 /dev/xvde1</code>将这个分区格式化成ext4文件系统。如图：<br><img src="/media/15317044049926.jpg"></li><li><code>mount /dev/xvde1 /mnt</code>挂载分区</li><li><code>df -h</code>可以查看到新挂载的分区，此时分区已经可以使用了。但是还没有开机自动挂载，如果要开机自动挂载，还需做第7步</li><li>保险起见，先备份<code>fstab</code>，执行命令<code>cp /etc/fstab /etc/fstab.bak</code>，然后执行<code>echo /dev/xvde1 /mnt ext4 defaults 0 0 &gt;&gt; /etc/fstab</code>。之后即使重启，分区也会自动挂载喽。可以通过<code>df -h</code>看到效果：<br><img src="/media/15317048391668.jpg"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用JMH做简单的JVM性能测试</title>
      <link href="/2018/07/14/jmh/"/>
      <url>/2018/07/14/jmh/</url>
      
        <content type="html"><![CDATA[<p>写java也有年头了，有时候遇到对比某几种方法性能的情景，都是自己傻傻的打印<code>new Date()</code>计算时间差。现在想来，这种原始的方式，就跟不会用IDE Debug，只会<code>System.out.println()</code>打印调试没什么区别。<br>这次被人安利<code>JMH</code>，说来惭愧，是我在Twitter上质疑<code>Vert.x</code>采用了效率不高的Json序列化库，影响了其在<a href="https://www.techempower.com/benchmarks/">techempower</a>的成绩。结果<a href="https://twitter.com/julienviet">@julienviet</a>神回复我说”you should make a JMH microbenchmark to find out”，所以才有了这篇，利用JMH做Json序列化速度对比的文章。<br>这是测试结果：<br><img src="/media/15315228604634.jpg" alt="-w783"><br>可以看到<code>Vert.x</code>的Json序列化速度还是出类拔萃的，当然，其本质还是实用的<code>jackson</code><br>上代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aruistar.benchmark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aruistar.benchmark.model.User;</span><br><span class="line"><span class="keyword">import</span> com.jsoniter.output.JsonStream;</span><br><span class="line"><span class="keyword">import</span> groovy.json.JsonBuilder;</span><br><span class="line"><span class="keyword">import</span> groovy.json.JsonOutput;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.Benchmark;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonToStringBenchmark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line">                .include(JsonToStringBenchmark.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .warmupIterations(<span class="number">2</span>)</span><br><span class="line">                .measurementIterations(<span class="number">3</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    @Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJsonObjectToBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;tomcat&quot;</span>, <span class="number">10</span>, <span class="string">&quot;angular&quot;</span>, <span class="literal">true</span>).toBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJsonObjectToString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;tomcat&quot;</span>, <span class="number">10</span>, <span class="string">&quot;angular&quot;</span>, <span class="literal">true</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJsonBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">JsonBuilder</span>(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;tomcat&quot;</span>, <span class="number">10</span>, <span class="string">&quot;angular&quot;</span>, <span class="literal">true</span>).getMap()).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJsonOutput</span><span class="params">()</span> &#123;</span><br><span class="line">        JsonOutput.toJson(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;tomcat&quot;</span>, <span class="number">10</span>, <span class="string">&quot;angular&quot;</span>, <span class="literal">true</span>).getMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJsoniter</span><span class="params">()</span> &#123;</span><br><span class="line">        JsonStream.serialize(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;tomcat&quot;</span>, <span class="number">10</span>, <span class="string">&quot;angular&quot;</span>, <span class="literal">true</span>).getMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aruistar.benchmark.model;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">JsonObject</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String username, <span class="type">int</span> age, String title, <span class="type">boolean</span> bool)</span> &#123;</span><br><span class="line">        put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        put(<span class="string">&quot;age&quot;</span>, age);</span><br><span class="line">        put(<span class="string">&quot;title&quot;</span>, title);</span><br><span class="line">        put(<span class="string">&quot;bool&quot;</span>, bool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源码地址，<a href="https://github.com/aruis/somebenchmark">https://github.com/aruis/somebenchmark</a></p><p>需要注意的是，如果在IDEA打开，想直接通过main方法启动，需要执行如下步骤</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">Do you have org.openjdk.jmh:jmh-generator-annprocess on your classpath?</span><br><span class="line">If yes, <span class="keyword">is</span> annotation processing enabled <span class="built_in">in</span> your IDE? You can find the checkbox under</span><br><span class="line">P<span class="function"><span class="title">references</span> -&gt;</span> B<span class="function"><span class="title">uild</span>, Execution, Deployment -&gt;</span> C<span class="function"><span class="title">ompiler</span> -&gt;</span> Annotation Processors</span><br></pre></td></tr></table></figure><ul><li>参考[<a href="https://github.com/artyushov/idea-jmh-plugin/issues/13]">https://github.com/artyushov/idea-jmh-plugin/issues/13]</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL数组类型数据一条sql实现翻译</title>
      <link href="/2018/07/13/postgresql_select_array/"/>
      <url>/2018/07/13/postgresql_select_array/</url>
      
        <content type="html"><![CDATA[<p>PostgreSQL的ARRAY类型是个非常实用的类型。以往在设计“多选”这种业务场景的时候，要么需要设计子表，要么弄个varchar字段，存放<code>1,3,5</code>这种逗号隔开的数据。现在有了原生支持的ARRAY类型，终于可以大胆的把多选的数据id放在这个字段里了。<br>接踵而至的问题是，如何一次性实现数组字段的数据翻译呢。比如实际数据是<code>&#123;1,3,5&#125;</code>，关联查询后，希望看到<code>&#123;红,黄,蓝&#125;</code><br>话不多说，直接上sql</p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> app_message.id,app_message.ids_at_auth_user__to,</span><br><span class="line">  <span class="built_in">array_agg</span>(auth_user.v_username) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> app_message.id) <span class="keyword">as</span> av_username_at_auth_user</span><br><span class="line"><span class="keyword">from</span> app_message</span><br><span class="line">  <span class="keyword">join</span> auth_user <span class="keyword">on</span> auth_user.id = <span class="keyword">ANY</span> (ids_at_auth_user__to)</span><br></pre></td></tr></table></figure><p><code>app_message</code>是个收发消息表，里面<code>ids_at_auth_user__to</code>字段是个ARRAY，存储了<code>auth_user</code>表的若干个id，代表收件箱的人（多人）<br><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-27%2011.41.45.png" alt="屏幕快照 2018-04-27 11.41.45"></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
