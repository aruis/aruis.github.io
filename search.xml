<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>性能封神的数据库访问库reactive-pg-client初探</title>
      <link href="/2018/09/14/reactive-pg-client_start/"/>
      <url>/2018/09/14/reactive-pg-client_start/</url>
      <content type="html"><![CDATA[<p>不知道有没有人关注过TechEmpower的<code>Web Framework Benchmarks</code>（<a href="https://www.techempower.com/benchmarks/" target="_blank" rel="noopener">https://www.techempower.com/benchmarks/</a> ），一种把各种<code>Web</code>后端开发技术都罗列起来，在同样的机器下跑最简单的业务逻辑，来对比各技术性能的竞赛。参与跑分的技术代码，都是开源的，甚至很多代码就是由<code>Web</code>技术本身的作者维护的。<br>虽说，跑分不能代表性能，性能更不能代表技术的优劣。但是有着么一个性能维度的粗浅比较，还是能带给我们不一样的收获。<br>比如，在<code>2018-06-06</code>的最新一场比拼中，<code>Vert.x</code>搭配<code>PostgreSQL</code>的组合，在部分比试时表现十分抢眼，性能一骑绝尘且大幅领先第二名。被它踩在脚下摩擦的对手，不乏我们熟知的技术方案，比如<code>go</code>、<code>nodejs</code>、<code>spring</code>、<code>php</code>，还有<code>mysql</code>、<code>mongodb</code>等数据库。（这里我无意引战，有兴趣的朋友可以查看具体<a href="https://www.techempower.com/benchmarks/#section=data-r16&amp;hw=ph&amp;test=db" target="_blank" rel="noopener">跑分结果</a>及<a href="https://github.com/TechEmpower/FrameworkBenchmarks/tree/round16" target="_blank" rel="noopener">相关代码</a>）<br>查看具体跑分<a href="https://github.com/TechEmpower/FrameworkBenchmarks/blob/724a773096f403d149cfaf59b8257465bbf70103/frameworks/Java/vertx/src/main/java/vertx/App.java" target="_blank" rel="noopener">代码</a>可知，<code>Vert.x</code>之所以能位居榜首，与其使用的数据库客户端是密不可分的。作为一套基于<code>Java</code>的技术解决方案，<code>Vert.x</code>没有使用<code>Java</code>程序员所熟知的<code>JDBC</code>，而是使用了一种叫<a href="https://github.com/reactiverse/reactive-pg-client" target="_blank" rel="noopener">reactive-pg-client</a>的技术。<br><code>reactive-pg-client</code>与<code>JDBC</code>最大的区别就是前者是针对<code>PostgreSQL</code>数据库单独开发的，利用了<code>PostgreSQL</code>异步特性，最大限度了挖掘了数据库的访问性能。<br>现在我们就来简单尝试下<code>reactive-pg-client</code>，首先添加依赖<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'io.reactiverse:reactive-pg-client:0.10.3'</span></span><br></pre></td></tr></table></figure></p><p>准备<code>PgPoolOptions</code><br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">PgPoolOptions options = new PgPoolOptions()</span><br><span class="line">  .<span class="built_in">set</span>Port(<span class="number">5432</span>)</span><br><span class="line">  .<span class="built_in">set</span>Host(<span class="string">"the-host"</span>)</span><br><span class="line">  .<span class="built_in">set</span>Database(<span class="string">"the-db"</span>)</span><br><span class="line">  .<span class="built_in">set</span>User(<span class="string">"user"</span>)</span><br><span class="line">  .<span class="built_in">set</span>Password(<span class="string">"secret"</span>)</span><br><span class="line">  .<span class="built_in">set</span>MaxSize(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p>接下来就可以用了<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the client pool</span></span><br><span class="line">PgPool client = PgClient.pool(options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A simple query</span></span><br><span class="line">client.query(<span class="string">"SELECT * FROM users WHERE id='julien'"</span>, ar -&gt; &#123;</span><br><span class="line">  <span class="built_in">if</span> (ar.succeeded()) &#123;</span><br><span class="line">    PgRowSet result = ar.result();</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Got "</span> + result.<span class="built_in">size</span>() + <span class="string">" rows "</span>);</span><br><span class="line">  &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Failure: "</span> + ar.cause().getMessage());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now close the pool</span></span><br><span class="line">  client.<span class="built_in">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>典型的异步代码编写风格，正是由于该库先天异步的特性，我们可以用一个线程，就能控制多个数据库链接（The client is reactive and non blocking, allowing to handle many database connections with a single thread.），籍此获得更好的计算机资源利用率，从而提高性能。更多信息请查看官方文档<a href="https://reactiverse.io/reactive-pg-client/guide/java/" target="_blank" rel="noopener">reactive-pg-client</a></p><p>明天，我将继续深入<code>reactive-pg-client</code>，带你尝试<code>PostgreSQL</code>独有的<code>NOTIFY</code>特性，实现从数据库端到业务程序段的数据主动推送。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>给异步的Vert.x程序做单元测试</title>
      <link href="/2018/09/13/vertx_unit_test/"/>
      <url>/2018/09/13/vertx_unit_test/</url>
      <content type="html"><![CDATA[<p>异步的程序先天不好单元测试，尤其是按照传统的<code>JUnit</code>思路来弄，肯定是不行的。好在<code>Vert.x</code>想到了这一点，所以提供了<code>vertx-unit</code>包，专门考虑了对异步代码的测试。<br>使用起来也很简单，首先<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">testCompile</span> "<span class="selector-tag">io</span><span class="selector-class">.vertx</span><span class="selector-pseudo">:vertx-unit</span><span class="selector-pseudo">:3.5.3"</span></span><br></pre></td></tr></table></figure></p><p>然后创建一个测试类<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(VertxUnitRunner.<span class="keyword">class</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnitTestSuite</span> &#123;</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> testSomething(TestContext context) &#123;</span><br><span class="line">    context.assertFalse(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要是测试异步程序，只需要调用<code>TestContext</code>的<code>async()</code>方法即可。然后直到手动调用其<code>complete()</code>方法，整个测试过程才会结束。请看例子：<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSomething</span>(<span class="params">TestContext context</span>) </span>&#123;</span><br><span class="line">    def <span class="keyword">async</span> = context.<span class="keyword">async</span>()</span><br><span class="line">    Vertx.vertx().setTimer(<span class="number">3000</span>, &#123;</span><br><span class="line">        context.assertFalse(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">async</span>.complete()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>async</code>方法的注释写得还是很详细的<br><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">and</span> returns a <span class="keyword">new</span> <span class="keyword">async</span> object, the returned <span class="keyword">async</span> controls the completion <span class="keyword">of</span> the test. Calling the <span class="keyword">Async</span>.complete() completes the <span class="keyword">async</span> operation.</span><br><span class="line"></span><br><span class="line">The test <span class="keyword">case</span> will complete when all the <span class="keyword">async</span> objects have their <span class="keyword">Async</span>.complete() <span class="function"><span class="keyword">method</span> <span class="title">called</span> <span class="title">at</span> <span class="title">least</span> <span class="title">once</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">This</span> <span class="title">method</span> <span class="title">shall</span> <span class="title">be</span> <span class="title">used</span> <span class="title">for</span> <span class="title">creating</span> <span class="title">asynchronous</span> <span class="title">exit</span> <span class="title">points</span> <span class="title">for</span> <span class="title">the</span> <span class="title">executed</span> <span class="title">test</span>.</span></span><br></pre></td></tr></table></figure></p><p>更多内容请参考官方文档：<a href="https://vertx.io/docs/vertx-unit/java/" target="_blank" rel="noopener">vertx-unit</a></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>再谈CompletableFuture</title>
      <link href="/2018/09/12/CompletableFuture_something/"/>
      <url>/2018/09/12/CompletableFuture_something/</url>
      <content type="html"><![CDATA[<p>今天是还之前欠的一个账，当时在<a href="https://www.kankanzhijian.com/2018/07/21/vertx_async_to_sync/">Vert.x异步方法转同步</a>这篇文章里，我提到其关键点是<code>CompletableFuture</code>类，今天我们就沿着当时的代码继续掰扯一下这个强大的类。<br>先来回顾下当时的代码<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import io<span class="selector-class">.vertx</span><span class="selector-class">.core</span><span class="selector-class">.Vertx</span></span><br><span class="line"></span><br><span class="line">import java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CompletableFuture</span></span><br><span class="line"></span><br><span class="line">String sayHello() &#123;</span><br><span class="line">    CompletableFuture completableFuture = new CompletableFuture()</span><br><span class="line"></span><br><span class="line">    Vertx vertx = Vertx.vertx()</span><br><span class="line">    vertx.setTimer(<span class="number">1000</span>, &#123;</span><br><span class="line">        completableFuture.complete(<span class="string">"hello world"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return completableFuture.get()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">println</span><span class="params">(sayHello()</span></span>)</span><br></pre></td></tr></table></figure></p><p><code>vertx.setTimer</code>是个先天异步的东西，我们让它来模拟一个异步调用，你可以想象成从网络、磁盘或者其他什么接口，获取到那么一个字符串<code>hello world</code>。这么一个过程是异步的。然后在一个非异步程序的大环境下，后续的程序要等待这么一个结果。<br>此时我们用到了<code>CompletableFuture</code>，并且牵扯到其中的两个方法：<code>complete(T value)</code>、<code>get()</code>。</p><h4 id="complete-T-value"><a href="#complete-T-value" class="headerlink" title="complete(T value)"></a><code>complete(T value)</code></h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">If <span class="keyword">not</span> already completed, sets <span class="keyword">the</span> <span class="built_in">value</span> returned <span class="keyword">by</span> <span class="built_in">get</span>() <span class="keyword">and</span> related methods <span class="built_in">to</span> <span class="keyword">the</span> given <span class="built_in">value</span>.</span><br></pre></td></tr></table></figure><p>这个很好理解，就是给<code>completableFuture</code>塞一个完成的结果，供后续的方法调用获取，最典型的就是<code>get()</code></p><h4 id="get"><a href="#get" class="headerlink" title="get()"></a><code>get()</code></h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Waits <span class="keyword">if</span> necessary <span class="keyword">for</span> this future <span class="keyword">to</span> complete, <span class="keyword">and</span> <span class="keyword">then</span> returns <span class="keyword">its</span> <span class="literal">result</span>.</span><br></pre></td></tr></table></figure><p>这个<code>get()</code>方法源自于<code>Future</code>接口，是一个早在<code>Java 1.5</code>时代就提供的接口了。这个方法就是典型的阻塞式获取<code>Future</code>结果。放在上面的代码里，恰好能起到把<code>vert.x</code>的异步调用转换成同步的效果。但其实着不是什么好事，在<code>Java 8</code>中特意引入<code>CompletableFuture</code>就是为了解决阻塞问题，让异步发挥出更大的优势。</p><h4 id="发散一下"><a href="#发散一下" class="headerlink" title="发散一下"></a>发散一下</h4><p>抛开上面有意把异步转同步不说，我们来看看如果借助<code>CompletableFuture</code>，把<code>vert.x</code>的异步跟<code>Java 8</code>的异步有效结合，尝试代码如下：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import io<span class="selector-class">.vertx</span><span class="selector-class">.core</span><span class="selector-class">.Vertx</span></span><br><span class="line"></span><br><span class="line">import java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CompletableFuture</span></span><br><span class="line"></span><br><span class="line">CompletableFuture sayHello() &#123;</span><br><span class="line">    CompletableFuture completableFuture = new CompletableFuture()</span><br><span class="line"></span><br><span class="line">    Vertx vertx = Vertx.vertx()</span><br><span class="line">    vertx.setTimer(<span class="number">1000</span>, &#123;</span><br><span class="line">        completableFuture.complete(<span class="string">"hello world"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return completableFuture</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sayHello</span><span class="params">()</span></span>.whenCompleteAsync(&#123; res, <span class="selector-tag">th</span> -&gt;</span><br><span class="line">    println(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>简单改造过后，这就是一个遵循<code>Java 8</code>中<code>CompletableFuture</code>风格的异步使用方式。关键点在于<br><code>whenCompleteAsync(@NotNull BiConsumer&lt;? super T, ? super Throwable&gt; action)</code><br>方法，同时还有<br><code>whenComplete(@NotNull BiConsumer&lt;? super T, ? super Throwable&gt; action)</code><br>方法可供使用。这两个方法最大的区别是，前者会为<code>action</code>的执行上下文准备<code>ForkJoinPool</code>线程池环境；而后者会让<code>action</code>使用之前<code>completableFuture.complete()</code>所处的线程上下文。</p><h4 id="CompletableFuture是一个异常强大且复杂的类，本文所讲的东西不过是九牛一毛。这里推荐两个不错的帖子供大家参考："><a href="#CompletableFuture是一个异常强大且复杂的类，本文所讲的东西不过是九牛一毛。这里推荐两个不错的帖子供大家参考：" class="headerlink" title="CompletableFuture是一个异常强大且复杂的类，本文所讲的东西不过是九牛一毛。这里推荐两个不错的帖子供大家参考："></a><code>CompletableFuture</code>是一个异常强大且复杂的类，本文所讲的东西不过是九牛一毛。这里推荐两个不错的帖子供大家参考：</h4><ul><li><a href="https://colobu.com/2016/02/29/Java-CompletableFuture/" target="_blank" rel="noopener">https://colobu.com/2016/02/29/Java-CompletableFuture/</a></li><li><p><a href="https://www.ibm.com/developerworks/cn/java/j-cf-of-jdk8/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-cf-of-jdk8/index.html</a></p><p>  其中第二篇文章涉及的代码，我已经整理了一份，你可以从这里获取<a href="https://gist.github.com/aruis/135f6e1fa678fc5024ea20db4b9b4eee" target="_blank" rel="noopener">gist</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iTerm最佳实践</title>
      <link href="/2018/09/11/iTerm_best_practices/"/>
      <url>/2018/09/11/iTerm_best_practices/</url>
      <content type="html"><![CDATA[<p><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-11%2010.09.15.png" alt=""></p><p><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-11%2009.16.40.png" alt=""><br><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-11%2009.19.37.png" alt=""></p><h3 id="另注两个最常用的快捷键："><a href="#另注两个最常用的快捷键：" class="headerlink" title="另注两个最常用的快捷键："></a>另注两个最常用的快捷键：</h3><h4 id="横向分屏-⌘D"><a href="#横向分屏-⌘D" class="headerlink" title="横向分屏 ⌘D"></a>横向分屏 <code>⌘D</code></h4><h4 id="纵向分屏-⇧⌘D"><a href="#纵向分屏-⇧⌘D" class="headerlink" title="纵向分屏 ⇧⌘D"></a>纵向分屏 <code>⇧⌘D</code></h4>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Groovy迭代器中的return陷阱</title>
      <link href="/2018/09/10/groovy_return_in_each/"/>
      <url>/2018/09/10/groovy_return_in_each/</url>
      <content type="html"><![CDATA[<p><code>groovy</code>从不会让人失望，如果有，那就是接下来我要说的这种情况：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">def <span class="type">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">def test(List <span class="type">list</span>) &#123;</span><br><span class="line">    <span class="type">list</span>.each &#123;</span><br><span class="line">        if (it &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            return it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println test(<span class="type">list</span>)</span><br></pre></td></tr></table></figure></p><p>我们期望的结果<code>4</code>，也就是找到第一个比3大的数字就返回了，然而事与愿违，得到的结果是这样<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure></p><p>整个list都被打印了出来，其实<code>test</code>方法最终返回的东西是<code>list.each{...}</code>，而且<code>.each</code>方法的返回值是<code>the self List</code>，所以最后把<code>list</code>又原封不动打印了一遍也就不足为奇了。<br>那我们写的那行<code>return</code>干吗了，答案是，它既不会是方法返回，也不会使<code>each closure</code>返回，它在这里的作用跟<code>continue</code>类似，仅仅是让它后面的代码不在这次循环执行，仅此而已。</p><h4 id="那怎么才能打断一个each，然后让上面的方法提前return呢？"><a href="#那怎么才能打断一个each，然后让上面的方法提前return呢？" class="headerlink" title="那怎么才能打断一个each，然后让上面的方法提前return呢？"></a>那怎么才能打断一个<code>each</code>，然后让上面的方法提前<code>return</code>呢？</h4><p><strong>答案是，不能用<code>each</code>，得用<code>find</code>或者<code>any</code>之类的，</strong>有明显截断语义的迭代器。这里还是首推<code>find</code>，因为<code>any</code>返回值是<code>boolean</code>，能帮我们截断迭代，但是不适用于找东西的场景。</p><p>用<code>find</code>改造一下代码，如下<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">def test(List <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="built_in">    return</span> <span class="built_in">list</span>.find &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">it</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">            return</span> <span class="keyword">it</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于<code>groovy</code>方法中的<code>return</code>是可以省略的，更进一步，就写成这样<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">def test(List <span class="built_in">list</span>) &#123;</span><br><span class="line">   <span class="built_in">list</span>.find &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">it</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">            return</span> <span class="keyword">it</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然基于<code>find</code>的先天特性，那句<code>return it</code>也可以省略成这样<br><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">def test(<span class="built_in">List</span> <span class="built_in">list</span>) &#123;</span><br><span class="line">   <span class="built_in">list</span>.<span class="built_in">find</span> &#123; it &gt; <span class="number">3</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再次之前执行<code>println test(list)</code>，得到结果<code>4</code>，一切归于完美了。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>这里不得不说下<code>Kotlin</code>，它应付上面描述的场景就非常得心应手了。首先，默认情况下<code>return</code>就是代表让一个方法返回，这符合一个程序员的直觉。<br>在不想扩大<code>return</code>的打击范围，而仅仅只想结束一个<code>lambda</code>的时候，可以使用<code>标签返回</code>，类似这样<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>.<span class="keyword">forEach</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (it &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>@<span class="keyword">forEach</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果上面的语法糖，让你觉得有点故弄玄虚了，还可以使用更容易理解的匿名函数，就像这样<br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">list.forEach(<span class="function"><span class="keyword">fun</span>(<span class="title">it</span></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (it &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>我是非常喜欢<code>groovy</code>的，她已经陪伴我8个年头了，几乎我手上所有的项目都离不开<code>groovy</code>的身影。我甚至用她写过<code>Android</code>程序。不过不得不承认，<code>Kotlin</code>作为后起之秀，的确在很多方向上更进一步，考虑的场景也更为全面。期待<code>groovy</code>的<code>3.0</code>能够发力一波。</strong></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用JavaScript在PostgreSQL中写存储过程</title>
      <link href="/2018/09/09/plv8_in_postgresql/"/>
      <url>/2018/09/09/plv8_in_postgresql/</url>
      <content type="html"><![CDATA[<p>首先交代一个概念，在<code>PostgreSQL</code>中，函数、存储过程都是一回事，创建语法都是<code>create function</code>。之所以本文标题使用<code>存储过程</code>的叫法，是为了方便其他数据库的使用者容易理解。<br>先来看看<code>PostgreSQL</code>默认支持的创建数据库函数的写法，如：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 把系统生成的uuid中的-替换成_</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> <span class="keyword">uuid</span>()</span><br><span class="line">  <span class="keyword">returns</span> <span class="built_in">text</span></span><br><span class="line"><span class="keyword">language</span> <span class="keyword">sql</span></span><br><span class="line"><span class="keyword">as</span> $$</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">replace</span>(uuid_generate_v4()::<span class="built_in">text</span>,<span class="string">'-'</span>,<span class="string">'_'</span>);</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure></p><p>注意其中的<code>language</code>关键字，后面指明了该数据库函数所使用的语言，上面这个函数很简单，用纯<code>SQL</code>就能搞定，更多的时候，我们遇到的会复杂很多，就得用上过程化的SQL，也就是<code>plpgsql</code>（类似Oracle中的PL/SQL），具体可以查看官方文档<a href="http://www.postgres.cn/docs/10/plpgsql.html" target="_blank" rel="noopener">plpgsql</a>。<br>不过今天的主题不是<code>plpgsql</code>，而是<code>plv8</code>——基于<code>V8</code>引擎的在<code>PostgreSQL</code>中运行的过程化语言，其实就是用<code>JavaScript</code>在<code>PostgreSQL</code>中写数据库函数。<br><strong>那么为什么要用<code>Javascript</code>来写数据库函数呢？</strong>在我看来，至少有下面几个好处：</p><ol><li>熟悉的配方，熟悉的味道。<code>JavaScript</code>作为<code>Web</code>世界的一等公民，其教众众多。能用<code>JavaScript</code>来实现高级的数据库开发，可以大幅拉低数据库的学习曲线，进而<strong>降低人力成本</strong>。</li><li>获得<code>SQL</code>世界本身不具备的库函数，像这样：<img src="/media/15364987364827.jpg" alt=""><br> 还有这样：<br> <img src="/media/15364989242348.jpg" alt=""><br> 可以极大丰富数据库层面的功能实现，进而影响一个软件的架构设计。</li><li>更快的性能，众所周知<code>Google</code>主推的<code>V8</code>引擎是业界公认的顶尖性能怪兽。有它配合你的数据库使用真是如虎添翼。尤其是在业务系统的开发采用了并不是以性能为卖点的语言时（比如<code>Ruby</code>、<code>PHP</code>），把部分业务逻辑通过<code>JavaScript</code>在数据库中重构一边，说不定会有意想不到的效果。这比伤筋动骨地单纯在业务层摸索改进要容易得多。</li></ol><p>说了这么多，怎么才能在<code>PostgreSQL</code>中用上<code>JavaScript</code>呢？</p><ul><li>第一步肯定是在电脑上装好<code>PostgreSQL</code>，这个不再赘述</li><li><code>windows</code>用户，可以下载这里的安装包，<a href="http://www.postgresonline.com/journal/archives/379-PLV8-binaries-for-PostgreSQL-10-windows-both-32-bit-and-64-bit.html" target="_blank" rel="noopener">http://www.postgresonline.com/journal/archives/379-PLV8-binaries-for-PostgreSQL-10-windows-both-32-bit-and-64-bit.html</a> </li><li><code>ubuntu</code>用户，<code>apt-get install postgresql-10-plv8</code></li><li>更多安装细节，请参考官方文档：<a href="https://plv8.github.io" target="_blank" rel="noopener">https://plv8.github.io</a> 以及 <a href="https://pgxn.org/dist/plv8/doc/plv8.html" target="_blank" rel="noopener">https://pgxn.org/dist/plv8/doc/plv8.html</a></li><li><p>当然，如果你熟悉<code>docker</code>，可以使用我在<code>docker store</code>上分享的<code>lovearuis/postgres10_plv8</code>（<a href="https://store.docker.com/community/images/lovearuis/postgres10_plv8" target="_blank" rel="noopener">地址</a>），只需要这么一个命令</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> <span class="attribute">--name</span>=postgres10_plv8 -d -p 5432:5432 lovearuis/postgres10_plv8</span><br></pre></td></tr></table></figure><p>  就可以在本机<code>5432</code>端口上运行一个装好<code>JavaScript</code>支持的最新版<code>PostgreSQL</code></p></li><li>安装完必要的<code>plv8</code>包之后，还要在数据库中执行<code>SQL</code>：<code>CREATE EXTENSION plv8;</code>，才能真正解锁<code>plv8</code>的洪荒之力。</li></ul><p>一切就绪之后，按照官方文档上举例的，先来个带<code>for</code>循环和生成<code>JSON</code>的耍耍，<code>SQL</code>如下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> plv8_test(<span class="keyword">keys</span> <span class="built_in">TEXT</span>[], vals <span class="built_in">TEXT</span>[]) <span class="keyword">RETURNS</span> <span class="keyword">JSON</span> <span class="keyword">AS</span> $$</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">for(var i=0; i&lt;keys.length; i++)&#123;</span><br><span class="line">o[keys[i]] = vals[i];</span><br><span class="line">&#125;</span><br><span class="line">return o;</span><br><span class="line">$$ LANGUAGE plv8 IMMUTABLE STRICT;</span><br></pre></td></tr></table></figure></p><p>尝试调用刚刚创建的<code>plv8_test</code>函数：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> plv8_test(<span class="built_in">ARRAY</span>[<span class="string">'name'</span>, <span class="string">'age'</span>], <span class="built_in">ARRAY</span>[<span class="string">'Tom'</span>, <span class="string">'29'</span>]);</span><br></pre></td></tr></table></figure></p><p>获得结果<img src="/media/15365022296404.jpg" alt=""><br>是不是美妙极了？☺️</p><h3 id="放大招"><a href="#放大招" class="headerlink" title="放大招"></a>放大招</h3><p>是不是看了上面的介绍，有点心痒难耐了。🤪<strong>其实<code>PostgreSQL</code>在内部可调用的过程化语言的支持远不仅于此。你完全可以用你心爱的<code>Python</code>、<code>Java</code>、<code>PHP</code>甚至是<code>R</code>、<code>Lua</code>从事<code>PostgreSQL</code>中的数据库函数开发。</strong><br>尤其是<code>Python</code>、<code>Java</code>，这两个语言几乎在<code>PostgreSQL</code>的<code>PL</code>环境下有最大的权限空间。想象这样一个场景：<br>一个别人做的项目（你没有源码，或者有源码跟没有也没啥区别），领导说要加个需求，当一个数据到达某种阀值时，要发短信给一个人（比如考试成绩低于60的时候，发个短信给学生家长）。这个时候，你不需要再打开开发环境，在别人的代码里面流离失所，久久不能自拔。你需要做的，就是打开这个项目的<code>PostgreSQL</code>（谢天谢地，它用了世界上最先进的开源数据库，尽管它的代码跟翔没什么区别），然后用<code>Java</code>在<code>PostgreSQL</code>中写个数据库函数（请求一个短信网关的http接口或者别的什么东西），最后套一个触发器（3行<code>SQL</code>）就什么都完成了。<br>这画面太美，我不敢想象啊，哈哈。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Google Trends了解某一技术的全球态势</title>
      <link href="/2018/09/08/Google_Trends/"/>
      <url>/2018/09/08/Google_Trends/</url>
      <content type="html"><![CDATA[<p>今天想介绍的东西很简单了，但却异常强大，就是<code>Google Trends</code>。使用方法非常简单，访问<a href="https://trends.google.com/trends/explore" target="_blank" rel="noopener">trends.google.com</a>即可。<br>那么来看看我自己通过<code>Google Trends</code>发掘的一些有意思的事情吧。<br><img src="/media/15363698300629.jpg" alt=""><br><img src="/media/15363699317160.jpg" alt=""><br><img src="/media/15363701237412.jpg" alt=""><br><img src="/media/15363701562662.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>IntelliJ IDEA中那些锦上添花的小技巧</title>
      <link href="/2018/09/07/IntelliJ_IDEA_tips/"/>
      <url>/2018/09/07/IntelliJ_IDEA_tips/</url>
      <content type="html"><![CDATA[<p><code>IntelliJ IDEA</code>作为相当主流的<code>Java</code>开发工具，网上分享其使用技巧的如汗牛充栋。今天我从自己的角度，分享一些经常被人忽视，同时也不怎么重要的使用技巧，权作锦上添花之用。</p><h4 id="用Toolbox来管理IntelliJ-IDEA"><a href="#用Toolbox来管理IntelliJ-IDEA" class="headerlink" title="用Toolbox来管理IntelliJ IDEA"></a>用<code>Toolbox</code>来管理<code>IntelliJ IDEA</code></h4><p>自己安装<code>IntelliJ IDEA</code>诚然没什么难度，但是架不住其更新频率实在太高，而且有时候还没有升级包可用。所以通过<code>Toolbox</code>来保持<code>IntelliJ IDEA</code>永远在最新版本是一种相当有效的做法。</p><h4 id="用Dracula插件来美化代码配色"><a href="#用Dracula插件来美化代码配色" class="headerlink" title="用Dracula插件来美化代码配色"></a>用<code>Dracula</code>插件来美化代码配色</h4><p><img src="/media/15363162820957.jpg" alt=""><br>美化后的代码配色如上图，愿项目地址在此：<a href="https://draculatheme.com/jetbrains/" target="_blank" rel="noopener">https://draculatheme.com/jetbrains/</a> 如何使用，该项目文档已经讲的很清楚了</p><h4 id="编辑VM-Options"><a href="#编辑VM-Options" class="headerlink" title="编辑VM Options"></a>编辑<code>VM Options</code></h4><p><code>IntelliJ IDEA</code>毕竟还是<code>Java</code>程序，想要发挥最大性能，还是需要好好维护<code>JVM</code>参数的。早期<code>IntelliJ IDEA</code>版本中，要维护<code>VM Options</code>是需要到该程序安装目录找到一个特殊文件手动编辑的。现在处理起来简单多了，只需要点菜单的这里，如图：<br><img src="/media/15363168799795.jpg" alt=""></p><p>就可以方便地在<code>IntelliJ IDEA</code>环境中编辑<code>VM Options</code>了。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>免百度网盘客户端下载大文件并突破非会员限速</title>
      <link href="/2018/09/06/break_through_baiduwangpan/"/>
      <url>/2018/09/06/break_through_baiduwangpan/</url>
      <content type="html"><![CDATA[<p>在网盘市场洗过几次牌后的今天，百度网盘可以说是如今的头牌了。网上充斥的各种资源，几乎都在用百度网盘分享。但是百度这家公司怎么说呢，就是骨子里，有一点<code>X</code>，<em>你懂的</em>。遇到稍微大一点的文件，不让从浏览器直接下载不说，限速起来更是毫无人性。<br>不过正所谓道高一尺，魔高一丈。在互联网的江湖，一切皆有可能。今天我们就来介绍一种借助浏览器插件突破百度网盘限制的一种方法。</p><h3 id="1-安装浏览器插件tampermonkey"><a href="#1-安装浏览器插件tampermonkey" class="headerlink" title="1. 安装浏览器插件tampermonkey"></a>1. 安装浏览器插件<code>tampermonkey</code></h3><p>就和安装其他浏览器插件一样，没什么难度，可以去它的官网查看<a href="http://tampermonkey.net" target="_blank" rel="noopener">http://tampermonkey.net</a> 。看看官网是怎么介绍它的<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">Tampermonkey 是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera <span class="keyword">Next</span>, 和 Firefox。</span><br></pre></td></tr></table></figure></p><h3 id="2-安装针对百度网盘的拓展脚本EX-百度云盘"><a href="#2-安装针对百度网盘的拓展脚本EX-百度云盘" class="headerlink" title="2. 安装针对百度网盘的拓展脚本EX-百度云盘"></a>2. 安装针对百度网盘的拓展脚本<code>EX-百度云盘</code></h3><p>项目地址：<a href="https://greasyfork.org/zh-CN/scripts/26638-ex-百度云盘" target="_blank" rel="noopener">EX-百度云盘</a>，访问这个项目页面时，可以看到大大的<code>安装此脚本</code>按钮，大胆点击它就好了。</p><h3 id="3-访问任意一个百度网盘分享页面就能够发现惊喜了"><a href="#3-访问任意一个百度网盘分享页面就能够发现惊喜了" class="headerlink" title="3. 访问任意一个百度网盘分享页面就能够发现惊喜了"></a>3. 访问任意一个百度网盘分享页面就能够发现惊喜了</h3><p><img src="/media/15361965426250.jpg" alt=""><br>此时通过点击<code>普通下载</code>就能够突破百度网盘网页版对于大文件不允许下载的限制了</p><h3 id="4-突破速度限制"><a href="#4-突破速度限制" class="headerlink" title="4. 突破速度限制"></a>4. 突破速度限制</h3><p>接上图，通过<code>复制链接</code>按钮，我们就能获取该资源的原始下载链接，此时我们通过任意多线程下载工具（包括迅雷，但不怎么好用就是了），就能获得几乎峰值的下载速度了。<br><img src="/media/15361968542946.jpg" alt=""><br>截图中，我使用的工具是<code>Aria2GUI</code>，这是一款针对<code>mac OS</code>的下载工具（<a href="https://github.com/yangshun1029/aria2gui/releases" target="_blank" rel="noopener">点此下载</a>）。如果你是<code>windows</code>用户，可以试试<code>IDM</code>或者<code>flashget</code>，如果动手能力强可以搜索<code>aria2 windows</code>关键词，打开新世界的大门。</p>]]></content>
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ubuntu里查看软件包信息</title>
      <link href="/2018/09/05/ubuntu_show_soft_info/"/>
      <url>/2018/09/05/ubuntu_show_soft_info/</url>
      <content type="html"><![CDATA[<p>以<code>postgresql-10-plv8</code>这个软件包为例，需要知道软件包的一些必要信息，比如版本、项目主页、大小、简单说明之类的，可以用如下命令查看：<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">apt <span class="keyword">show</span> postgresql<span class="number">-10</span>-plv8</span><br></pre></td></tr></table></figure></p><p>对于早期版本的ubuntu（&lt;14.04），可以使用这个命令<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">apt-<span class="keyword">cache </span><span class="keyword">show </span>postgresql-10-plv8</span><br></pre></td></tr></table></figure></p><p>另外一种方式也是极好的，就是利用<code>aptitude</code>，前提是你先安装了它，那么就可以这么用：<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">aptitude <span class="keyword">show</span> postgresql<span class="number">-10</span>-plv8</span><br></pre></td></tr></table></figure></p><p><code>aptitude</code>比前者强的地方是它能告诉你该软件包是否已经安装</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gradle插件下载不下来的解决方案</title>
      <link href="/2018/09/04/gradle_plugin_download_error/"/>
      <url>/2018/09/04/gradle_plugin_download_error/</url>
      <content type="html"><![CDATA[<p>字符乱码和互联网不互联，是困扰中国程序员的两大问题。我就在使用<code>gradle</code>的时候，会遇到官方插件下载不下来的情况。<br>比如使用<code>org.hidetake.ssh</code>插件时，如果按照文档所述，直接这样写<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">plugins</span> &#123;</span><br><span class="line">  <span class="attribute">id</span> <span class="string">'org.hidetake.ssh'</span> version <span class="string">'2.9.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有时候就会遇到网络问题，因为此时要去访问<code>gradle.org</code>官网去申请插件，而不知道什么时候这个网络就不通了。<br>此时我们可以通过细化<code>buildscript</code>的<code>repositories</code>来解决问题，也就是在<code>plugins</code>之前，增加<code>buildscript</code>的配置内容，整体代码如下<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">buildscript</span> &#123;</span><br><span class="line">    <span class="section">repositories</span> &#123;</span><br><span class="line">        <span class="section">maven</span> &#123;</span><br><span class="line">            <span class="attribute">url</span> <span class="string">"http://maven.aliyun.com/nexus/content/groups/public"</span></span><br><span class="line">        &#125;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    <span class="attribute">id</span> <span class="string">"org.hidetake.ssh"</span> version <span class="string">"2.9.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>这里我们通过使用阿里云的<code>maven</code>服务器地址，理论上还能在国内获得更快的资源访问速度。</em></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim必知必会</title>
      <link href="/2018/09/03/vim_note/"/>
      <url>/2018/09/03/vim_note/</url>
      <content type="html"><![CDATA[<h3 id="普通模式下光标移动"><a href="#普通模式下光标移动" class="headerlink" title="普通模式下光标移动"></a>普通模式下光标移动</h3><ul><li><code>h</code>：左移一个字符</li><li><code>j</code>：下移一行</li><li><code>k</code>：上移一行</li><li><p><code>l</code>：右移一个字符</p></li><li><p><code>PageDown</code>(<code>Ctrl+F</code>)：下翻一屏</p></li><li><code>PageUp</code>（<code>Ctrl+B</code>）上翻一屏</li><li><code>G</code>：移动到最后一行</li><li><code>num G</code>：移动到第<em>num</em>行</li><li><code>gg</code>：移动到第一行</li></ul><h3 id="命令模式下的命令"><a href="#命令模式下的命令" class="headerlink" title="命令模式下的命令"></a>命令模式下的命令</h3><ul><li><code>q</code>：退出</li><li><code>q!</code>：放弃修改，退出</li><li><code>w filename</code>：保存到另外一个文件</li><li><code>wq</code>：保存并退出</li></ul><h3 id="普通模式下的编辑命令"><a href="#普通模式下的编辑命令" class="headerlink" title="普通模式下的编辑命令"></a>普通模式下的编辑命令</h3><ul><li><code>x</code>：删除光标位置的的字符</li><li><code>dd</code>：删除光标所在行</li><li><code>dw</code>：删除光标所在单词</li><li><code>d$</code>：删除光标至行尾</li><li><code>J</code>：删除光标所在行的换行符</li><li><code>u</code>：撤销操作</li><li><code>a</code>：在光标后追加数据</li><li><code>A</code>：在光标所在行末尾追加数据</li><li><code>r char</code>：用<em>char</em>替换光标所在字符</li><li><code>R text</code>：用<em>text</em>替换光标所在位置数据</li></ul><h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><ul><li><code>y</code>复制，跟<code>d</code>类似，<code>yw</code>复制一个单词，<code>y$</code>复制到行尾</li><li><code>p</code>粘贴<br>还有个特别好用的就是<code>v</code>模式，可以通过敲<code>v</code>进入，然后就可以移动光标批量选择内容，按<code>y</code>复制，之后合适的位置<code>p</code>进行粘贴</li></ul><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><ul><li><code>:s/old/new/</code>替换一处</li><li><code>:%s/old/new/g</code>替换所有</li><li><code>:%s/old/new/gc</code>以交互询问的方式，替换所有</li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ssh中文乱码</title>
      <link href="/2018/09/02/ssh_chinese_garbled/"/>
      <url>/2018/09/02/ssh_chinese_garbled/</url>
      <content type="html"><![CDATA[<p>ssh远程到服务器后，遇到中文乱码，建议通过<code>locale</code>检查当前的字符集，如果遇到<code>LC_ALL=</code>无值，十有八九是要出问题的。<br>此时可以通过执行<code>export  LC_ALL=zh_CN.UTF-8</code>临时解决。<br>当然，把上面这句添加到<code>.bash_profile</code>中，就可以永久解决了。 就像这样<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .bash_profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the aliases and functions</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">        . ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific environment and startup programs</span></span><br><span class="line"></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="built_in">export</span>  LC_ALL=zh_CN.UTF-8</span><br></pre></td></tr></table></figure></p><p>补充一点，用<code>en_US.UTF-8</code>代替上文的<code>zh_CN.UTF-8</code>也是同样有效的。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>相当靠谱的FastDFS Docker镜像</title>
      <link href="/2018/09/01/fastdfs_docker/"/>
      <url>/2018/09/01/fastdfs_docker/</url>
      <content type="html"><![CDATA[<p>该项目是我在网上搜的，迄今为止个人感觉最靠谱的<code>FastDFS</code>镜像，项目地址<a href="https://github.com/luhuiguo/fastdfs-docker" target="_blank" rel="noopener">https://github.com/luhuiguo/fastdfs-docker</a></p><p>开启一个<code>tracker</code><br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">docker run -dti <span class="params">--network=host</span> <span class="params">--name</span> tracker -v <span class="string">/var/fdfs/tracker</span>:<span class="string">/var/fdfs</span> luhuiguo/fastdfs tracker</span><br></pre></td></tr></table></figure></p><p>开启一个<code>storage</code><br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -dti <span class="attribute">--network</span>=host --name storage0 -e <span class="attribute">TRACKER_SERVER</span>=10.1.5.85:22122 -v /var/fdfs/storage0:/var/fdfs luhuiguo/fastdfs storage</span><br></pre></td></tr></table></figure></p><p>开启一个<code>storage</code>，并指定<code>Group</code><br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -dti <span class="attribute">--network</span>=host --name storage2 -e <span class="attribute">TRACKER_SERVER</span>=10.1.5.85:22122 -e <span class="attribute">GROUP_NAME</span>=group2 -e <span class="attribute">PORT</span>=22222 -v /var/fdfs/storage2:/var/fdfs luhuiguo/fastdfs storage</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> FastDFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一个八岁小女孩</title>
      <link href="/2018/08/31/eight_years_girl/"/>
      <url>/2018/08/31/eight_years_girl/</url>
      <content type="html"><![CDATA[<p><img src="/media/FullSizeRender.jpeg" alt="摄于兴义机场"></p><p>在贵阳飞回徐州的飞机上，坐在我旁边的是一个胖乎乎的小女孩。飞行的前半程，我一直有个疑问，就是谁和她通行的，总不可能一个二三年级的小学生独自坐飞机，而且还是要飞个上千公里的这种。<br>直到看到她自己去跟空姐沟通午餐事宜，自己从书包里拿出一张毛爷爷来支付自己的午餐。我才明白，原来她是一个人坐飞机的。心中暗暗赞叹。<br>后来简单跟她聊了一会，得知她今年八岁。因为父母离异，分居两地，她从四岁时就开始了这种独自往返于贵阳与徐州的生活。这的确听起来让人觉得可怜，毕竟孩子是无辜的，但却没什么其他办法。<br>我留了一张有我们俩人的自拍照，但没有问她名字。只能在心里默默祝福她，希望未来能越来越好。</p><p>最后记录一下我俩的对话：<br>她：你说世界上坏人多么？<br>我：多，但是没有好人多。</p>]]></content>
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>«写给大家看的设计书»中最关键的九个字</title>
      <link href="/2018/08/30/non-designers-design-book/"/>
      <url>/2018/08/30/non-designers-design-book/</url>
      <content type="html"><![CDATA[<p>«写给大家看的设计书»书如其名，是一本非常适合外行看的设计书。这本书再版多次，足以证明其优秀，推荐给可能会遇到UI设计需求的程序员同胞看。<br>全书的核心思想就是四个原则，如果你没时间看书，只要牢记这四大原则，也是能够获益良多的。</p><h3 id="对比-（Contrast）"><a href="#对比-（Contrast）" class="headerlink" title="对比 （Contrast）"></a>对比 （Contrast）</h3><p>对比的目的是强调重点，所以也不要为了对比而对比。通过对比的设计，突出你想表达的，让受众能更容易地发现重点。</p><h3 id="重复-（Repetition）"><a href="#重复-（Repetition）" class="headerlink" title="重复 （Repetition）"></a>重复 （Repetition）</h3><p>不是单指字面上的重复，按我的理解，用“呼应”更为贴切。颜色也好、图形也好、甚至字体等等，通过一定的重复产生呼应的效果。给人一种精心设计的感觉。</p><h3 id="对齐-（Alignment）"><a href="#对齐-（Alignment）" class="headerlink" title="对齐 （Alignment）"></a>对齐 （Alignment）</h3><p>这个很多人都有感触的。我想说的是，对齐其实也是某个维度的重复，其实跟第二条原则是重叠的。只是对齐是最容易做到，也是最应该做到的，故而单独拿出以示其重要性。</p><h3 id="亲密性-（Proximity）"><a href="#亲密性-（Proximity）" class="headerlink" title="亲密性 （Proximity）"></a>亲密性 （Proximity）</h3><p>这个翻译，还挺让人晕的。简单的说，就是把有共性的事物聚类，形成视觉单元（<em>visual unit</em>）。</p><p>以上四原则摘自<a href="https://item.jd.com/11824338.html" target="_blank" rel="noopener">«写给大家看的设计书»</a>，但是解读是我自己根据理解补充的。话说回来，当你回过头审视这几个原则的时候，会发现这甚至跟写作文、写诗歌、写小说有点像。要有起伏，要有重点，要前后呼应。是不是很有意思呢？</p>]]></content>
      
      <categories>
          
          <category> 设计相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在SpringBoot中使用groovy.sql.SQL高效开发</title>
      <link href="/2018/08/29/groovy-sql-SQL-in-spring-boot/"/>
      <url>/2018/08/29/groovy-sql-SQL-in-spring-boot/</url>
      <content type="html"><![CDATA[<p>某种情况下，其实就想用<code>Spring Boot</code>提供的那种即开即用的开发体验，但是我真的对<code>Spring</code>保姆式的一揽子工程不怎么感冒。尤其是数据库<code>JDBC</code>这块。常见的<code>Java</code>系里提到的技术，我真的一个都不想用，我最钟爱的数据库类库其实就是<code>groovy.sql.SQL</code>，简单而强大，配合<code>Groovy</code>之后，再也没有繁琐的<code>Java Bean</code>和无边无际的<code>get</code>、<code>set</code>。<br>想了解更多<code>groovy.sql.SQL</code>欢迎查看官方文档：<a href="http://groovy-lang.org/databases.html" target="_blank" rel="noopener">http://groovy-lang.org/databases.html</a><br>今天我们还是着重说一下，怎么在<code>Spring Boot</code>的框架下融入<code>groovy.sql.SQL</code>，话不多说，上代码：</p><h4 id="gradle-build"><a href="#gradle-build" class="headerlink" title="gradle.build"></a>gradle.build</h4><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'org.springframework.boot'</span> version <span class="string">'1.5.15.RELEASE'</span></span><br><span class="line">    id <span class="string">'war'</span></span><br><span class="line">    id <span class="string">'groovy'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> <span class="string">'com.aruistar'</span></span><br><span class="line">version <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    groovy_version = <span class="string">"2.5.2"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-starter-web"</span>)</span><br><span class="line"><span class="comment">//    providedRuntime("org.springframework.boot:spring-boot-starter-tomcat")</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.codehaus.groovy:groovy:$groovy_version"</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.codehaus.groovy:groovy-sql:$groovy_version"</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.codehaus.groovy:groovy-json:$groovy_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'com.alibaba'</span>, name: <span class="string">'druid'</span>, version: <span class="string">'1.1.10'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'mysql'</span>, name: <span class="string">'mysql-connector-java'</span>, version: <span class="string">'5.1.46'</span></span><br><span class="line"></span><br><span class="line">    testCompile <span class="string">"org.codehaus.groovy:groovy-test:$groovy_version"</span></span><br><span class="line">    testCompile(<span class="string">"org.springframework.boot:spring-boot-starter-test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="程序入口Application"><a href="#程序入口Application" class="headerlink" title="程序入口Application"></a>程序入口Application</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aruistar</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"><span class="keyword">import</span> groovy.sql.Sql</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.support.SpringBootServletInitializer</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(Application.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"app.datasource"</span>)</span><br><span class="line">    <span class="function">DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().type(DruidDataSource.class).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Sql <span class="title">db</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sql(dataSource())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置文件application-yml"><a href="#配置文件application-yml" class="headerlink" title="配置文件application.yml"></a>配置文件application.yml</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">app:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/test</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    pool-size:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="用上Sql的Controller"><a href="#用上Sql的Controller" class="headerlink" title="用上Sql的Controller"></a>用上Sql的Controller</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aruistar.controller</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> groovy.sql.Sql</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/open"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Sql db</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function">def <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        db.firstRow(<span class="string">"select 1)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这套方案用上了<code>Spring</code>，也用上了数据库连接池<code>druid</code>，所以项目整体是足够健壮的。如果你的项目本来就是基于<code>Spring</code>技术栈的，那我强烈推荐你试试结合<code>Groovy</code>的这套打法。可以大幅提升开发效率。<br><strong>亲自跑一下<code>Groovy</code>项目，用用她提供的<code>SQL</code>类，我想你会爱上她的</strong></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>上墙纪念</title>
      <link href="/2018/08/28/vertx_example_contributors/"/>
      <url>/2018/08/28/vertx_example_contributors/</url>
      <content type="html"><![CDATA[<p><img src="/media/15354179433179.jpg" alt=""><br><a href="https://github.com/vert-x3/vertx-examples" target="_blank" rel="noopener">vertx-examples</a>项目合并了我一次<code>PR</code>，所以我的ID出现在<a href="https://github.com/vert-x3/vertx-examples/graphs/contributors" target="_blank" rel="noopener">contributors</a>里了。应该是为数不多的亚裔面孔。嗨皮。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> contributors </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gradle中的sourceCompatibility与targetCompatibility</title>
      <link href="/2018/08/27/sourceCompatibility_and_targetCompatibility_in_gradle/"/>
      <url>/2018/08/27/sourceCompatibility_and_targetCompatibility_in_gradle/</url>
      <content type="html"><![CDATA[<p><code>Gradle</code>中有两个属性，我也是一知半解。今天正好要练习下<code>Java10</code>，那就先把这两个属性的问题测试透了再说。那就是<code>sourceCompatibility</code>和<code>targetCompatibility</code>。<br>简单的说，<code>sourceCompatibility</code>属性跟编译环境有关，而<code>targetCompatibility</code>属性跟运行环境有关。<br>至少有这么几个原则，是不能违背的：</p><ol><li><code>sourceCompatibility</code>关系到你使用到的<code>Java</code>语法特性及库</li><li><code>sourceCompatibility</code>不能比<code>targetCompatibility</code>大</li><li><code>targetCompatibility</code>不能比目标客户端运行环境的<code>JavaVersion</code>大</li><li><code>targetCompatibility</code>不能比当前<code>Gradle</code>使用的<code>JavaVersion</code>大</li></ol><p>总结起来就是这样<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">代码用的语言特性对应的JavaVersion </span><br><span class="line">≦ <span class="keyword">sourceCompatibility</span> </span><br><span class="line">≦ <span class="keyword">targetCompatibility</span> </span><br><span class="line">≦ Gradle使用的JavaVersion </span><br><span class="line">≦ 客户端环境的JavaVersion</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中关于SCHEMA和SEARCH_PATH的一些技巧</title>
      <link href="/2018/08/26/postgresql_schema_and_search_path/"/>
      <url>/2018/08/26/postgresql_schema_and_search_path/</url>
      <content type="html"><![CDATA[<h4 id="1-extension最好放在单独的schema里，就像这样"><a href="#1-extension最好放在单独的schema里，就像这样" class="headerlink" title="1. extension最好放在单独的schema里，就像这样"></a>1. <code>extension</code>最好放在单独的<code>schema</code>里，就像这样</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">schema</span> <span class="string">"extension_schema"</span>;</span><br><span class="line"><span class="keyword">create</span> extension <span class="string">"ltree"</span> <span class="keyword">schema</span> extension_schema;</span><br></pre></td></tr></table></figure><h4 id="2-业务上不相干的表，建议也放在单独的schema中，比如这样"><a href="#2-业务上不相干的表，建议也放在单独的schema中，比如这样" class="headerlink" title="2.业务上不相干的表，建议也放在单独的schema中，比如这样"></a>2.业务上不相干的表，建议也放在单独的<code>schema</code>中，比如这样</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">schema</span> <span class="string">"metadata_schema"</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">schema</span> <span class="string">"platform_schema"</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">schema</span> <span class="string">"platform_schema"</span>;</span><br></pre></td></tr></table></figure><h4 id="3-可选-从数据库设计的角度来说，不同schema中的表名是可以重名的。但是我们有时候要反其道而行之，就是要任何情况下表名不同，方便编写SQL的时候，可以方便的省略schema。这样就需要借助触发器了。像这样"><a href="#3-可选-从数据库设计的角度来说，不同schema中的表名是可以重名的。但是我们有时候要反其道而行之，就是要任何情况下表名不同，方便编写SQL的时候，可以方便的省略schema。这样就需要借助触发器了。像这样" class="headerlink" title="3.[可选]从数据库设计的角度来说，不同schema中的表名是可以重名的。但是我们有时候要反其道而行之，就是要任何情况下表名不同，方便编写SQL的时候，可以方便的省略schema。这样就需要借助触发器了。像这样"></a>3.[<em>可选</em>]从数据库设计的角度来说，不同<code>schema</code>中的表名是可以重名的。但是我们有时候要反其道而行之，就是要任何情况下表名不同，方便编写<code>SQL</code>的时候，可以方便的省略<code>schema</code>。这样就需要借助触发器了。像这样</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> table_create()</span><br><span class="line">  <span class="keyword">returns</span> event_trigger</span><br><span class="line"><span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">        table_name       <span class="built_in">VARCHAR</span>;</span><br><span class="line">        short_table_name VARCHAR;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> object_identity</span><br><span class="line">  <span class="keyword">INTO</span> table_name</span><br><span class="line">  <span class="keyword">FROM</span> pg_event_trigger_ddl_commands();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">substr</span>(table_name, <span class="keyword">position</span>(<span class="string">'.'</span> <span class="keyword">IN</span> table_name) + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">INTO</span> short_table_name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span></span><br><span class="line">  <span class="keyword">INTO</span> is_exist</span><br><span class="line">  <span class="keyword">FROM</span> pg_catalog.pg_stat_user_tables</span><br><span class="line">  <span class="keyword">WHERE</span> relname = short_table_name :: <span class="built_in">VARCHAR</span>;</span><br><span class="line"></span><br><span class="line">  IF is_exist</span><br><span class="line">  THEN</span><br><span class="line">    RAISE EXCEPTION '%  already exists. event:%, command:%. abort.', table_name, TG_EVENT, TG_TAG;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EVENT</span> <span class="keyword">TRIGGER</span> etgr_table_create</span><br><span class="line"><span class="keyword">ON</span> ddl_command_end</span><br><span class="line"><span class="keyword">WHEN</span> TAG <span class="keyword">IN</span> (<span class="string">'CREATE TABLE'</span>)</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> table_create();</span><br></pre></td></tr></table></figure><h4 id="4-现在schema已经够多了，但是用户连接到PostgreSQL的时候，默认只会去-user跟public这两个schema去寻找表，如果要访问别的schema还要在用到的时候采用schema-table的方式。这点在配置文件postgresql-conf中也可以看到"><a href="#4-现在schema已经够多了，但是用户连接到PostgreSQL的时候，默认只会去-user跟public这两个schema去寻找表，如果要访问别的schema还要在用到的时候采用schema-table的方式。这点在配置文件postgresql-conf中也可以看到" class="headerlink" title="4.现在schema已经够多了，但是用户连接到PostgreSQL的时候，默认只会去$user跟public这两个schema去寻找表，如果要访问别的schema还要在用到的时候采用schema.table的方式。这点在配置文件postgresql.conf中也可以看到"></a>4.现在<code>schema</code>已经够多了，但是用户连接到<code>PostgreSQL</code>的时候，默认只会去<code>$user</code>跟<code>public</code>这两个<code>schema</code>去寻找表，如果要访问别的<code>schema</code>还要在用到的时候采用<code>schema.table</code>的方式。这点在配置文件<code>postgresql.conf</code>中也可以看到</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">search_path = <span class="string">'"$user", public'</span>        <span class="comment"># schema names</span></span></span><br></pre></td></tr></table></figure><p>聪明的你已经猜到，只需要修改配置文件中的这个<code>search_path</code>，就可以让用户访问表的时候不必带上<code>schema</code>。<br>但是我倒不建议这么做。因为这个配置文件是全局的。我们可能会有多个<code>database</code>运行于此，而他们有着不相干的<code>schema</code>，都写在这个配置文件里面显然不合适。我们应该通过下面的方式设置<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="string">"your_database"</span> <span class="keyword">set</span> search_path = metadata_schema,metadata_schema,platform_schema,<span class="keyword">public</span>;</span><br></pre></td></tr></table></figure></p><p>这样就可以精确到对一个库设置它的默认<code>search_path</code>了。设置完毕后，重新建立数据库连接，执行<code>show search_path;</code>可以查看设置结果。<br>除了上面通过<code>alter database</code>之外，<code>alter role</code>也能起到类似的效果，还靠小伙伴们自行发掘了。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ssh连接保活，mosh初体验</title>
      <link href="/2018/08/25/mosh/"/>
      <url>/2018/08/25/mosh/</url>
      <content type="html"><![CDATA[<p>传统的<code>ssh</code>最恼人的就是放着不动，没多久就丢了。有时候<code>tail -f</code>跟踪一个日志，一会日志没动静，可能<code>ssh</code>就已经阵亡了，而我还没反应过来，还琢磨着日志该出来了。烦。<br>前两天研究<code>iTerm2</code>的时候，看到有人分享<code>mosh</code>的相关知识，提到它最大的优点就是<code>ssh</code>保活。马上决定一试。</p><ol><li><p>服务端安装</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> mosh</span><br></pre></td></tr></table></figure></li><li><p>防火墙放行端口，端口从<code>60000</code>排队起步，根据同时可能产生的连接数量，适当放行几个就好</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=60000-60010/udp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>客户端同样安装<code>mosh</code></p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>mosh</span><br></pre></td></tr></table></figure></li><li><p>客户端使用</p> <figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">mosh -ssh=<span class="string">"ssh -p 3322"</span> root@<span class="number">192.168</span><span class="number">.0</span><span class="number">.88</span></span><br></pre></td></tr></table></figure><p> 上面的<code>-ssh</code>命令主要是用在<code>ssh</code>端口不是开在<code>22</code>的情况下，需要指定端口。因为<code>mosh</code>自己的<code>-p</code>是指的<code>mosh</code>自身要用的<code>udp</code>端口。<br> 另外，如果你维护了<code>～/.ssh/config</code>文件的话，那么恭喜你，<code>mosh</code>可以直接读取这个<code>config</code>，也就是说，之前<code>ssh a_server</code>可以无缝替换成<code>mosh a_server</code></p></li><li><p>排错，如果遇到客户端访问不了服务器，并且有如下提示</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">locale: Cannot <span class="builtin-name">set</span> LC_CTYPE <span class="keyword">to</span><span class="built_in"> default </span>locale: <span class="literal">No</span> such file <span class="keyword">or</span> directory</span><br><span class="line">locale: Cannot <span class="builtin-name">set</span> LC_ALL <span class="keyword">to</span><span class="built_in"> default </span>locale: <span class="literal">No</span> such file <span class="keyword">or</span> directory</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">Connection <span class="keyword">to</span> xxx.xxx.xxx.xxx closed.</span><br><span class="line">/usr/local/bin/mosh: Did <span class="keyword">not</span> <span class="builtin-name">find</span> mosh<span class="built_in"> server </span>startup message. (Have you installed mosh on your server?)</span><br></pre></td></tr></table></figure><p> 可以尝试在服务器上的<code>~/.bashrc</code>文件追加这两行解决</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">LANG</span>=en_US.UTF-8</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">LC_ALL</span>=en_US.UTF-8</span><br></pre></td></tr></table></figure></li><li><p>最后说下实际体验感受<br> 的确大大延长了<code>ssh</code>的可用时间，但是像网上说的能坚持个个把月，很遗憾我并没有那么幸运，不过<code>mosh</code>仍然是个值得推荐的工具。</p></li></ol>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Javalin又一个小而美的Java Web框架</title>
      <link href="/2018/08/24/javalin/"/>
      <url>/2018/08/24/javalin/</url>
      <content type="html"><![CDATA[<p><code>Javalin</code>是<code>JVM</code>平台下一个上手极为容易的<code>Web</code>框架。有这么几个显著的特点：</p><ol><li>简单便捷，不论是概念上还是真正上手开发，给人的感觉就是轻松写意</li><li>灵活，可以兼容同步和异步两种编程思路</li><li>小，即使是打成一个可以独立运行的<code>fat-jar</code>，大小才<code>4～5M</code>，就算把常用的<code>log</code>、<code>jdbc</code>等常用库放进去，估计也到不了<code>10M</code></li></ol><p>官方支持的语言是<code>Java</code>和<code>Kotlin</code>，当然还有跟<code>Java</code>无缝兼容的<code>Groovy</code>，这个相当于买一赠一了。下面我们直接看一下<code>Kotlin</code>简单demo<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> con.aruistar.studyjavalin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.javalin.Javalin</span><br><span class="line"></span><br><span class="line"><span class="function">data class <span class="title">User</span><span class="params">(val name: String, val id: Int)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">    val app = Javalin.create().start(<span class="number">7000</span>)</span><br><span class="line"></span><br><span class="line">    val map = hashMapOf&lt;String, Int&gt;()</span><br><span class="line">    map.put(<span class="string">"one"</span>, <span class="number">1</span>)</span><br><span class="line">    map.put(<span class="string">"two"</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    app.get(<span class="string">"/"</span>) &#123; ctx -&gt; ctx.result(<span class="string">"Hello World"</span>) &#125;</span><br><span class="line">    app.get(<span class="string">"/json"</span>) &#123; ctx -&gt; ctx.json(User(<span class="string">"Alex"</span>, <span class="number">1</span>)) &#125;</span><br><span class="line">    app.get(<span class="string">"/json/map"</span>) &#123; ctx -&gt; ctx.json(map) &#125;</span><br><span class="line">    app.after &#123; ctx -&gt;</span><br><span class="line">        println(<span class="string">"log"</span>)</span><br><span class="line">        println(ctx.resultString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有没有一种简单到没朋友的感觉，我想这段代码我不多解释，大家也都看得懂。其他特性还有很多，这里我从文档上摘录几个比较实用的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">get(<span class="string">"/hello/*/and/*"</span>, ctx -&gt; &#123;</span><br><span class="line">    ctx.result(<span class="string">"Hello: "</span> + ctx.splat(<span class="number">0</span>) + <span class="string">" and "</span> + ctx.splat(<span class="number">1</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">app.routes(() -&gt; &#123;</span><br><span class="line">    path(<span class="string">"users"</span>, () -&gt; &#123;</span><br><span class="line">        get(UserController::getAllUsers);</span><br><span class="line">        post(UserController::createUser);</span><br><span class="line">        path(<span class="string">":id"</span>, () -&gt; &#123;</span><br><span class="line">            get(UserController::getUser);</span><br><span class="line">            patch(UserController::updateUser);</span><br><span class="line">            delete(UserController::deleteUser);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">app.exception(NullPointerException.class, (e, ctx) -&gt; &#123;</span><br><span class="line">    <span class="comment">// handle nullpointers here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">app.error(<span class="number">404</span>, ctx -&gt; &#123;</span><br><span class="line">    ctx.result(<span class="string">"Generic 404 message"</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更多功能请查看官方文档<a href="https://javalin.io/documentation" target="_blank" rel="noopener">javalin</a></p><h3 id="最后说一下我个人对这个框架的一些看法"><a href="#最后说一下我个人对这个框架的一些看法" class="headerlink" title="最后说一下我个人对这个框架的一些看法"></a>最后说一下我个人对这个框架的一些看法</h3><p>如果你是个<code>Java</code>程序员，还从来没有用过<code>Spring</code>以外的<code>WEB</code>框架，那我推荐你试试<code>Javalin</code>；但如果你是站在公司立场，要为下一个项目做技术选型的话，我更建议你用经受过多年市场考验的<a href="http://vertx.io" target="_blank" rel="noopener">Vert.x</a>。<br>如果你的项目中已经用过<a href="http://sparkjava.com" target="_blank" rel="noopener">SparkJava</a>了，那我觉得<code>Javalin</code>应该也在你的备选技术清单里。<br>如果你是<code>node.js</code>程序员，想涉猎一下<code>Java</code>方面的开发，<code>Javalin</code>可能是个不错的尝试，因为从中你能找到<code>koa</code>的影子，我想你会觉得无比亲切。</p><hr><p>本文demo已上传至<a href="https://github.com/aruis/studyjavalin" target="_blank" rel="noopener">https://github.com/aruis/studyjavalin</a></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一个因为JDBC及PostgreSQL过于优秀而导致的坑</title>
      <link href="/2018/08/23/defect_jdbc_postgresql/"/>
      <url>/2018/08/23/defect_jdbc_postgresql/</url>
      <content type="html"><![CDATA[<p>假设存在这么一张表，记录全国各地大学的名称，以及所处的行政区划<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 大学信息表</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">varchar</span> <span class="keyword">DEFAULT</span> uuid_generate_v4() PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    v_name <span class="built_in">varchar</span>,</span><br><span class="line">    v_所处行政区划代码 <span class="built_in">varchar</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>其中，行政区划是国家标准的，也就是你身份证开头的6位，能够精确到区、县的。两位一个级别，前六位，可以笼统的概括成，省及、市级、县级，当然还有直辖市、特别行政区什么的，先不必深究，暂且简化这个逻辑就好了。<br>现在问题来了，如果想统计各省份大学的数量，是不是该用这条<code>SQL</code><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">left</span>(v_所处行政区划代码, <span class="number">2</span>), <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">from</span> 大学信息表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">left</span>(v_所处行政区划代码, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>对需求敏感的小伙伴肯定看出来了，上面的<code>2</code>在设计接口的时候应该设计成参数，万一要统计各城市的大学数量，直接传<code>4</code>不就好了。<br>所以在<code>Java</code>中，我们大约会写这么一段代码<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PreparedStatement pstmt = conn.prepareStatement("""</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">left</span>(v_所处行政区划代码, ?), <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">from</span> 大学信息表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">left</span>(v_所处行政区划代码, ?);</span><br><span class="line">""");</span><br><span class="line"></span><br><span class="line">pstmt.setInt(1, 2);</span><br><span class="line">pstmt.setInt(2, 2);</span><br></pre></td></tr></table></figure></p><p>就是用两处<code>?</code>占位，然后传入相同的参数。<strong>可惜事与愿违，这段<code>SQL</code>一定是报错的</strong>，会有提示<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">column "大学信息表.v_所处行政区划代码" must appear in the GROUP BY clause or be used in an aggregate function</span><br></pre></td></tr></table></figure></p><p>简单的说，数据库不认为<code>select</code>中的<code>left(v_所处行政区划代码, ?)</code>跟<code>group by</code>中的<code>left(v_所处行政区划代码, ?)</code>是一个东西，所以认为我们在查询了一个没有<code>group by</code>也没有聚合函数的数据，属于<code>SQL</code>语法错误。<br>下面尝试分析原因：</p><ol><li>原始<code>SQL</code>在<code>PostgreSQL</code>中独立执行，完全没问题，所以肯定不是<code>PostgreSQL</code>的问题</li><li>用<code>Python</code>（<code>psycopg2</code>）实现了同样的逻辑，然而没有报错，所以还得从<code>JDBC</code>+<code>PostgreSQL</code>上找原因</li><li><p>去数据库服务器看日志，发现问题，当<code>JDBC</code>请求的时候，后台日志是</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">STATEMENT:</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">left</span>(v_所处行政区划代码, $<span class="number">1</span>), <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">from</span> 大学信息表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">left</span>(v_所处行政区划代码, $<span class="number">2</span>)</span><br><span class="line">DETAIL:  <span class="keyword">parameters</span>: $<span class="number">1</span> = <span class="string">'2'</span>, $<span class="number">2</span> = <span class="string">'2'</span></span><br></pre></td></tr></table></figure><p> 而当<code>Python</code>请求时，后台日志是</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">left</span>(v_所处行政区划代码, <span class="number">2</span>), <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">from</span> 大学信息表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">left</span>(v_所处行政区划代码, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p> 是不是有一种见了鬼的感觉，</p></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在使用<code>JDBC</code>操作<code>PostgreSQL</code>时，<code>JAVA</code>中的<code>prepareStatement</code>会精准换算成<code>PostgreSQL</code>中的<a href="http://www.postgres.cn/docs/10/sql-prepare.html" target="_blank" rel="noopener">PREPARE</a>，而在<code>PREPARE</code>的时候，参数还没给出，所以<code>PostgreSQL</code>会认为<code>select</code>的<code>left(v_所处行政区划代码, $1)</code>并未参与<code>group by</code>，因而<code>PREPARE</code>报错，导致最终<code>SQL</code>执行失败。<br>而在<code>psycopg2</code>+<code>PostgreSQL</code>的环境中，并没有像<code>JDBC</code>那样充分利用<code>PostgreSQL</code>的<code>PREPARE</code>特性，而是在程序侧就换算好了<code>SQL</code>语句，所以反而不会报错。<br><em>显然，是<code>JDBC</code>的设计更细致，但是却给自己挖了个坑</em></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL打开SQL日志</title>
      <link href="/2018/08/22/PostgreSQL_show_SQL_logs/"/>
      <url>/2018/08/22/PostgreSQL_show_SQL_logs/</url>
      <content type="html"><![CDATA[<p>找到<code>PostgreSQL</code>安装目录所在的地方，编辑配置文件<code>postgresql.conf</code><br>确保<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log_destination</span> = <span class="string">'stderr'</span></span><br></pre></td></tr></table></figure></p><p>这样可以打开日志功能<br>然后找到<code>atement</code>设置成<code>all</code><br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log_statement</span> = <span class="string">'all'</span></span><br></pre></td></tr></table></figure></p><p>重启服务之后就可以跟踪到所有的<code>SQL</code>语句了。</p><p>当然其他还有很多配置，可以进行更细致的定制，可以参考官方文档<a href="http://www.postgres.cn/docs/10/runtime-config-logging.html" target="_blank" rel="noopener">错误报告和日志</a></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>groovy中的正则使用</title>
      <link href="/2018/08/21/groovy_regular/"/>
      <url>/2018/08/21/groovy_regular/</url>
      <content type="html"><![CDATA[<h4 id="判断是否与正则匹配"><a href="#判断是否与正则匹配" class="headerlink" title="判断是否与正则匹配"></a>判断是否与正则匹配</h4><figure class="highlight flix"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">res</span> </span>= <span class="string">"522300000000"</span> ==~ /\d*<span class="number">0</span>&#123;<span class="number">8</span>&#125;$/</span><br><span class="line"><span class="comment">// res is true</span></span><br></pre></td></tr></table></figure><h4 id="从字符串中找到匹配的内容"><a href="#从字符串中找到匹配的内容" class="headerlink" title="从字符串中找到匹配的内容"></a>从字符串中找到匹配的内容</h4><figure class="highlight flix"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">res</span> </span>= <span class="string">"hello110,world"</span> =~ /\d+/</span><br><span class="line">println(res[<span class="number">0</span>])</span><br><span class="line"><span class="comment">//res[0] is 110</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>黔西南州兴义市马岭河峡谷半日游</title>
      <link href="/2018/08/20/xingyi-malinghe/"/>
      <url>/2018/08/20/xingyi-malinghe/</url>
      <content type="html"><![CDATA[<p>最近在贵州出差，一个小城市，兴义市，隶属于黔西南布依族苗族自治州。周末去了趟当地的景点——马岭河峡谷，感觉不错，几处瀑布意境各不相同。随手拍了几张照片，聊作纪念。<br><img src="/media/IMG_7384.jpg" alt=""><br><img src="/media/IMG_7284.jpg" alt=""><br><img src="/media/IMG_7350.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux防火墙常用命令</title>
      <link href="/2018/08/19/Linux_firewall-cmd/"/>
      <url>/2018/08/19/Linux_firewall-cmd/</url>
      <content type="html"><![CDATA[<ol><li><p>安装防火墙</p> <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> firewalld</span><br></pre></td></tr></table></figure></li><li><p>永久放行端口</p> <figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">firewall</span><span class="literal">-</span><span class="comment">cmd</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">add</span><span class="literal">-</span><span class="comment">port=54321/tcp</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">permanent</span></span><br></pre></td></tr></table></figure><p> <em>临时的话，把–permanent去掉</em></p></li><li><p>使配置生效</p> <figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --reload</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>移除放行端口 <figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">firewall</span><span class="literal">-</span><span class="comment">cmd</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">remove</span><span class="literal">-</span><span class="comment">port=54321/tcp</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">permanent</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li>查看所有放行端口 <figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --list-ports</span></span><br></pre></td></tr></table></figure></li></ol><p>这里只列出最简单的一些用法，更多高阶用法请查看官方文档：<a href="https://firewalld.org/documentation/man-pages/firewall-cmd.html" target="_blank" rel="noopener">https://firewalld.org/documentation/man-pages/firewall-cmd.html</a>    </p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>免开发环境在GitHub站点上快速给开源项目贡献代码</title>
      <link href="/2018/08/18/github-pull-request/"/>
      <url>/2018/08/18/github-pull-request/</url>
      <content type="html"><![CDATA[<p>给开源项目贡献代码应该算是进阶程序员的一条必经之路。今天我就简单介绍一下，如何在不clone代码，不使用本地开发环境的情况下，给GitHub上的开源项目贡献代码。<br>还没有GitHub账号的小伙伴，就抓紧注册个吧，其他就没有任何必要条件了。</p><h3 id="第一步，发现问题"><a href="#第一步，发现问题" class="headerlink" title="第一步，发现问题"></a>第一步，发现问题</h3><p>这个我可教不了，只能介绍一下我自己的经验，就是多看，多想。比如我今天举例的就是<code>JVM</code>下知名项目<code>Vert.x</code>，官方维护的<a href="https://github.com/vert-x3/vertx-examples" target="_blank" rel="noopener">vertx-examples</a>，我发现他在介绍<code>gradle-redeploy</code>的时候，其中<code>build.gradle</code>有一段写得就不够严谨，他是这么写的：</p><figure class="highlight flix"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vert.x will call this task on changes</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doOnChange</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> </span>(System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"windows"</span>)) &#123;</span><br><span class="line">  doOnChange = '.\\gradlew classes'</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doOnChange = './gradlew classes'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过我之前博客的小伙伴应该知道，操作系统的文件分割符，<code>Java</code>中是提供静态方法等多种方式来获取的，不需要通过自己手动判断操作系统的名字来自己实现。所以我决定把这段代码优化一下。也就是这篇博客的起因。</p><h3 id="第二步，Fork代码"><a href="#第二步，Fork代码" class="headerlink" title="第二步，Fork代码"></a>第二步，<code>Fork</code>代码</h3><p>点这里即可：<br><img src="/media/%E7%B2%98%E8%B4%B4%E7%9A%84%E5%9B%BE%E7%89%872018_8_18_14_23.png" alt=""><br><code>Fork</code>成功之后，会自动进入到自己命名空间下的项目<br><img src="/media/15345735455740.jpg" alt=""></p><h3 id="第三步，创建分支"><a href="#第三步，创建分支" class="headerlink" title="第三步，创建分支"></a>第三步，创建分支</h3><p><code>GitHub</code>上的<code>Pull Request</code>都是基于分支的，也就是说想要贡献代码，要先创建一个分支，在上面承载你的代码变更。其实做起来也相当简单，如图：<img src="/media/%E7%B2%98%E8%B4%B4%E7%9A%84%E5%9B%BE%E7%89%872018_8_18_14_28.png" alt=""></p><h3 id="第四步，修改代码"><a href="#第四步，修改代码" class="headerlink" title="第四步，修改代码"></a>第四步，修改代码</h3><p>之后就会进入到自己新建的分支，找到要修改的代码后，点编辑按钮，如图<img src="/media/%E7%B2%98%E8%B4%B4%E7%9A%84%E5%9B%BE%E7%89%872018_8_18_14_32.png" alt=""></p><p>把我之前说的代码改成：</p><figure class="highlight flix"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doOnChange</span> </span>= <span class="string">".$&#123;File.separator&#125;gradlew classes"</span></span><br></pre></td></tr></table></figure><p>一行搞定，是不是简单多了。<br>编辑完代码后，在屏幕最下方，提交代码，注意要写一个理由充分的提交注释，证明你改变代码的必要性<br><img src="/media/15345741245811.jpg" alt=""></p><h3 id="第五步，发起Pull-Request"><a href="#第五步，发起Pull-Request" class="headerlink" title="第五步，发起Pull Request"></a>第五步，发起<code>Pull Request</code></h3><p>把修改<code>commit</code>之后，回到自己的项目首页，就可以看到一句提示，问你要不要把刚修改的那个分支去跟原始项目比较，并且发起<code>pull request</code>，如图<img src="/media/%E7%B2%98%E8%B4%B4%E7%9A%84%E5%9B%BE%E7%89%872018_8_18_14_39.png" alt=""></p><p>点击这个按钮后，进入最后的<code>Open a pull request</code>界面，再次要把提交说明写到位，就可以点<code>Create pull request</code>按钮正式发起贡献代码请求了。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>基本开源项目都有自动化的代码审查，比如单元测试、格式规范检查之类的，发起<code>PR</code>之后也要留意观看，万一发现自己代码有问题，还可以继续更改</li><li>之后还回到自己分支，产生的更改，就不用重新发起<code>PR</code>了，只要<code>commit</code>之后，之前的<code>PR</code>可以直接看到</li><li>一旦<code>PR</code>成功，就可以在原始项目的<code>contributors</code>中找到自己的账户了。希望你到时候可以榜上有名；）</li></ol>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中实现更新默认值（二）</title>
      <link href="/2018/08/17/PostgreSQL_auto_modify_defaults_2/"/>
      <url>/2018/08/17/PostgreSQL_auto_modify_defaults_2/</url>
      <content type="html"><![CDATA[<p>今天我们用<code>表继承</code>+<code>触发器</code>的方案，来实现表中的更新默认值。这也许是<code>PostgreSQL</code>里最佳的解决方案。</p><h4 id="一-创建一张表，作为父表"><a href="#一-创建一张表，作为父表" class="headerlink" title="一. 创建一张表，作为父表"></a>一. 创建一张表，作为父表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> basic_update</span><br><span class="line">(</span><br><span class="line">  t_update <span class="keyword">timestamp</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="二-创建一个函数，用作最后负责修改t-update使用"><a href="#二-创建一个函数，用作最后负责修改t-update使用" class="headerlink" title="二. 创建一个函数，用作最后负责修改t_update使用"></a>二. 创建一个函数，用作最后负责修改<code>t_update</code>使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> update_modified_column()</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  NEW.t_update = <span class="keyword">now</span>();</span><br><span class="line">  RETURN NEW;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$</span><br><span class="line">language 'plpgsql';</span><br></pre></td></tr></table></figure><h4 id="三-创建一个函数，用来给继承了basic-update的表新增一个触发器，怼上第二步的函数"><a href="#三-创建一个函数，用来给继承了basic-update的表新增一个触发器，怼上第二步的函数" class="headerlink" title="三. 创建一个函数，用来给继承了basic_update的表新增一个触发器，怼上第二步的函数"></a>三. 创建一个函数，用来给继承了<code>basic_update</code>的表新增一个触发器，怼上第二步的函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> table_create()</span><br><span class="line">  <span class="keyword">returns</span> event_trigger</span><br><span class="line"><span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">oid</span>           <span class="built_in">INT</span>;</span><br><span class="line">        table_name    VARCHAR;</span><br><span class="line">        parent_tables VARCHAR [];</span><br><span class="line">        is_update     BOOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> object_identity</span><br><span class="line">      <span class="keyword">INTO</span> table_name <span class="keyword">FROM</span> pg_event_trigger_ddl_commands();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> objid</span><br><span class="line">      <span class="keyword">INTO</span> <span class="keyword">oid</span> <span class="keyword">FROM</span> pg_event_trigger_ddl_commands();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> get_parent_tables_by_oid(<span class="keyword">oid</span>)</span><br><span class="line">      <span class="keyword">INTO</span> parent_tables;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> parent_tables :: <span class="built_in">TEXT</span> [] @&gt; <span class="string">'&#123;basic_update&#125;'</span> :: <span class="built_in">TEXT</span> []</span><br><span class="line">      <span class="keyword">INTO</span> is_update;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  IF is_update</span><br><span class="line"></span><br><span class="line">  THEN</span><br><span class="line">    <span class="keyword">EXECUTE</span> <span class="string">'CREATE TRIGGER tgr_auto_t_update'</span></span><br><span class="line">            || <span class="string">' BEFORE UPDATE ON  '</span></span><br><span class="line">            || table_name</span><br><span class="line">            || <span class="string">' FOR EACH ROW EXECUTE PROCEDURE update_modified_column()'</span>;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h4 id="四-创建一个建表时的触发器，接管创建表的时机，怼上第三步的函数"><a href="#四-创建一个建表时的触发器，接管创建表的时机，怼上第三步的函数" class="headerlink" title="四. 创建一个建表时的触发器，接管创建表的时机，怼上第三步的函数"></a>四. 创建一个建表时的触发器，接管创建表的时机，怼上第三步的函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EVENT</span> <span class="keyword">TRIGGER</span> etgr_table_create</span><br><span class="line"><span class="keyword">ON</span> ddl_command_end</span><br><span class="line"><span class="keyword">WHEN</span> TAG <span class="keyword">IN</span> (<span class="string">'CREATE TABLE'</span>)</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> table_create();</span><br></pre></td></tr></table></figure><h4 id="五-所有操作已经完成，可以创建一个表测试了"><a href="#五-所有操作已经完成，可以创建一个表测试了" class="headerlink" title="五. 所有操作已经完成，可以创建一个表测试了"></a>五. 所有操作已经完成，可以创建一个表测试了</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">id</span>        <span class="built_in">varchar</span> <span class="keyword">default</span> uuid_generate_v4() <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">constraint</span> test_pkey</span><br><span class="line">    primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="built_in">text</span>      <span class="built_in">varchar</span>,</span><br><span class="line">  t_create  <span class="keyword">timestamp</span> <span class="keyword">default</span> <span class="keyword">now</span>()</span><br><span class="line">)</span><br><span class="line">  inherits (basic_update);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> (<span class="built_in">text</span>)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">text</span> = <span class="string">'b'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中实现更新默认值（一）</title>
      <link href="/2018/08/16/PostgreSQL_auto_modify_defaults_1/"/>
      <url>/2018/08/16/PostgreSQL_auto_modify_defaults_1/</url>
      <content type="html"><![CDATA[<p>业务系统中，经常会在设计表的时候，考虑这两个字段：新增时间、修改时间。前者用数据库的基础功能即可实现，后者就要采取一些手段了。<br>在<code>PostgreSQL</code>中的最佳实践是采用触发器，捕捉<code>UPDATE</code>实践，虽然听起来很可怕，但其实并不难。</p><ol><li><p>首先创建一个函数，作用就是给一行数据，追加某个值（这里我用的字段名是<code>t_update</code>）</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> update_modified_column()</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  NEW.t_update = <span class="keyword">now</span>();</span><br><span class="line">  RETURN NEW;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$</span><br><span class="line">language 'plpgsql';</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>然后就是把这个函数怼到触发器上</p> <figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TRIGGER tgr_auto_t_update</span><br><span class="line">  BEFORE UPDATE</span><br><span class="line">  <span class="keyword">ON</span> a_table</span><br><span class="line">  <span class="keyword">FOR</span> <span class="keyword">EACH</span> ROW EXECUTE <span class="function"><span class="keyword">PROCEDURE</span> <span class="title">update_modified_column</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li></ol><p>这样就大功告成了。但是如果有很多表的话，感觉还是有重复劳动，不够优雅。明天我将结合昨天提到的表继承，最大化的减少工作量，用更优雅的方法实现更新默认值的功能。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中用递归CTE获取一张表的所有祖先表</title>
      <link href="/2018/08/15/PostgreSQL_with_recursive/"/>
      <url>/2018/08/15/PostgreSQL_with_recursive/</url>
      <content type="html"><![CDATA[<p>今天介绍两个知识点：</p><ol><li>PostgreSQL的表继承</li><li>PostgreSQL中的可递归CTE</li></ol><h3 id="表继承"><a href="#表继承" class="headerlink" title="表继承"></a>表继承</h3><p>表继承是PostgreSQL独有的功能，就是在<code>create table</code>的时候可以通过<code>inherits</code>关键字指定若干个父表，如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">id</span>       <span class="built_in">varchar</span> <span class="keyword">default</span> uuid_generate_v4() <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">constraint</span> test_pkey</span><br><span class="line">    primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="built_in">text</span>     <span class="built_in">varchar</span>,</span><br><span class="line">  t_create <span class="keyword">timestamp</span> <span class="keyword">default</span> <span class="keyword">now</span>()</span><br><span class="line">)</span><br><span class="line">  inherits (basic_update);</span><br></pre></td></tr></table></figure><p>继承父表，有如下几个特性：</p><ul><li>父表的字段会自动加入子表中来</li><li>父表上的所有检查约束和非空约束都将自动被它的后代所继承， 除非使用 NO INHERIT子句明确指定。其他类型的约束（唯一、主键和外键约束）则不会被继承</li><li>插入子表的数据，在父表中默认是可以查询到的，除非在对父表查询时，表名前加入<code>only</code>修饰符</li></ul><h3 id="递归CTE"><a href="#递归CTE" class="headerlink" title="递归CTE"></a>递归CTE</h3><p>可选的RECURSIVE修饰符将WITH从单纯的句法便利变成了一种在标准SQL中不能完成的特性。通过使用RECURSIVE，一个WITH查询可以引用它自己的输出。一个非常简单的例子是计算从1到100的整数合的查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">WITH RECURSIVE t(n) AS (</span><br><span class="line">    VALUES (1)</span><br><span class="line">  UNION ALL</span><br><span class="line">    <span class="keyword">SELECT</span> n+<span class="number">1</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> n &lt; <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span>(n) <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure><h3 id="回到今天的主题，PostgreSQL中用递归CTE获取一张表的所有祖先表"><a href="#回到今天的主题，PostgreSQL中用递归CTE获取一张表的所有祖先表" class="headerlink" title="回到今天的主题，PostgreSQL中用递归CTE获取一张表的所有祖先表"></a>回到今天的主题，PostgreSQL中用递归CTE获取一张表的所有祖先表</h3><p>这里我直接通过创建一个函数来封装这个功能，具体逻辑就在函数中，相信有前面两个知识点的铺垫，小伙伴们应该也能看懂了</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> get_parent_tables_by_oid(me <span class="built_in">integer</span>)</span><br><span class="line">  <span class="keyword">returns</span> <span class="built_in">character</span> <span class="built_in">varying</span> []</span><br><span class="line"><span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span> parent_tables <span class="built_in">VARCHAR</span> [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> x <span class="keyword">AS</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> pg_inherits <span class="keyword">WHERE</span> inhrelid = me</span><br><span class="line"></span><br><span class="line">      <span class="keyword">UNION</span> ALL</span><br><span class="line"></span><br><span class="line">      <span class="keyword">SELECT</span> pg_inherits.* <span class="keyword">FROM</span> x</span><br><span class="line">                                  <span class="keyword">JOIN</span> pg_inherits <span class="keyword">ON</span> x.inhparent = pg_inherits.inhrelid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> array_agg(pg_stat_user_tables.relname)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">INTO</span> parent_tables</span><br><span class="line"></span><br><span class="line">  <span class="keyword">FROM</span> x</span><br><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> pg_stat_user_tables <span class="keyword">ON</span> x.inhparent = pg_stat_user_tables.relid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  RETURN parent_tables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$$;</span><br></pre></td></tr></table></figure><p>其中<code>inhrelid</code>是<code>PostgreSQL</code>中的一种元数据，可以理解成表的<code>id</code>，在知道表名的情况下怎么知道它的<code>id</code>呢，可以去元数据里面查，如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> relid <span class="keyword">FROM</span> pg_stat_user_tables <span class="keyword">WHERE</span> relname = <span class="string">'a_table'</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vert.x项目监测代码变化自动冷重启</title>
      <link href="/2018/08/14/Vert-x_redeploy/"/>
      <url>/2018/08/14/Vert-x_redeploy/</url>
      <content type="html"><![CDATA[<p>传统的Java Web开发一般都会提供热重载的方式，方便开发人员在代码发生变化的时候，无需手动重启应用，就可以刷新到效果。用惯了的人，在用<code>Vert.x</code>开发的时候多少会有点不习惯，不过<code>Vert.x</code>程序启动速度还是很可观的，所以也勉强能忍。<br>后来通读文档的时候，发现有个关于<code>redeploy</code>的介绍，似乎能用，又似乎不好用的，直到看到官方的<a href="https://github.com/vert-x3/vertx-examples/tree/master/gradle-redeploy" target="_blank" rel="noopener">Vert.x 3.2 Gradle redeploy project</a>总算豁然开朗了。<br>核心代码无非下面几行<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">// Vert.<span class="keyword">x</span> watches <span class="keyword">for</span> <span class="keyword">file</span> <span class="keyword">changes</span> in <span class="keyword">all</span> subdirectories</span><br><span class="line">// of src/ but <span class="keyword">only</span> <span class="keyword">for</span> <span class="keyword">files</span> with .java extension</span><br><span class="line">def watchForChange = <span class="string">'src/**/*.java'</span></span><br><span class="line"></span><br><span class="line">// Vert.<span class="keyword">x</span> will <span class="keyword">call</span> this task <span class="keyword">on</span> <span class="keyword">changes</span></span><br><span class="line">def doOnChange</span><br><span class="line"><span class="keyword">if</span> (System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"windows"</span>)) &#123;</span><br><span class="line">  doOnChange = <span class="string">'.\\gradlew classes'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doOnChange = <span class="string">'./gradlew classes'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &#123;</span><br><span class="line">  <span class="keyword">args</span> = [<span class="string">'run'</span>, mainVerticleName, <span class="string">"--redeploy=$watchForChange"</span>, <span class="string">"--launcher-class=$mainClassName"</span>, <span class="string">"--on-redeploy=$doOnChange"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我也尝试了一下，的确可用，但是这个官方示例还是有个地方写的不好，就是关于文件分割符的判断，恰好这个在我之前的帖子里面提到过，见<a href="https://www.kankanzhijian.com/2018/07/26separator_in_java/">编写跨操作系统Java代码时动态获取文件分隔符</a><br>所以上面的<code>gradle</code>代码关于<code>doOnChange</code>声明就可以简化成下面的样子了<br><figure class="highlight flix"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doOnChange</span> </span>= <span class="string">".$&#123;File.separator&#125;gradlew classes"</span></span><br></pre></td></tr></table></figure></p><p>测试成功</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>家长的责任及义务</title>
      <link href="/2018/08/13/Parental_responsibilities_and_obligations/"/>
      <url>/2018/08/13/Parental_responsibilities_and_obligations/</url>
      <content type="html"><![CDATA[<h2 id="身为家长，到底能为孩子做些什么，什么又是最重要的呢"><a href="#身为家长，到底能为孩子做些什么，什么又是最重要的呢" class="headerlink" title="身为家长，到底能为孩子做些什么，什么又是最重要的呢"></a>身为家长，到底能为孩子做些什么，什么又是最重要的呢</h2><h3 id="我认为按重要程度，依次有这几点"><a href="#我认为按重要程度，依次有这几点" class="headerlink" title="我认为按重要程度，依次有这几点"></a>我认为按重要程度，依次有这几点</h3><ol><li>和睦温馨的家庭氛围</li><li>不论工作、学习如何辛苦，始终不忘身体健康是第一要务</li><li>活到老学到老的人生态度</li><li>能够支持孩子从事学习活动的经济基础</li></ol>]]></content>
      
      <categories>
          
          <category> 文艺中年 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教育子女 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分享一个Vert.x的自定义Launcher</title>
      <link href="/2018/08/12/my_luancher_in_vertx/"/>
      <url>/2018/08/12/my_luancher_in_vertx/</url>
      <content type="html"><![CDATA[<p>在<code>Vert.x</code>的官方example中，<code>mainClassName</code>一般是指定的<code>io.vertx.core.Launcher</code>，但是在实际应用中，如果我们也不加思索的用这个<code>Launcher</code>就会损失好多定制性，比如：</p><ul><li>blockedThreadCheckInterval（检查线程block定时时间间隔）</li><li>warningExceptionTime（block多久后开始打印堆栈信息）</li><li>maxEventLoopExecuteTime（允许<code>EventLoop</code>的最长执行时间）</li></ul><p>这些设置都是要在<code>Vertx</code>实例化之前准备好的，只要不是Embedded应用（也就是自己调用<code>Vertx.vertx()</code>），那就只剩接管<code>Launcher</code>这条路了，下面分享一个<code>groovy</code>版的自定义<code>Launcher</code></p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.vertx.core.Launcher</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.VertxOptions</span><br><span class="line"><span class="keyword">import</span> org.slf4j.bridge.SLF4JBridgeHandler</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">AruisLauncher</span> extends <span class="type">Launcher</span> &#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    static &#123;</span></span><br><span class="line"><span class="class">        <span class="type">SLF4JBridgeHandler</span>.removeHandlersForRootLogger();</span></span><br><span class="line"><span class="class">        <span class="type">SLF4JBridgeHandler</span>.install();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    static void main(<span class="type">String</span>[] <span class="title">args</span>) &#123;</span></span><br><span class="line"><span class="class">        new <span class="type">AruisLauncher</span>().dispatch(<span class="title">args</span>)</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    @<span class="type">Override</span></span></span><br><span class="line"><span class="class">    void beforeStartingVertx(<span class="type">VertxOptions</span> <span class="title">options</span>) &#123;</span></span><br><span class="line"><span class="class">        options.setWarningExceptionTime(10L * 1000 * 1000000)</span></span><br><span class="line"><span class="class">        options.setBlockedThreadCheckInterval(2000)</span></span><br><span class="line"><span class="class">        options.setMaxEventLoopExecuteTime(2L * 1000 * 1000000)</span></span><br><span class="line"><span class="class">        options.workerPoolSize = 20</span></span><br><span class="line"><span class="class">        super.beforeStartingVertx(<span class="title">options</span>)</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>在这个<code>Launcher</code>中，我还额外做了几件事：</p><ul><li>用<code>slf4j</code>接管了<code>Vert.x</code>的日志</li><li>提供一个<code>main</code>方法，方便<code>IDE</code>开发环境启动</li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用pg_cron定时刷新PostgreSQL的物化视图</title>
      <link href="/2018/08/11/pg_cron_and_materialized_view/"/>
      <url>/2018/08/11/pg_cron_and_materialized_view/</url>
      <content type="html"><![CDATA[<p>在<code>PostgreSQL</code>中可以很轻松的创建物化视图，但是却没有自动刷新物化视图的机制。通常来说，不外乎两种方式，一种是通过触发器，另一种就是定时任务调度。今天我们就来说说第二种方式。<br>主要借助一个名为<a href="https://github.com/citusdata/pg_cron" target="_blank" rel="noopener">pg_cron</a>的扩展。<br>安装方法在官方介绍里面已经说的很清楚了，不再赘述，这里提醒一点，安装完后，是需要修改<code>postgresql.conf</code>配置文件，并重启<code>PostgreSQL</code>服务的。具体修改如下：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">shared_preload_libraries = <span class="string">'pg_cron'</span></span><br><span class="line">cron<span class="selector-class">.database_name</span> = <span class="string">'postgres'</span></span><br></pre></td></tr></table></figure></p><p>第二行的指定<code>cron</code>的元数据相关信息存放的数据库，是可以改成其他的。这里要明确一个概念，<code>cron</code>安装的数据库，和它要控制的数据库没有什么必然联系，并不因为说安装在了<code>postgres</code>库，就不能调度其他库了，这个在后续具体配置的时候，就能明白了。<br>做完上述步骤，保证<code>PostgreSQL</code>服务重启过后，就可以用<code>psql</code>或其他工具连接到<code>cron.database_name</code>对应的数据，执行<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">CREATE <span class="keyword">EXTENSION </span>pg_cron<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>如果不在指定的库执行的话，会遇到错误<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Jobs must be scheduled <span class="built_in">from</span> <span class="keyword">the</span> database configured <span class="keyword">in</span> cron.database_name, since <span class="keyword">the</span> pg_cron background worker reads job descriptions <span class="built_in">from</span> this database.</span><br></pre></td></tr></table></figure></p><p>届时注意即可。<br>一切准备就绪后，就可以使用了，使用方式相当简单。这里我用一个查询<code>now()</code>的物化视图做演示<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">materialized</span> <span class="keyword">view</span> <span class="keyword">now</span> <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">now</span>();</span><br><span class="line"><span class="keyword">SELECT</span> cron.schedule(<span class="string">'26 * * * *'</span>, <span class="string">'refresh materialized view now;'</span>);</span><br></pre></td></tr></table></figure></p><p>这就实现了每小时26分的时候去刷新物化视图，也就是意味着，任意时候执行<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">now</span>;</span><br></pre></td></tr></table></figure></p><p>获得的结果，都是距离此刻最近的26分，而不是当前时间。<br>那么，已经创建的任务，该如何管理呢。其实很简单，定时任务数据都存放在<code>cron.job</code>表中，我们看看里面的数据就明白了。<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">+<span class="params">---------</span>+<span class="params">------------</span>+<span class="params">--------------------------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+</span><br><span class="line">| jobid   | schedule   | <span class="keyword">command</span>                        | nodename   | nodeport   | database   | username   |</span><br><span class="line">|<span class="params">---------</span>+<span class="params">------------</span>+<span class="params">--------------------------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>|</span><br><span class="line">| 1       | 26 * * * * | refresh materialized view now; | localhost  | 5432       | analyze    | postgres   |</span><br><span class="line">+<span class="params">---------</span>+<span class="params">------------</span>+<span class="params">--------------------------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+</span><br></pre></td></tr></table></figure></p><p>如果要取消一个任务，就需要拿到<code>jobid</code>，然后执行下面这句就好了。<br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cron.unschedule(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL修改FDW相关配置</title>
      <link href="/2018/08/10/PostgreSQL_alert_foreign_server/"/>
      <url>/2018/08/10/PostgreSQL_alert_foreign_server/</url>
      <content type="html"><![CDATA[<p>必要的时候要修改<code>PostgreSQL</code>中配置的外部服务器。有个<code>ALTER SERVER</code>命令是专门应对这种场景的。比如我的外部数据源服务器地址换了，只需要改下之前配置的<code>host</code>地址即可，<code>SQL</code>如下<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">ALTER SERVER foreign_server <span class="keyword">OPTIONS</span> (<span class="keyword">set</span> host <span class="comment">'192.168.0.88'</span><span class="comment">)</span>;</span><br></pre></td></tr></table></figure></p><p>更多内容可以查看官方文档[<a href="http://www.postgres.cn/docs/9.6/sql-alterserver.html]" target="_blank" rel="noopener">http://www.postgres.cn/docs/9.6/sql-alterserver.html]</a></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中的distinct on</title>
      <link href="/2018/08/09/PostgreSQL_distinct-on/"/>
      <url>/2018/08/09/PostgreSQL_distinct-on/</url>
      <content type="html"><![CDATA[<p>想象有这么一张表，存放若干学生不同课程的考试成绩，需求是，找出每门课程中，成绩最好的学生。原始表大概如下：</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+--------------------------------------+-----------------+----------------+-----------+</span><br><span class="line">|<span class="string"> id                                   </span>|<span class="string"> v_studentname   </span>|<span class="string"> v_coursename   </span>|<span class="string"> i_score   </span>|</span><br><span class="line">|<span class="string">--------------------------------------+-----------------+----------------+-----------</span>|</span><br><span class="line">|<span class="string"> fb9fe43a-6f57-4f92-8678-139167693e72 </span>|<span class="string"> 张三            </span>|<span class="string"> 语文           </span>|<span class="string"> 91        </span>|</span><br><span class="line">|<span class="string"> 0898afd7-4253-496e-9190-36fae14bddf2 </span>|<span class="string"> 张三            </span>|<span class="string"> 数学           </span>|<span class="string"> 77        </span>|</span><br><span class="line">|<span class="string"> 2a1f810d-55ee-42cc-ac17-ee970154cecb </span>|<span class="string"> 张三            </span>|<span class="string"> 英语           </span>|<span class="string"> 90        </span>|</span><br><span class="line">|<span class="string"> fa975cd4-af5f-49d0-a89e-6f88665629eb </span>|<span class="string"> 李四            </span>|<span class="string"> 语文           </span>|<span class="string"> 88        </span>|</span><br><span class="line">|<span class="string"> 8833a07c-de8d-4b15-aa34-d9340c2e82c3 </span>|<span class="string"> 李四            </span>|<span class="string"> 数学           </span>|<span class="string"> 87        </span>|</span><br><span class="line">|<span class="string"> 1a9dfbdf-7c44-45d7-8141-590203aa26a9 </span>|<span class="string"> 李四            </span>|<span class="string"> 英语           </span>|<span class="string"> 89        </span>|</span><br><span class="line">|<span class="string"> cd3ec937-0ab9-4745-ad1a-c9f85839eaeb </span>|<span class="string"> 王五            </span>|<span class="string"> 语文           </span>|<span class="string"> 89        </span>|</span><br><span class="line">|<span class="string"> 431b7ccd-3a25-4ff4-9cc2-2e9f111f5c06 </span>|<span class="string"> 王五            </span>|<span class="string"> 数学           </span>|<span class="string"> 91        </span>|</span><br><span class="line">|<span class="string"> 8021e41d-09f5-49fb-a9e2-750d14bbff50 </span>|<span class="string"> 王五            </span>|<span class="string"> 英语           </span>|<span class="string"> 79        </span>|</span><br><span class="line">+--------------------------------------+-----------------+----------------+-----------+</span><br></pre></td></tr></table></figure><h2 id="传统方案"><a href="#传统方案" class="headerlink" title="传统方案"></a>传统方案</h2><p>传统的方法，要找每门课程成绩最好的学生的话，需要借助聚合函数，而且要几步操作：</p><ol><li><p>找到每门课程的最好成绩</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">select v_coursename, max(i_score)</span><br><span class="line"><span class="keyword">from</span> achievement</span><br><span class="line">group by v_coursename;</span><br></pre></td></tr></table></figure></li><li><p>再跟<code>achievement</code>表<code>join</code>，才能找到该课程最高分对应的学生姓名。即使在有<code>CTE</code>支持的情况下，实现起来也很复杂</p> <figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">with cte as (<span class="keyword">select</span> v_coursename, <span class="built_in">max</span>(i_score) <span class="keyword">as</span> i_score <span class="keyword">from</span> achievement <span class="keyword">group</span> <span class="keyword">by</span> v_coursename)</span><br><span class="line"><span class="keyword">select</span> cte.*, achievement.v_studentname</span><br><span class="line"><span class="keyword">from</span> cte</span><br><span class="line">       <span class="keyword">join</span> achievement <span class="keyword">on</span> cte.i_score = achievement.i_score <span class="keyword">and</span> cte.v_coursename = achievement.v_coursename</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> cte.v_coursename;</span><br></pre></td></tr></table></figure><p> 要是没有<code>CTE</code>的支持，估计用纯数据库实现，就捉襟见肘了。</p></li></ol><h2 id="使用distinct-on的方案"><a href="#使用distinct-on的方案" class="headerlink" title="使用distinct on的方案"></a>使用distinct on的方案</h2><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">on</span> (v_coursename) * </span><br><span class="line"><span class="keyword">from</span> achievement</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> v_coursename, i_score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>一句话解决，是不是很开森。</p><h4 id="原理回顾"><a href="#原理回顾" class="headerlink" title="原理回顾"></a>原理回顾</h4><p><code>DISTINCT ON</code>是将结果集按指定字段值的去重，具体实现方法是先对结果集按照<code>DISTINCT ON</code>指定的字段进行排序，然后筛选出每个字段第一次出现时所在的记录，其余的记录都剔除。<br><code>ON</code>修饰符支持多列，运算时会基于多列的总体唯一性进行去重操作。同时查询语句必须要有<code>ORDER BY</code>，并且要保证排序字段从左至右的的顺序，应该是跟<code>DISTINCT ON</code>命中字段顺序相符合，当然<code>ORDER BY</code>可以追加更多的字段。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux软硬链接使用心得</title>
      <link href="/2018/08/08/Linux_ln/"/>
      <url>/2018/08/08/Linux_ln/</url>
      <content type="html"><![CDATA[<p><code>ln</code>命令，涉及到的软硬链接的核心概念已经被阐述的很多了。但是用的时候，到底用软链接，还是用硬链接，有时候还是会让人摸不着头绪。所以我尝试总结几点：</p><ol><li>软硬链接都能起到原始文件只占用一份磁盘资源的目的</li><li>硬链接不能针对文件夹，软链接无此限制</li><li>硬链接可以起到备份的作用，只要有硬链接在，原始文件就能访问；软链接无此效果</li><li>不论软链接，硬链接，<code>chmod</code>做的权限变更都具有传递性</li><li>软链接有个坑，如果原始文件删除之后，再创建一个同名的文件，软链接还会莫名其妙建立链接，这可能不一定是我们需要的</li></ol>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL删除数据库时提示other session using the database</title>
      <link href="/2018/08/07/PostgreSQL_drop_database_other-session-using-the-database/"/>
      <url>/2018/08/07/PostgreSQL_drop_database_other-session-using-the-database/</url>
      <content type="html"><![CDATA[<p>PostgreSQL中，如果想drop一个正在被人连接的数据库，是不可以的。提示如下：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">postgres</span>=# drop database ka;</span><br><span class="line">ERROR:  database <span class="string">"ka"</span> is being accessed by other users</span><br><span class="line">DETAIL:  There is 1 other session using the database</span><br></pre></td></tr></table></figure></p><p>应对方法是要通过<code>pg_terminate_backend</code>系统内置函数，把对应库在线连接给清理掉，使用方法如下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_terminate_backend(pg_stat_activity.pid)</span><br><span class="line">    <span class="keyword">FROM</span> pg_stat_activity</span><br><span class="line">    <span class="keyword">WHERE</span> pg_stat_activity.datname = <span class="string">'ka'</span></span><br><span class="line">      <span class="keyword">AND</span> pid &lt;&gt; pg_backend_pid();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cordova插件中定制build.gradle的方法</title>
      <link href="/2018/08/06/cordova_plugin_gradle/"/>
      <url>/2018/08/06/cordova_plugin_gradle/</url>
      <content type="html"><![CDATA[<p>编写<code>cordova</code>插件的时候，有时候要有进一步设置<code>build.gradle</code>文件的需求，比如追加个依赖什么的。这中问题，可以通过设置<code>cordova</code>的<code>plugin.xml</code>来解决的。分为如下几个步骤：</p><ol><li><p>编写cordova.build文件，文件名可以随便叫，内容就放你需要追加的个性化内容，比如我的是</p> <figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            jniLibs.srcDirs = [<span class="string">'libs'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>plugin.xml</code>文件中<code>&lt;platform name=&quot;android&quot;&gt;&lt;/platform&gt;</code>区域内追加配置</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;framework <span class="attribute">src</span>=<span class="string">"src/android/cordova.gradle"</span> <span class="attribute">custom</span>=<span class="string">"true"</span> <span class="attribute">type</span>=<span class="string">"gradleReference"</span>/&gt;</span><br></pre></td></tr></table></figure></li></ol><p>更多信息可以查阅文档 <a href="https://cordova.apache.org/docs/en/latest/plugin_ref/spec.html" target="_blank" rel="noopener">https://cordova.apache.org/docs/en/latest/plugin_ref/spec.html</a></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cordova </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于Geb的京东抢券</title>
      <link href="/2018/08/05/grab_a_ticket_use_geb/"/>
      <url>/2018/08/05/grab_a_ticket_use_geb/</url>
      <content type="html"><![CDATA[<p>前面介绍过<a href="http://gebish.org" target="_blank" rel="noopener">Geb</a>是个好东西，可以用它实现web前端的自动化测试，自然用来解放双手，抢个券什么的不在话下。<br>这次我们主要瞄准京东。最佳的实验场所是京东的移动web版，即<a href="https://m.jd.com/" target="_blank" rel="noopener">https://m.jd.com/</a>，大概分为以下几个步骤：</p><ol><li>打开京东首页</li><li>点击登录按钮</li><li>填写登录用户名密码并登录</li><li>调整到需要抢券的页面</li><li>找到抢券按钮开抢</li></ol><p>下面贴一个，618某活动的抢券代码（现在已经下线了），仅供参考。<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"> static <span class="function"><span class="keyword">def</span> <span class="title">checkin</span><span class="params">(String username, String password)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FirefoxBinary firefoxBinary = new FirefoxBinary();</span><br><span class="line">/<span class="regexp">/        firefoxBinary.addCommandLineOptions("--headless");</span></span><br><span class="line"><span class="regexp">        FirefoxOptions firefoxOptions = new FirefoxOptions();</span></span><br><span class="line"><span class="regexp">        firefoxOptions.setBinary(firefoxBinary);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        def browser = new Browser(driver: new FirefoxDriver(firefoxOptions))</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        browser.with &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            go "https:/</span><span class="regexp">/m.jd.com"</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            $(".jd-search-icon-login").click()</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            $("#username").value(username)</span></span><br><span class="line"><span class="regexp">            $("#password").value(password)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            $("#loginBtn").click()</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            sleep(5000)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            go "https:/</span><span class="regexp">/pro.m.jd.com/mall</span><span class="regexp">/active/q</span>KRVTAJL7v93L71TkJebPv5GJnE/index.html<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            $("</span><span class="comment">#m_1_14").children().each &#123;</span></span><br><span class="line">                it.click()</span><br><span class="line">                sleep(<span class="number">500</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>补充几个说明：</p><ol><li>我用的是<code>Firefox</code>浏览器。所以需要电脑事先装好该浏览器。</li><li>只装浏览器还不够，还需要相应的<code>WebDriver</code>驱动。如果找不到程序会报错的，可以根据错误提示下载该驱动。然后要把本地驱动文件地址设置一下，方便<code>Geb</code>识别，代码如下<code>System.setProperty(&quot;webdriver.gecko.driver&quot;, &quot;/root/geckodriver&quot;)</code></li><li><strong>无节目的Linux服务器可不可用呢？答案是可以</strong>，在安装完上面两样东西之后，只需要代码里添加<code>firefoxBinary.addCommandLineOptions(&quot;--headless&quot;);</code>就可以启动无界面的<code>Firefox</code>了</li></ol><h4 id="友情提醒"><a href="#友情提醒" class="headerlink" title="友情提醒"></a>友情提醒</h4><p>工具抢券也好、代码抢券也好，都是一种对普通消费者不公平的存在。建议学会之后，自用练手即可，切勿以此牟利。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM下最好用的前端自动化测试工具Geb</title>
      <link href="/2018/08/04/Geb/"/>
      <url>/2018/08/04/Geb/</url>
      <content type="html"><![CDATA[<p>接触了<code>Angular</code>才知道前端有个端到端测试的说法，然后了解到有<code>WebDriver</code>这种神奇的存在，瞬间打开了新世纪的大门。后来几经寻觅，终于发现一个运行在<code>JVM</code>中的前端测试工具，那就是<a href="http://gebish.org" target="_blank" rel="noopener">Geb</a>。<br>来段代码：<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">import</span> geb.<span class="keyword">Browser</span></span><br><span class="line"><span class="keyword"> </span></span><br><span class="line"><span class="keyword">Browser.drive </span>&#123;</span><br><span class="line">    go <span class="string">"http://myapp.com/login"</span></span><br><span class="line">     </span><br><span class="line">    <span class="meta">assert</span> $(<span class="string">"h1"</span>)<span class="meta">.text</span>() == <span class="string">"Please Login"</span></span><br><span class="line">     </span><br><span class="line">    $(<span class="string">"form.login"</span>).with &#123;</span><br><span class="line">        username = <span class="string">"admin"</span></span><br><span class="line">        password = <span class="string">"password"</span></span><br><span class="line">        login().click()</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">assert</span> $(<span class="string">"h1"</span>)<span class="meta">.text</span>() == <span class="string">"Admin Section"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是很易懂，一个有<code>Java</code>与<code>jQuery</code>基础的人应该非常容易上手。<br>还记得那个阿里员工抢月饼事件么，估计看了新闻之后，前端程序员都会觉得0门槛，但是后端程序员，可能就会觉得自己的技术栈鞭长莫及了。有了<code>Geb</code>，我们能做的事情会更多，也会更加方便。下一篇，我将介绍如何用<code>Geb</code>来实现京东抢券。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Geb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中的几中常见索引及应用场景</title>
      <link href="/2018/08/03/PostgreSQL_indexs/"/>
      <url>/2018/08/03/PostgreSQL_indexs/</url>
      <content type="html"><![CDATA[<h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h2><p><code>B-tree</code>是关系型数据库中，最常见的索引，也是<code>PostgreSQL</code>中经常采用的默认索引。主要应对场景：</p><ul><li>主键</li><li>唯一性约束</li><li>等值比较</li><li>范围查询</li><li>null判断</li></ul><h2 id="GiST"><a href="#GiST" class="headerlink" title="GiST"></a>GiST</h2><p>全称Generalized Search Tree，大白话就是通用搜索树。这是一种<strong>有损</strong>索引，主要应对非结构化数据，比如空间、全文检索什么的。主要应对场景：</p><ul><li>几何类型数据</li><li>范围类型数据</li><li>ltree类型数据</li><li>总之就是要用到不局限于<code>&lt;、&lt;=、=、 &gt;=、&gt;</code>这几种操作符时，要考虑<code>GiST</code>索引</li><li><code>GiST</code>跟<code>B-tree</code>并不矛盾，可以把<code>GiST</code>当作一种补充来用，效果更好</li></ul><h2 id="GIN"><a href="#GIN" class="headerlink" title="GIN"></a>GIN</h2><p>全称Generalized Inverted Index，通用逆序索引。它是从<code>GiST</code>派生出来的一种索引，比<code>GiST</code>最大的优势是无损，也就是说如果要查询的数据都被索引，就可以从索引中直接获取查询结果。<code>GIN</code>索引的缺点是更新操作时，多出一个字段值复制的动作，这点不及<code>GiST</code>的速度快。另外就是它不能对大对象类型索引，比如hstore、text里面有大对象，就不适合用<code>GIN</code>了。主要应对场景：</p><ul><li>jsonb数据类型</li><li>数组数据类型</li><li>配合<code>create extension pg_trgm</code>对<code>varchar</code>模糊查询</li></ul><h2 id="SP-GiST"><a href="#SP-GiST" class="headerlink" title="SP-GiST"></a>SP-GiST</h2><p>SP是Space-Partitioning的简写，也就是说本索引是基于空间分区树算法的GiST索引。与<code>GiST</code>的应用场领域高度重叠，好处就是针对某些领域的特定算法，其效率要高一些。目前支持该索引的类型主要有：</p><ul><li>point</li><li>box</li><li>text</li><li>range</li><li>network</li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>PostgreSQL已将<code>Hash</code>索引列为不推荐使用状态。只能实现<code>=</code>运算相关判断。</p><p>想了解更多索引的应用范围，完全可以在<code>PostgreSQL</code>的元数据中找到答案。尝试执行这个<code>SQL</code>吧<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">SELECT am<span class="selector-class">.amname</span> AS index_method,</span><br><span class="line">       opf<span class="selector-class">.opfname</span> AS opfamily_name,</span><br><span class="line">       amop<span class="selector-class">.amopopr</span>::regoperator AS opfamily_operator</span><br><span class="line">FROM pg_am am, pg_opfamily opf, pg_amop amop</span><br><span class="line">WHERE opf<span class="selector-class">.opfmethod</span> = am<span class="selector-class">.oid</span> AND</span><br><span class="line">      amop<span class="selector-class">.amopfamily</span> = opf.oid</span><br><span class="line">ORDER BY index_method, opfamily_name, opfamily_operator</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中varchar类型like前置%查询命中索引的方法</title>
      <link href="/2018/08/02/PostgreSQL_select_varchar_like_front_/"/>
      <url>/2018/08/02/PostgreSQL_select_varchar_like_front_/</url>
      <content type="html"><![CDATA[<p>上一篇中，我们学习了<code>PostgreSQL</code>中想要让<code>varchar</code>类型支持<code>like</code>查询能够命中索引，需要注意的地方。但是即便是创建索引时，指定了操作符类<code>varchar_pattern_ops</code>，在使用<code>like</code>查询的时候，还是只能保证<code>sometext%</code>这种查询能够命中索引，但是<code>%sometext</code>这种是无能为力的，见下图。<br><img src="/media/15331709094483.jpg" alt=""><br><img src="/media/15331709707728.jpg" alt=""><br>所以如果需要支持<code>%sometext</code>方式的索引查询，还需要再做点工作：</p><ol><li><code>create extension pg_trgm;</code></li><li><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> log_action_v_uri_index  <span class="keyword">ON</span>  log_action <span class="keyword">using</span> gist (v_uri gist_trgm_ops);</span><br></pre></td></tr></table></figure></li><li><p>上面<code>gist</code>索引时有损的，后来研究支持，发现<code>gin</code>更合适，速度更快 <strong>强烈推荐</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> table_name_md5_index  <span class="keyword">ON</span> table_name <span class="keyword">using</span> gin (<span class="keyword">md5</span> gin_trgm_ops);</span><br></pre></td></tr></table></figure></li></ol><p>然后重新执行<code>explain</code>，就能看到命中索引了<br><img src="/media/15331719609935.jpg" alt=""></p><p>关于<code>btree</code>索引与<code>gist</code>索引的应用场景，我们以后再探讨。 现在我们先看看同样支持<code>sometext%</code>查询命中索引的情况下，我们该用哪种呢。</p><ol><li>首先是查询速度，这次我们换百万行的数据来测试<ul><li>先看<code>btree</code>的<img src="/media/15331926585276.jpg" alt=""></li><li>再看<code>gist</code>的<img src="/media/15331926156740.jpg" alt=""></li><li>直观来看，采用<code>gist</code>索引规划期给的时间是更快的。但是如果采用<code>explain analyse</code>尝试获取真实结果的话，答案就恰恰相反了</li><li>先看<code>btree</code><img src="/media/15331929892802.jpg" alt=""></li><li>再看<code>gist</code><img src="/media/15331930513697.jpg" alt=""></li><li>结果匪夷所思，在<code>gist</code>索引的情况下，不论怎么测试，最终的<code>Execution time</code>都保持在500ms以上。而<code>btree</code>实际执行时间才1ms多。我尝试重启数据库，来保证数据没有缓存，但是<code>btree</code>反馈的实际执行时间也不过就11ms多，之后又会下降了1ms量级。这其中的原因，是因为<code>gist</code>是一种有损索引，所以不能像<code>btree</code>索引那样，直接把值取出来。</li><li><strong>结论：通常情况下btree的查询速度会远好于gist，但是如果gist索引列只参与条件判断，不参与select，gist的速度还是比较理想的</strong></li></ul></li><li>然是是创建索引的速度<ul><li>先看<code>btree</code><img src="/media/15331936107582.jpg" alt=""></li><li>再看<code>gist</code><img src="/media/15331936413004.jpg" alt=""></li><li><strong>结论：创建索引的速度，btree远好于gist</strong></li></ul></li><li>还有功能上<strong>gist索引不支持=查询，也就是如果除了模糊匹配，还需要精确匹配的话，必须引入btree索引</strong></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><code>varchar</code>类型，如果需要模糊查询，需要这么来</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> table_name_md5_index_btree <span class="keyword">ON</span> table_name (<span class="keyword">md5</span> text_pattern_ops);</span><br></pre></td></tr></table></figure><p>  但是此方案只支持<code>左锚定</code></p></li><li><p>如果需要不局限于<code>左锚定</code>的模糊查询，还需要这么来</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> extension pg_trgm;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> table_name_md5_index  <span class="keyword">ON</span> table_name <span class="keyword">using</span> gin (<span class="keyword">md5</span> gin_trgm_ops);</span><br></pre></td></tr></table></figure></li><li><p>如果还需要精确等值查询，请务必保留<code>btree</code>索引</p></li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中varchar类型支持like查询索引</title>
      <link href="/2018/08/01/PostgreSQL_select_varchar_like_index/"/>
      <url>/2018/08/01/PostgreSQL_select_varchar_like_index/</url>
      <content type="html"><![CDATA[<p>之前在使用<code>PostgreSQL</code>中的<code>varchar</code>类型时想当然的以为用最基本的索引创建语句创建的索引，就支持<code>like</code>查询的。<br>类似这句：<br><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> log_action_v_uri_index <span class="keyword">ON</span> log_action (v_uri);</span><br></pre></td></tr></table></figure></p><p>但是看过<code>explain</code>才知道，单凭这样的索引，在<code>like</code>搜索的时候，仍然是顺序全表扫描，如图：<br><img src="/media/15330845808519.jpg" alt=""><br>后来google了一下解决方案，原来是创建索引的时候追加一下参数，应该这么创建<br><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> log_action_v_uri_index <span class="keyword">ON</span> log_action (v_uri varchar_pattern_ops);</span><br></pre></td></tr></table></figure></p><p>然后对同样的语句再次<code>explain</code>结果如下：<br><img src="/media/15330848868005.jpg" alt=""><br>可以看到，已经命中索引了。<br>这其中涉及到一个重要的知识点，就是<code>PostgreSQL</code>的索引<em>操作符类</em> ，其标准语法为<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="keyword">name</span> <span class="keyword">ON</span> <span class="keyword">table</span> (<span class="keyword">column</span> opclass [<span class="keyword">sort</span> options] [, ...]);</span><br></pre></td></tr></table></figure></p><p>这个<code>opclass</code>可以针对不同的数据类型和查询方式提供多种多样的方案，<br><img src="/media/15330861199315.jpg" alt=""><br>可以看到光<code>btree</code>索引有关的操作符类就非常多，有些<code>is_default</code>是<code>true</code>也就是正好列类型吻合的话，这个操作符类就不要特意说明了。而<code>varchar</code>或者<code>text</code>的默认用的是<code>text_ops</code>，它支持的查询方式仅有<br><img src="/media/15330876281185.jpg" alt=""><br>所以想用模糊查询的话，还是得用<code>text_pattern_ops</code>或者<code>varchar_pattern_ops</code>(这哥俩是一个东西)，它支持正则模糊匹配，也支持<code>like %</code>的方式<br><img src="/media/15330878032471.jpg" alt=""></p><ul><li>更多信息，可以查看官方文档<a href="http://www.postgres.cn/docs/9.6/indexes-opclass.html" target="_blank" rel="noopener">操作符类和操作符族</a></li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IntelliJ IDEA中的SQL Explain</title>
      <link href="/2018/07/31/IntelliJ-IDEA_SQL-Explain/"/>
      <url>/2018/07/31/IntelliJ-IDEA_SQL-Explain/</url>
      <content type="html"><![CDATA[<p>善于利用<code>SQL</code>的<code>explain</code>是<code>SQL</code>调整优化的必经之路。但是遇到复杂的<code>SQL</code>，查看<code>explain</code>结果也是有点困难的。比如这样的：<br><img src="/media/15329969004233.jpg" alt=""><br>好在很多数据库的客户端都提供了图形化的表现形式，比如<code>PostgreSQL</code>的<code>pgAdmin4</code>就能看到如下效果：<br><img src="/media/15329972711011.jpg" alt=""><br>不过如果有个工具，能够hold住所有主流的关系型数据库的话，就更嗨皮了。答案就是<code>IntelliJ IDEA</code>。如果你还没有尝试过其自带的<code>Database</code>功能的话，推荐现在就试一下。在屏幕右侧应该能找到。<br><img src="/media/15329976430336.jpg" alt=""><br>只需要按照向导添加相应的数据库连接就好了。不过这个功能免费的社区版是没有的。<br>创建完数据库链接后，通过此按钮打开<code>SQL Console</code>窗口<br><img src="/media/15329978378217.jpg" alt=""><br>然后在里面就可以愉快的编写<code>SQL</code>了。<br>先来一段：<br><img src="/media/15329983218004.jpg" alt=""><br>现在我们可以尝试通过<code>IntelliJ IDEA</code>执行一次<code>explain</code>了。</p><ul><li>先把光标移动到需要<code>explain</code>的<code>SQL</code>上</li><li>右键呼出菜单，找到<img src="/media/15329984643618.jpg" alt="">   执行之</li><li>就能看到效果了<img src="/media/15329985590089.jpg" alt=""></li><li>点击<code>Show Visualisation</code>可以呼出图形化展示<img src="/media/15329987110873.jpg" alt=""></li><li>如果觉得这个功能实用的话，可以给它设置一个快捷键，方法如下<ul><li>呼出<code>Find Action...</code>窗口（快捷键：⇧⌘A），在<code>Help</code>菜单下能找到</li><li>搜索到<code>explain</code><img src="/media/15329989448215.jpg" alt=""></li><li>按快捷键⌥↩︎，或者windows下的<code>alt+回车</code></li><li>就可以设置一个快捷键了<img src="/media/15329990816786.jpg" alt=""></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>启动Docker容器后要注意的时区问题</title>
      <link href="/2018/07/30/timezone_in_docker/"/>
      <url>/2018/07/30/timezone_in_docker/</url>
      <content type="html"><![CDATA[<p>对于中国用户来说，一般的docker容器启动后，如果执行<code>docker  exec -it xxxx date</code>会发现打印出来的时间，比当前北京时间早八个小时。所以需要调整容器的时区，主要有两个命令（要在容器内部执行）：</p><ul><li><code>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></li><li><code>echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</code></li></ul><p>其中第一个命令就能解决不少问题，比如我用<code>PostgreSQL</code>的话，<code>select now()</code>就可以通过第一条命令修正。但是<code>Tomcat</code>等java相关的程序，还需要第二条命令，才能获得正确的时间。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>tomcat中URL中文乱码问题</title>
      <link href="/2018/07/29/tomcat_url_chinese_garbled/"/>
      <url>/2018/07/29/tomcat_url_chinese_garbled/</url>
      <content type="html"><![CDATA[<p>找到<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attribute">port</span>=<span class="string">"8080"</span> <span class="attribute">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attribute">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>追加配置为<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attribute">port</span>=<span class="string">"8080"</span> <span class="attribute">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attribute">redirectPort</span>=<span class="string">"8443"</span> <span class="attribute">URIEncoding</span>=<span class="string">"UTF-8"</span>/&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乱码 </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>被忽略的IntelliJ IDEA常用快捷键</title>
      <link href="/2018/07/28/IntelliJ-IDEA_hot_keys/"/>
      <url>/2018/07/28/IntelliJ-IDEA_hot_keys/</url>
      <content type="html"><![CDATA[<ul><li>跳转到方法声明处 （Go to declaration） ⌘B</li><li>快速查看声明（Open quick definition lookup）⇧⌘I</li><li>快速查看文档（Quick documentation lookup）^J</li><li>块级注释（Comment/uncomment with block comment）^⇧/</li><li>查找被调用处（Show usages）⌥⌘F7</li><li>在本文件高亮引用，可以用在return上（Highlight usages in file）⇧⌘F7</li><li>弹出重构窗口 ⌥⇧⌘T</li><li>补全代码（Complete statement）⇧⌘↩︎</li><li>查找功能（Find Action…）⇧⌘A，紧接着如果要给找到的功能设置快捷键，就继续⌥↩︎</li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>制作macOS启动U盘命令</title>
      <link href="/2018/07/27/macos_bootable_usb/"/>
      <url>/2018/07/27/macos_bootable_usb/</url>
      <content type="html"><![CDATA[<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo <span class="string">/Applications/Install</span>\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia <span class="params">--volume</span> <span class="string">/Volumes/Sierra</span> <span class="params">--applicationpath</span> <span class="string">/Applications/Install</span>\ macOS\ High\ Sierra.app <span class="params">--nointeraction</span></span><br></pre></td></tr></table></figure><p>其中<code>/Volumes/Sierra</code>的<code>Sierra</code>是U盘的命名。如下图所示。<br><img src="/media/15326512660951.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编写跨操作系统Java代码时动态获取文件分隔符</title>
      <link href="/2018/07/26/separator_in_java/"/>
      <url>/2018/07/26/separator_in_java/</url>
      <content type="html"><![CDATA[<h3 id="大概有以下几种思路"><a href="#大概有以下几种思路" class="headerlink" title="大概有以下几种思路"></a>大概有以下几种思路</h3><ol><li><code>File.separator</code>系统相关的默认名称分隔符，为方便起见，表示为字符串。 该字符串包含单个字符，即separatorChar。</li><li><code>FileSystems.getDefault().getSeparator()</code>返回名称分隔符，表示为字符串。<br>名称分隔符用于分隔路径字符串中的名称。 实现可能支持多个名称分隔符，在这种情况下，此方法返回特定于实现的默认名称分隔符。 通过调用toString（）方法创建路径字符串时使用此分隔符。<br>对于默认提供程序，此方法返回与java.io.File.separator相同的分隔符。</li><li><code>System.getProperty(&quot;file.separator&quot;)</code></li></ol><p>正常情况下，选择第一种，就ok了。第二种是在Java7时代追加的，功能更为强大。第三种也不错，因为额外提供通过<code>-Dfile.separator=</code>参数来指定的特性。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux免密登录不起作用解决办法</title>
      <link href="/2018/07/25/linux_ssh_key/"/>
      <url>/2018/07/25/linux_ssh_key/</url>
      <content type="html"><![CDATA[<p>已经把公钥添加到<code>~/.ssh/authorized_keys</code>文件之后，有时候依然无法实现免密码登录。后来才发现，是因为有些文件的权限放大了。想想也是，如果<code>authorized_keys</code>文件，是其他用户也能编辑的。那岂不是多了个后门，可以帮助其他用户绕到当前用户了。<br>所以重点在于几个关键文件是否把权限集中在自己手上，并且无论如何是不允许其他用户编辑的。<br>总结为以下几条命令<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">chmod 700 ~<span class="string">/.ssh</span></span><br><span class="line">chmod 600 ~<span class="string">/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure></p><p>有时候，光有上面两句还搞不定，我发现还得追加一句<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">755</span> ~</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小诗一首</title>
      <link href="/2018/07/24/xuzhou_xiari/"/>
      <url>/2018/07/24/xuzhou_xiari/</url>
      <content type="html"><![CDATA[<p><img src="/media/DSC04458.jpg" alt=""></p><h3 id="都谓彭城多霾日，"><a href="#都谓彭城多霾日，" class="headerlink" title="都谓彭城多霾日，"></a>都谓彭城多霾日，</h3><h3 id="落笔春城溅靛青。"><a href="#落笔春城溅靛青。" class="headerlink" title="落笔春城溅靛青。"></a>落笔春城溅靛青。</h3><h3 id="天公莫要惜颜色，"><a href="#天公莫要惜颜色，" class="headerlink" title="天公莫要惜颜色，"></a>天公莫要惜颜色，</h3><h3 id="几许蔚蓝伴我行。"><a href="#几许蔚蓝伴我行。" class="headerlink" title="几许蔚蓝伴我行。"></a>几许蔚蓝伴我行。</h3><h4 id="——戊戌年六月偶瞥于徐州"><a href="#——戊戌年六月偶瞥于徐州" class="headerlink" title="——戊戌年六月偶瞥于徐州"></a>——戊戌年六月偶瞥于徐州</h4>]]></content>
      
      <categories>
          
          <category> 文艺中年 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>IntelliJ IDEA在Winodws下Gradle乱码问题</title>
      <link href="/2018/07/23/IntelliJ-IDEA_Winodws_Gradle_garbled/"/>
      <url>/2018/07/23/IntelliJ-IDEA_Winodws_Gradle_garbled/</url>
      <content type="html"><![CDATA[<p>恐怕没有哪个中国程序员没被字符编码的问题坑过吧。本以为把能设置字符集的地方，都设置成<code>UTF-8</code>就不会踩坑。可是现实是残酷的。<br>比如在中文windows系统环境下，如果使用IntelliJ IDEA开发工具，同时跑gradle项目，那就要小心了。<br>需要在<br><code>File | Settings | Build, Execution, Deployment | Gradle</code><br>下，找到<code>Gradle VM options</code>，然后填入配置<code>-Dfile.encoding=UTF-8</code></p><p>还有一种方法，可以通过修改gradle.bat这个文件来实现，改文件通常存放于，<code>GRADLE_HOME</code>下的<code>bin</code>目录，找到<code>set DEFAULT_JVM_OPTS=</code>修改为<br><code>set DEFAULT_JVM_OPTS=&quot;-Dfile.encoding=UTF-8&quot;</code><br>即可。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> gradle </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL里一条SQL统计合计与小计</title>
      <link href="/2018/07/22/postgres_select_total_subtotal_one_sql/"/>
      <url>/2018/07/22/postgres_select_total_subtotal_one_sql/</url>
      <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">GROUPING</span>(student) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">THEN</span> <span class="string">'合计'</span></span><br><span class="line">  <span class="keyword">ELSE</span> student <span class="keyword">END</span>,</span><br><span class="line">  <span class="keyword">CASE</span> <span class="keyword">WHEN</span>  <span class="keyword">GROUPING</span>(student) &lt;&gt; <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">GROUPING</span>(course) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">THEN</span> <span class="string">'小计'</span></span><br><span class="line">  <span class="keyword">ELSE</span> course <span class="keyword">END</span>,</span><br><span class="line">  <span class="keyword">sum</span>(score.score)</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (student, course)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">GROUPING</span>(student) <span class="keyword">DESC</span> ,student <span class="keyword">DESC</span>, <span class="keyword">GROUPING</span>(course) <span class="keyword">DESC</span> ,course <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vert.x异步方法转同步</title>
      <link href="/2018/07/21/vertx_async_to_sync/"/>
      <url>/2018/07/21/vertx_async_to_sync/</url>
      <content type="html"><![CDATA[<p>以前用Vert.x的时候就有这样的疑问，如果我提供的方法是基于Vert.x异步实现的。如何被一个同步的应用调用呢，比如Spring。当时我一度以为要自己开一个线程，然后不断轮询结果，之后再返回，通过这样，把一个异步的方法，包装成同步的方法。<br>后来在使用<code>vertx-pac4j</code>的时候，无意中看到它源码中，也有我上面说的场景使用。就在<code>org.pac4j.vertx.context.session.VertxSessionStore</code>类的这一段：<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   <span class="keyword">public</span> Session getSession(<span class="keyword">String</span> sessionId) &#123;</span><br><span class="line">       final CompletableFuture&lt;io.vertx.ext.web.Session&gt; vertxSessionFuture = <span class="keyword">new</span> <span class="type">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">       sessionStore.<span class="keyword">get</span>(sessionId, asyncResult -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (asyncResult.succeeded()) &#123;</span><br><span class="line">               vertxSessionFuture.complete(asyncResult.result());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               vertxSessionFuture.completeExceptionally(asyncResult.cause());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       final CompletableFuture&lt;Session&gt; pac4jSessionFuture = vertxSessionFuture.thenApply(session -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">VertxSession</span>(session);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> pac4jSessionFuture.<span class="keyword">get</span>();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException|ExecutionException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">TechnicalException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>可以明显看到<code>sessionStore.get</code>是的常规的Vert.x异步调用。<br>基于这种应用方式，我尝试用<code>groovy</code>模仿写了一下，效果显著，代码如下：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import io<span class="selector-class">.vertx</span><span class="selector-class">.core</span><span class="selector-class">.Vertx</span></span><br><span class="line"></span><br><span class="line">import java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CompletableFuture</span></span><br><span class="line"></span><br><span class="line">String sayHello() &#123;</span><br><span class="line">    CompletableFuture completableFuture = new CompletableFuture()</span><br><span class="line"></span><br><span class="line">    Vertx vertx = Vertx.vertx()</span><br><span class="line">    vertx.setTimer(<span class="number">3000</span>, &#123;</span><br><span class="line">        completableFuture.complete(<span class="string">"hello world"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return completableFuture.get()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">println</span><span class="params">(sayHello()</span></span>)</span><br></pre></td></tr></table></figure></p><p>上面这种写法，主要还是依赖了java1.8的<code>CompletableFuture</code>类，后续我会单独开文章讲解这个类的使用。今天就先到这里吧。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何在cas登录成功页面显示用户名</title>
      <link href="/2018/07/20/cas_show_username_in_login_success_page/"/>
      <url>/2018/07/20/cas_show_username_in_login_success_page/</url>
      <content type="html"><![CDATA[<p><a href="https://www.apereo.org/projects/cas" target="_blank" rel="noopener">CAS</a>这种本来业务场景就很细分，再加上其上古时代存续至今的特质。估计还在用它的公司已经不多了。间接导致，其中文资料比较匮乏。<br>领导说，想再cas成功后的欢迎页，也就是<code>casGenericSuccess.jsp</code>页面，可以显示<code>欢迎:xxx</code>的字样。<br>不得不说，这个需求非常常规。然而不仅cas默认没有实现，甚至翻遍google，都很难找到满意的答案。比较有参考价值的可能就是<a href="https://groups.google.com/forum/#!topic/jasig-cas-user/q_pjYXCe7ko" target="_blank" rel="noopener">google groups</a>上的这篇。居然要借助额外的jar包(还是个已停止维护的)才能实现。不得已，只能自己想办法。<br>现在给出我的思路：</p><ol><li>在<code>deployerConfigContext.xml</code>文件中，找到<code>authenticationHandlers</code>参数，其应该对应一个类。十有八九，那个类是你自己实现的，如果不是，可以自己继承一下原有参数配置的类。</li><li>然后在那个类里的<code>authenticate</code>方法，可以通过追加<code>HttpSession session = RequestContextHolder.getRequestAttributes().getSessionMutex().session as HttpSession</code>这么一行，获取到<code>session</code>，这就嗨皮了。</li><li>可以在<code>authenticate</code>方法需要返回<code>true</code>的时候，之前增加一行<code>session.setAttribute(&quot;username&quot;,balabala);</code>，这样我们就顺利把username塞到<code>session</code>里的</li><li>最后，修改<code>casGenericSuccess.jsp</code>，在需要显示用户名的地方，加入<code>&lt;%=session.getAttribute(&quot;username&quot;)%&gt;</code>，就可以实现在登录成功页面显示用户名了</li><li>如果想显示更复杂数据内容，可以留意下<code>deployerConfigContext.xml</code>里面的<code>credentialsToPrincipalResolvers</code>所对应的类。它的时间节点是判定用户登录成功之后，组织用户信息用的。</li></ol>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS系统使用Shadowsocks搭建代理服务</title>
      <link href="/2018/07/19/CentOS_Shadowsocks/"/>
      <url>/2018/07/19/CentOS_Shadowsocks/</url>
      <content type="html"><![CDATA[<ol><li>确认pip是否安装，命令<code>pip help</code>，返回如图信息，说明已安装<br><img src="/media/15319616591142.jpg" alt=""><br>如果返回下图，说明未安装<br><img src="/media/15319617008516.jpg" alt=""><br>未安装需要执行以下子步骤：<ul><li><code>yum -y install epel-release</code></li><li><code>yum install python-pip</code></li></ul></li><li>通过pip安装shadowsocks，命令<code>pip install shadowsocks</code></li><li><p>准备shadowsocks的配置文件，找个地方放就行，比如<code>/root/shadowsocks.json</code>，文件内容如下：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"server"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">  <span class="string">"server_port"</span>: <span class="number">1988</span>,</span><br><span class="line">  <span class="string">"local_address"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">  <span class="string">"local_port"</span>: <span class="number">1080</span>,</span><br><span class="line">  <span class="string">"password"</span>: “xyz<span class="string">",</span></span><br><span class="line">  <span class="string">"timeout"</span>: <span class="number">300</span>,</span><br><span class="line">  <span class="string">"method"</span>: <span class="string">"aes-256-cfb"</span>,</span><br><span class="line">  <span class="string">"fast_open"</span>: false,</span><br><span class="line">  <span class="string">"workers"</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中<code>server_port</code>、<code>passoword</code>、<code>method</code>三个参数比较重要，分别对应:代理服务所在端口、链接密码、加密方式，回头要用到。</p></li><li>准备好配置文件之后，就可以启动shadowsocks服务了，命令为<code>ssserver -c /root/shadowsocks.json -d start</code>，至此shadowsocks服务启动完毕，然后就可以用客户端连接了。</li><li>客户端下载地址在都在github上，这里给出最常用的mac版和windows版<ul><li><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">mac</a></li><li><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">windows</a></li></ul></li><li>客户端安装完毕，就可以配置服务器连接了，这里给个参考配置：<br> <img src="/media/15319627604059.jpg" alt=""><br>地址就是服务器所在的地址，备注随意，剩下的三个配置，正好对应上面提过的配置。</li><li>确定shadowsocks client是启动状态，就可以享受不一样的网络了。</li></ol>]]></content>
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用Gradle自动发布程序至Linux服务器</title>
      <link href="/2018/07/18/gradle_task_use_ssh/"/>
      <url>/2018/07/18/gradle_task_use_ssh/</url>
      <content type="html"><![CDATA[<p>你的重复劳动，一定能找“人”帮你做，聪明的程序员一定是拒绝重复的。由于公司条件限制，暂时用不上<code>jenkins</code>，先拿<code>gradle</code>救救急也是不错的。今天要实现的是，通过gradle发布静态站点到服务器。这样可以和上回的<a href="http://www.kankanzhijian.com/2018/07/17/gradle_build_vue/">用Gradle打包Vue前端程序</a>保持一定的连贯性。当然本帖拿来发布<code>war</code>包也是ok的。</p><ul><li>首先追加gradle插件，参考写法</li></ul><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">plugins</span> &#123;</span><br><span class="line">    <span class="attribute">id</span> <span class="string">'org.hidetake.ssh'</span> version <span class="string">'2.9.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">  <span class="keyword">repositories</span> &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">'org.hidetake:gradle-ssh-plugin:2.9.0'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply plugin: <span class="string">'org.hidetake.ssh'</span></span><br></pre></td></tr></table></figure></p><ul><li>配置插件</li></ul><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">remotes</span> &#123;</span><br><span class="line">    <span class="section">webServer</span> &#123;</span><br><span class="line">        <span class="attribute">host</span> = <span class="string">'192.168.1.100'</span></span><br><span class="line">        user = <span class="string">'develop'</span></span><br><span class="line">        port = <span class="number">22</span></span><br><span class="line">        password = <span class="string">'xyz'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得密码服务器密码明文写在这里不安全，可以用公钥ssh的方案，那么这里可以用<code>identity = file(&#39;id_rsa&#39;)</code>代替掉<code>password = &#39;xyz&#39;</code></p><ul><li>配置完Gradle SSH Plugin，就可以自己写<code>task</code>实现上传文件了。下面贴段我的</li></ul><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> deployPortal &#123;</span><br><span class="line">    <span class="keyword">group</span> = <span class="string">'release'</span></span><br><span class="line">    dependsOn zipPortal</span><br><span class="line">    <span class="keyword">doLast</span> &#123;</span><br><span class="line">        ssh.run &#123;</span><br><span class="line">            session(remotes.webServer) &#123;</span><br><span class="line">                put <span class="keyword">from</span>: <span class="string">"$buildDir/portal.zip"</span>, <span class="keyword">into</span>: <span class="string">"/home/develop/"</span></span><br><span class="line">                <span class="keyword">def</span> result = execute <span class="string">'unzip -o  /home/develop/portal.zip -d /home/develop/portal/'</span></span><br><span class="line">                <span class="keyword">println</span>(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个task的主要作用就是把压缩好的静态站点上传至服务器，然后再解压缩。重点就两句话，第一句<code>put from: &quot;本地文件&quot;, into: &quot;服务器路径&quot;</code>，实现文件上传功能。第二句<code>execute &#39;执行shell命令&#39;</code>，实现通过shell命令，解压缩文件。</p><ul><li><p>至于中间那句<code>dependsOn zipPortal</code>表示执行发布task之前，先要把文件准备好，这个<code>zipPortal</code>task我是这么写的</p>  <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> zipPortal(type: Zip) &#123;</span><br><span class="line">    dependsOn(<span class="string">':portal:build'</span>)</span><br><span class="line">    <span class="keyword">from</span> <span class="string">'portal/www'</span></span><br><span class="line">    archiveName <span class="string">'portal.zip'</span></span><br><span class="line">    <span class="keyword">destinationDir</span> buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>换句话说，如果你是要上传<code>war</code>包的话，可能就不是<code>dependsOn zipPortal</code>而是<code>dependsOn war</code>了。其他的地方，大同小异。</p></li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用Gradle打包Vue前端程序</title>
      <link href="/2018/07/17/gradle_build_vue/"/>
      <url>/2018/07/17/gradle_build_vue/</url>
      <content type="html"><![CDATA[<p>我这边打包和发布程序，属于重度依赖Gradle的状态。所以纵容前端程序游离在这个体系外，不利于团队的整体协作。于是有了这篇文章。<br>其实很简单，首先我们需要一个以Gradle为基石的项目，把前后端项目组织成这样<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">myproject</span><br><span class="line">├── build.gradle</span><br><span class="line">├── frontend</span><br><span class="line">│   ├── build</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── node_modules</span><br><span class="line">│   ├── package.json</span><br><span class="line">│   └── src</span><br><span class="line">├── javaweb</span><br><span class="line">│   ├── build</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   ├── out</span><br><span class="line">│   └── src</span><br><span class="line">└── settings.gradle</span><br></pre></td></tr></table></figure></p><p>其中<code>frontend</code>文件夹就是<code>vue</code>项目的存放路径，我们先在此文件夹中，追加文件<code>build.gradle</code>，放至在package.json隔壁。填上很简单的内容：<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  <span class="built_in">id</span> <span class="string">"com.palantir.npm-run"</span> <span class="built_in">version</span> <span class="string">"0.5.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代表这个项目要用到gradle-npm-run的插件<br>然后修改settings.gradle，追加一行<br><code>include &#39;frontend&#39;</code>，这样gradle就能顺利识别vue前端项目了，并且依靠插件，我们获得了这几个task<br><img src="/media/15317809896046.jpg" alt="-w148"><br>其中<code>build</code>就可以实现通过<code>gradle frontend:build</code>的命令，实现gradle对vue项目的打包了。<br>明天，我将继续讲解，如何用gardle实现像Linux服务器，敬请期待。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux挂载新磁盘（适用阿里云、华为云）</title>
      <link href="/2018/07/16/linux_mount/"/>
      <url>/2018/07/16/linux_mount/</url>
      <content type="html"><![CDATA[<p>公司项目用的是华为的云服务器，刚申请了新的硬盘资源，需要手动分区挂载。虽然华为没给啥资料，但是不是还有阿里云嘛。所以结合阿里云的资料。我们就可以在华为云实操一把了。附里云资料地址<a href="https://help.aliyun.com/document_detail/25426.html?spm=a2c4g.11186623.2.4.nTZpwz" target="_blank" rel="noopener">Linux 格式化和挂载数据盘</a></p><ol><li><code>fdisk -l</code>查看服务器是否识别到新硬盘的接入，一般会在最后，返回<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">磁盘 /dev/xvde：<span class="number">536.9</span> GB, <span class="number">536870912000</span> 字节，<span class="number">1048576000</span> 个扇区</span><br><span class="line">Units = 扇区 of <span class="number">1</span> * <span class="number">512</span> = <span class="number">512</span> bytes</span><br><span class="line">扇区大小(逻辑/物理)：<span class="number">512</span> 字节 / <span class="number">512</span> 字节</span><br><span class="line">I/O 大小(最小/最佳)：<span class="number">512</span> 字节 / <span class="number">512</span> 字节</span><br></pre></td></tr></table></figure></li></ol><p>说明识别到一个500多G的硬盘，记录下这个硬盘设备号<code>/dev/xvde</code>(这是个变量，你那里不一定跟我一样)</p><ol start="2"><li><code>fdisk /dev/xvde</code>对上面的新硬盘进行分区操作，这是一个交互式命令，首先输入<code>n</code>，也就是创建新分区的意思，如果就打算分一个区的话，后续就按根据提示输入一路回车，到如下界面：<img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-16%2009.20.59.png" alt="屏幕快照 2018-07-16 09.20.59"><br>此时输入<code>wq</code>将分区表写入磁盘，并退出。会收到提示：<br><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-16%2009.22.56.png" alt="屏幕快照 2018-07-16 09.22.56"></li><li><code>fdisk -l</code>再次执行此命令，可以看到新分区信息（一般在最后）<br><img src="/media/15317042937460.jpg" alt=""></li><li><code>mkfs.ext4 /dev/xvde1</code>将这个分区格式化成ext4文件系统。如图：<br><img src="/media/15317044049926.jpg" alt=""></li><li><code>mount /dev/xvde1 /mnt</code>挂载分区</li><li><code>df -h</code>可以查看到新挂载的分区，此时分区已经可以使用了。但是还没有开机自动挂载，如果要开机自动挂载，还需做第7步</li><li>保险起见，先备份<code>fstab</code>，执行命令<code>cp /etc/fstab /etc/fstab.bak</code>，然后执行<code>echo /dev/xvde1 /mnt ext4 defaults 0 0 &gt;&gt; /etc/fstab</code>。之后即使重启，分区也会自动挂载喽。可以通过<code>df -h</code>看到效果：<br><img src="/media/15317048391668.jpg" alt=""></li></ol>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用了docker之后性能损耗多少？</title>
      <link href="/2018/07/15/loss_in_docker/"/>
      <url>/2018/07/15/loss_in_docker/</url>
      <content type="html"><![CDATA[<p>Docker的一大优势，就是拥有微乎其微的性能损耗，换来良好的硬件资源隔离效果。虽然各大厂商都在主要业务领域使用了Docker，已经从侧面表明Docker的性能损耗不是个什么问题。但是较真的同学，肯定还是想知道Docker到底有没有损耗呢，损耗多少。<br>这里我用PostgreSQL数据库做个简单的对比测试。分别在同一台服务器的Docker内外个各装一个10.3版本的PostgreSQL。然后执行同一个SQL。SQL如下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">with cte as ( <span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">VALUES</span> (uuid_generate_v4(), <span class="string">'xiaoming'</span>,<span class="number">10</span>, <span class="string">'语文'</span>),</span><br><span class="line">      (uuid_generate_v4(), <span class="string">'xiaohong'</span>,<span class="number">12</span>, <span class="string">'数学'</span>),</span><br><span class="line">      (uuid_generate_v4(), <span class="string">'xiaoli'</span>,<span class="number">11</span>, <span class="string">'英语'</span>),</span><br><span class="line">      (uuid_generate_v4(), <span class="string">'xiaozhi'</span>,<span class="number">11</span>, <span class="string">'英语'</span>),</span><br><span class="line">      (uuid_generate_v4(), <span class="string">'xiaoxin'</span>,<span class="number">11</span>, <span class="string">'英语'</span>)</span><br><span class="line">  )</span><br><span class="line">    <span class="keyword">AS</span> tmp (<span class="keyword">id</span>, <span class="keyword">name</span>,age, fav))</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> array_to_json(array_agg(row_to_json(cte)))</span><br><span class="line"><span class="keyword">from</span> cte;</span><br></pre></td></tr></table></figure></p><p>因为不是从硬盘IO，所以这条SQL更贴近于CPU密集型的场景。压测功能是依托JMH开发的，源码已经上传至<a href="https://github.com/aruis/somebenchmark/tree/sqlbench" target="_blank" rel="noopener">https://github.com/aruis/somebenchmark/tree/sqlbench</a>，下面直接看结果：<br><img src="/media/15316574043348.jpg" alt="-w567"><br>可以看到第一行的吞吐量，大概是第二行的95%，亦即是说，在我这个应用场景下，Docker有5%的性能损耗。<br>应该可以给大家做个参考。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用JMH做简单的JVM性能测试</title>
      <link href="/2018/07/14/jmh/"/>
      <url>/2018/07/14/jmh/</url>
      <content type="html"><![CDATA[<p>写java也有年头了，有时候遇到对比某几种方法性能的情景，都是自己傻傻的打印<code>new Date()</code>计算时间差。现在想来，这种原始的方式，就跟不会用IDE Debug，只会<code>System.out.println()</code>打印调试没什么区别。<br>这次被人安利<code>JMH</code>，说来惭愧，是我在Twitter上质疑<code>Vert.x</code>采用了效率不高的Json序列化库，影响了其在<a href="https://www.techempower.com/benchmarks/" target="_blank" rel="noopener">techempower</a>的成绩。结果<a href="https://twitter.com/julienviet" target="_blank" rel="noopener">@julienviet</a>神回复我说”you should make a JMH microbenchmark to find out”，所以才有了这篇，利用JMH做Json序列化速度对比的文章。<br>这是测试结果：<br><img src="/media/15315228604634.jpg" alt="-w783"><br>可以看到<code>Vert.x</code>的Json序列化速度还是出类拔萃的，当然，其本质还是实用的<code>jackson</code><br>上代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aruistar.benchmark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aruistar.benchmark.model.User;</span><br><span class="line"><span class="keyword">import</span> com.jsoniter.output.JsonStream;</span><br><span class="line"><span class="keyword">import</span> groovy.json.JsonBuilder;</span><br><span class="line"><span class="keyword">import</span> groovy.json.JsonOutput;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.Benchmark;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonToStringBenchmark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(JsonToStringBenchmark.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .warmupIterations(<span class="number">2</span>)</span><br><span class="line">                .measurementIterations(<span class="number">3</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    @Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsonObjectToBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> User(<span class="string">"Hello, World!"</span>, <span class="string">"tomcat"</span>, <span class="number">10</span>, <span class="string">"angular"</span>, <span class="keyword">true</span>).toBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsonObjectToString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> User(<span class="string">"Hello, World!"</span>, <span class="string">"tomcat"</span>, <span class="number">10</span>, <span class="string">"angular"</span>, <span class="keyword">true</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsonBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> JsonBuilder(<span class="keyword">new</span> User(<span class="string">"Hello, World!"</span>, <span class="string">"tomcat"</span>, <span class="number">10</span>, <span class="string">"angular"</span>, <span class="keyword">true</span>).getMap()).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsonOutput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JsonOutput.toJson(<span class="keyword">new</span> User(<span class="string">"Hello, World!"</span>, <span class="string">"tomcat"</span>, <span class="number">10</span>, <span class="string">"angular"</span>, <span class="keyword">true</span>).getMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsoniter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JsonStream.serialize(<span class="keyword">new</span> User(<span class="string">"Hello, World!"</span>, <span class="string">"tomcat"</span>, <span class="number">10</span>, <span class="string">"angular"</span>, <span class="keyword">true</span>).getMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aruistar.benchmark.model;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">JsonObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String username, <span class="keyword">int</span> age, String title, <span class="keyword">boolean</span> bool)</span> </span>&#123;</span><br><span class="line">        put(<span class="string">"name"</span>, name);</span><br><span class="line">        put(<span class="string">"age"</span>, age);</span><br><span class="line">        put(<span class="string">"title"</span>, title);</span><br><span class="line">        put(<span class="string">"bool"</span>, bool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码地址，<a href="https://github.com/aruis/somebenchmark" target="_blank" rel="noopener">https://github.com/aruis/somebenchmark</a></p><p>需要注意的是，如果在IDEA打开，想直接通过main方法启动，需要执行如下步骤<br><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">Do you have org.openjdk.jmh:jmh-generator-annprocess on your classpath?</span><br><span class="line">If yes, <span class="keyword">is</span> annotation processing enabled <span class="built_in">in</span> your IDE? You can find the checkbox under</span><br><span class="line">P<span class="function"><span class="title">references</span> -&gt;</span> B<span class="function"><span class="title">uild</span>, Execution, Deployment -&gt;</span> C<span class="function"><span class="title">ompiler</span> -&gt;</span> Annotation Processors</span><br></pre></td></tr></table></figure></p><ul><li>参考[<a href="https://github.com/artyushov/idea-jmh-plugin/issues/13]" target="_blank" rel="noopener">https://github.com/artyushov/idea-jmh-plugin/issues/13]</a></li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL数组类型数据一条sql实现翻译</title>
      <link href="/2018/07/13/postgresql_select_array/"/>
      <url>/2018/07/13/postgresql_select_array/</url>
      <content type="html"><![CDATA[<p>PostgreSQL的ARRAY类型是个非常实用的类型。以往在设计“多选”这种业务场景的时候，要么需要设计子表，要么弄个varchar字段，存放<code>1,3,5</code>这种逗号隔开的数据。现在有了原生支持的ARRAY类型，终于可以大胆的把多选的数据id放在这个字段里了。<br>接踵而至的问题是，如何一次性实现数组字段的数据翻译呢。比如实际数据是<code>{1,3,5}</code>，关联查询后，希望看到<code>{红,黄,蓝}</code><br>话不多说，直接上sql<br><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> app_message.id,app_message.ids_at_auth_user__to,</span><br><span class="line">  <span class="built_in">array_agg</span>(auth_user.v_username) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> app_message.id) <span class="keyword">as</span> av_username_at_auth_user</span><br><span class="line"><span class="keyword">from</span> app_message</span><br><span class="line">  <span class="keyword">join</span> auth_user <span class="keyword">on</span> auth_user.id = <span class="keyword">ANY</span> (ids_at_auth_user__to)</span><br></pre></td></tr></table></figure></p><p><code>app_message</code>是个收发消息表，里面<code>ids_at_auth_user__to</code>字段是个ARRAY，存储了<code>auth_user</code>表的若干个id，代表收件箱的人（多人）<br><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-27%2011.41.45.png" alt="屏幕快照 2018-04-27 11.41.45"></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
