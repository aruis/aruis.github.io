<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Linux防火墙常用命令</title>
      <link href="/2018/08/19/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/08/19/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<ol><li><p>安装防火墙</p> <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> firewalld</span><br></pre></td></tr></table></figure></li><li><p>永久放行端口</p> <figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">firewall</span><span class="literal">-</span><span class="comment">cmd</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">add</span><span class="literal">-</span><span class="comment">port=54321/tcp</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">permanent</span></span><br></pre></td></tr></table></figure><p> <em>临时的话，把–permanent去掉</em></p></li><li><p>使配置生效</p> <figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --reload</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>移除放行端口 <figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">firewall</span><span class="literal">-</span><span class="comment">cmd</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">remove</span><span class="literal">-</span><span class="comment">port=54321/tcp</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">permanent</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li>查看所有放行端口 <figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --list-ports</span></span><br></pre></td></tr></table></figure></li></ol><p>这里只列出最简单的一些用法，更多高阶用法请查看官方文档：<a href="https://firewalld.org/documentation/man-pages/firewall-cmd.html" target="_blank" rel="noopener">https://firewalld.org/documentation/man-pages/firewall-cmd.html</a>    </p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>免开发环境在GitHub站点上快速给开源项目贡献代码</title>
      <link href="/2018/08/18/github-pull-request/"/>
      <url>/2018/08/18/github-pull-request/</url>
      <content type="html"><![CDATA[<p>给开源项目贡献代码应该算是进阶程序员的一条必经之路。今天我就简单介绍一下，如何在不clone代码，不使用本地开发环境的情况下，给GitHub上的开源项目贡献代码。<br>还没有GitHub账号的小伙伴，就抓紧注册个吧，其他就没有任何必要条件了。</p><h3 id="第一步，发现问题"><a href="#第一步，发现问题" class="headerlink" title="第一步，发现问题"></a>第一步，发现问题</h3><p>这个我可教不了，只能介绍一下我自己的经验，就是多看，多想。比如我今天举例的就是<code>JVM</code>下知名项目<code>Vert.x</code>，官方维护的<a href="https://github.com/vert-x3/vertx-examples" target="_blank" rel="noopener">vertx-examples</a>，我发现他在介绍<code>gradle-redeploy</code>的时候，其中<code>build.gradle</code>有一段写得就不够严谨，他是这么写的：</p><figure class="highlight flix"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vert.x will call this task on changes</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doOnChange</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> </span>(System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"windows"</span>)) &#123;</span><br><span class="line">  doOnChange = '.\\gradlew classes'</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doOnChange = './gradlew classes'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过我之前博客的小伙伴应该知道，操作系统的文件分割符，<code>Java</code>中是提供静态方法等多种方式来获取的，不需要通过自己手动判断操作系统的名字来自己实现。所以我决定把这段代码优化一下。也就是这篇博客的起因。</p><h3 id="第二步，Fork代码"><a href="#第二步，Fork代码" class="headerlink" title="第二步，Fork代码"></a>第二步，<code>Fork</code>代码</h3><p>点这里即可：<br><img src="/media/%E7%B2%98%E8%B4%B4%E7%9A%84%E5%9B%BE%E7%89%872018_8_18_14_23.png" alt=""><br><code>Fork</code>成功之后，会自动进入到自己命名空间下的项目<br><img src="/media/15345735455740.jpg" alt=""></p><h3 id="第三步，创建分支"><a href="#第三步，创建分支" class="headerlink" title="第三步，创建分支"></a>第三步，创建分支</h3><p><code>GitHub</code>上的<code>Pull Request</code>都是基于分支的，也就是说想要贡献代码，要先创建一个分支，在上面承载你的代码变更。其实做起来也相当简单，如图：<img src="/media/%E7%B2%98%E8%B4%B4%E7%9A%84%E5%9B%BE%E7%89%872018_8_18_14_28.png" alt=""></p><h3 id="第四步，修改代码"><a href="#第四步，修改代码" class="headerlink" title="第四步，修改代码"></a>第四步，修改代码</h3><p>之后就会进入到自己新建的分支，找到要修改的代码后，点编辑按钮，如图<img src="/media/%E7%B2%98%E8%B4%B4%E7%9A%84%E5%9B%BE%E7%89%872018_8_18_14_32.png" alt=""></p><p>把我之前说的代码改成：</p><figure class="highlight flix"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doOnChange</span> </span>= <span class="string">".$&#123;File.separator&#125;gradlew classes"</span></span><br></pre></td></tr></table></figure><p>一行搞定，是不是简单多了。<br>编辑完代码后，在屏幕最下方，提交代码，注意要写一个理由充分的提交注释，证明你改变代码的必要性<br><img src="/media/15345741245811.jpg" alt=""></p><h3 id="第五步，发起Pull-Request"><a href="#第五步，发起Pull-Request" class="headerlink" title="第五步，发起Pull Request"></a>第五步，发起<code>Pull Request</code></h3><p>把修改<code>commit</code>之后，回到自己的项目首页，就可以看到一句提示，问你要不要把刚修改的那个分支去跟原始项目比较，并且发起<code>pull request</code>，如图<img src="/media/%E7%B2%98%E8%B4%B4%E7%9A%84%E5%9B%BE%E7%89%872018_8_18_14_39.png" alt=""></p><p>点击这个按钮后，进入最后的<code>Open a pull request</code>界面，再次要把提交说明写到位，就可以点<code>Create pull request</code>按钮正式发起贡献代码请求了。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>基本开源项目都有自动化的代码审查，比如单元测试、格式规范检查之类的，发起<code>PR</code>之后也要留意观看，万一发现自己代码有问题，还可以继续更改</li><li>之后还回到自己分支，产生的更改，就不用重新发起<code>PR</code>了，只要<code>commit</code>之后，之前的<code>PR</code>可以直接看到</li><li>一旦<code>PR</code>成功，就可以在原始项目的<code>contributors</code>中找到自己的账户了。希望你到时候可以榜上有名；）</li></ol>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中实现更新默认值（二）</title>
      <link href="/2018/08/17/PostgreSQL%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%9B%B4%E6%96%B0%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/08/17/PostgreSQL%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%9B%B4%E6%96%B0%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>今天我们用<code>表继承</code>+<code>触发器</code>的方案，来实现表中的更新默认值。这也许是<code>PostgreSQL</code>里最佳的解决方案。</p><h4 id="一-创建一张表，作为父表"><a href="#一-创建一张表，作为父表" class="headerlink" title="一. 创建一张表，作为父表"></a>一. 创建一张表，作为父表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> basic_update</span><br><span class="line">(</span><br><span class="line">  t_update <span class="keyword">timestamp</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="二-创建一个函数，用作最后负责修改t-update使用"><a href="#二-创建一个函数，用作最后负责修改t-update使用" class="headerlink" title="二. 创建一个函数，用作最后负责修改t_update使用"></a>二. 创建一个函数，用作最后负责修改<code>t_update</code>使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> update_modified_column()</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  NEW.t_update = <span class="keyword">now</span>();</span><br><span class="line">  RETURN NEW;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$</span><br><span class="line">language 'plpgsql';</span><br></pre></td></tr></table></figure><h4 id="三-创建一个函数，用来给继承了basic-update的表新增一个触发器，怼上第二步的函数"><a href="#三-创建一个函数，用来给继承了basic-update的表新增一个触发器，怼上第二步的函数" class="headerlink" title="三. 创建一个函数，用来给继承了basic_update的表新增一个触发器，怼上第二步的函数"></a>三. 创建一个函数，用来给继承了<code>basic_update</code>的表新增一个触发器，怼上第二步的函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> table_create()</span><br><span class="line">  <span class="keyword">returns</span> event_trigger</span><br><span class="line"><span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">oid</span>           <span class="built_in">INT</span>;</span><br><span class="line">        table_name    VARCHAR;</span><br><span class="line">        parent_tables VARCHAR [];</span><br><span class="line">        is_update     BOOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> object_identity</span><br><span class="line">      <span class="keyword">INTO</span> table_name <span class="keyword">FROM</span> pg_event_trigger_ddl_commands();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> objid</span><br><span class="line">      <span class="keyword">INTO</span> <span class="keyword">oid</span> <span class="keyword">FROM</span> pg_event_trigger_ddl_commands();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> get_parent_tables_by_oid(<span class="keyword">oid</span>)</span><br><span class="line">      <span class="keyword">INTO</span> parent_tables;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> parent_tables :: <span class="built_in">TEXT</span> [] @&gt; <span class="string">'&#123;basic_update&#125;'</span> :: <span class="built_in">TEXT</span> []</span><br><span class="line">      <span class="keyword">INTO</span> is_update;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  IF is_update</span><br><span class="line"></span><br><span class="line">  THEN</span><br><span class="line">    <span class="keyword">EXECUTE</span> <span class="string">'CREATE TRIGGER tgr_auto_t_update'</span></span><br><span class="line">            || <span class="string">' BEFORE UPDATE ON  '</span></span><br><span class="line">            || table_name</span><br><span class="line">            || <span class="string">' FOR EACH ROW EXECUTE PROCEDURE update_modified_column()'</span>;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h4 id="四-创建一个建表时的触发器，接管创建表的时机，怼上第三步的函数"><a href="#四-创建一个建表时的触发器，接管创建表的时机，怼上第三步的函数" class="headerlink" title="四. 创建一个建表时的触发器，接管创建表的时机，怼上第三步的函数"></a>四. 创建一个建表时的触发器，接管创建表的时机，怼上第三步的函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">id</span>        <span class="built_in">varchar</span> <span class="keyword">default</span> uuid_generate_v4() <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">constraint</span> test_pkey</span><br><span class="line">    primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="built_in">text</span>      <span class="built_in">varchar</span>,</span><br><span class="line">  t_create  <span class="keyword">timestamp</span> <span class="keyword">default</span> <span class="keyword">now</span>()</span><br><span class="line">)</span><br><span class="line">  inherits (basic_update);</span><br></pre></td></tr></table></figure><h4 id="五-所有操作已经完成，可以创建一个表测试了"><a href="#五-所有操作已经完成，可以创建一个表测试了" class="headerlink" title="五. 所有操作已经完成，可以创建一个表测试了"></a>五. 所有操作已经完成，可以创建一个表测试了</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">id</span>        <span class="built_in">varchar</span> <span class="keyword">default</span> uuid_generate_v4() <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">constraint</span> test_pkey</span><br><span class="line">    primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="built_in">text</span>      <span class="built_in">varchar</span>,</span><br><span class="line">  t_create  <span class="keyword">timestamp</span> <span class="keyword">default</span> <span class="keyword">now</span>()</span><br><span class="line">)</span><br><span class="line">  inherits (basic_update);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> (<span class="built_in">text</span>)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">text</span> = <span class="string">'b'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中实现更新默认值（一）</title>
      <link href="/2018/08/16/PostgreSQL%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%9B%B4%E6%96%B0%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/08/16/PostgreSQL%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%9B%B4%E6%96%B0%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>业务系统中，经常会在设计表的时候，考虑这两个字段：新增时间、修改时间。前者用数据库的基础功能即可实现，后者就要采取一些手段了。<br>在<code>PostgreSQL</code>中的最佳实践是采用触发器，捕捉<code>UPDATE</code>实践，虽然听起来很可怕，但其实并不难。</p><ol><li><p>首先创建一个函数，作用就是给一行数据，追加某个值（这里我用的字段名是<code>t_update</code>）</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> update_modified_column()</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  NEW.t_update = <span class="keyword">now</span>();</span><br><span class="line">  RETURN NEW;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$</span><br><span class="line">language 'plpgsql';</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>然后就是把这个函数怼到触发器上</p> <figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TRIGGER tgr_auto_t_update</span><br><span class="line">  BEFORE UPDATE</span><br><span class="line">  <span class="keyword">ON</span> a_table</span><br><span class="line">  <span class="keyword">FOR</span> <span class="keyword">EACH</span> ROW EXECUTE <span class="function"><span class="keyword">PROCEDURE</span> <span class="title">update_modified_column</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li></ol><p>这样就大功告成了。但是如果有很多表的话，感觉还是有重复劳动，不够优雅。明天我将结合昨天提到的表继承，最大化的减少工作量，用更优雅的方法实现更新默认值的功能。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中用递归CTE获取一张表的所有祖先表</title>
      <link href="/2018/08/15/PostgreSQL%E4%B8%AD%E7%94%A8%E9%80%92%E5%BD%92CTE%E8%8E%B7%E5%8F%96%E4%B8%80%E5%BC%A0%E8%A1%A8%E7%9A%84%E6%89%80%E6%9C%89%E7%A5%96%E5%85%88%E8%A1%A8/"/>
      <url>/2018/08/15/PostgreSQL%E4%B8%AD%E7%94%A8%E9%80%92%E5%BD%92CTE%E8%8E%B7%E5%8F%96%E4%B8%80%E5%BC%A0%E8%A1%A8%E7%9A%84%E6%89%80%E6%9C%89%E7%A5%96%E5%85%88%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>今天介绍两个知识点：</p><ol><li>PostgreSQL的表继承</li><li>PostgreSQL中的可递归CTE</li></ol><h3 id="表继承"><a href="#表继承" class="headerlink" title="表继承"></a>表继承</h3><p>表继承是PostgreSQL独有的功能，就是在<code>create table</code>的时候可以通过<code>inherits</code>关键字指定若干个父表，如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">id</span>       <span class="built_in">varchar</span> <span class="keyword">default</span> uuid_generate_v4() <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">constraint</span> test_pkey</span><br><span class="line">    primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="built_in">text</span>     <span class="built_in">varchar</span>,</span><br><span class="line">  t_create <span class="keyword">timestamp</span> <span class="keyword">default</span> <span class="keyword">now</span>()</span><br><span class="line">)</span><br><span class="line">  inherits (basic_update);</span><br></pre></td></tr></table></figure><p>继承父表，有如下几个特性：</p><ul><li>父表的字段会自动加入子表中来</li><li>父表上的所有检查约束和非空约束都将自动被它的后代所继承， 除非使用 NO INHERIT子句明确指定。其他类型的约束（唯一、主键和外键约束）则不会被继承</li><li>插入子表的数据，在父表中默认是可以查询到的，除非在对父表查询时，表名前加入<code>only</code>修饰符</li></ul><h3 id="递归CTE"><a href="#递归CTE" class="headerlink" title="递归CTE"></a>递归CTE</h3><p>可选的RECURSIVE修饰符将WITH从单纯的句法便利变成了一种在标准SQL中不能完成的特性。通过使用RECURSIVE，一个WITH查询可以引用它自己的输出。一个非常简单的例子是计算从1到100的整数合的查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">WITH RECURSIVE t(n) AS (</span><br><span class="line">    VALUES (1)</span><br><span class="line">  UNION ALL</span><br><span class="line">    <span class="keyword">SELECT</span> n+<span class="number">1</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> n &lt; <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span>(n) <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure><h3 id="回到今天的主题，PostgreSQL中用递归CTE获取一张表的所有祖先表"><a href="#回到今天的主题，PostgreSQL中用递归CTE获取一张表的所有祖先表" class="headerlink" title="回到今天的主题，PostgreSQL中用递归CTE获取一张表的所有祖先表"></a>回到今天的主题，PostgreSQL中用递归CTE获取一张表的所有祖先表</h3><p>这里我直接通过创建一个函数来封装这个功能，具体逻辑就在函数中，相信有前面两个知识点的铺垫，小伙伴们应该也能看懂了</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> get_parent_tables_by_oid(me <span class="built_in">integer</span>)</span><br><span class="line">  <span class="keyword">returns</span> <span class="built_in">character</span> <span class="built_in">varying</span> []</span><br><span class="line"><span class="keyword">language</span> plpgsql</span><br><span class="line"><span class="keyword">as</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span> parent_tables <span class="built_in">VARCHAR</span> [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> x <span class="keyword">AS</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> pg_inherits <span class="keyword">WHERE</span> inhrelid = me</span><br><span class="line"></span><br><span class="line">      <span class="keyword">UNION</span> ALL</span><br><span class="line"></span><br><span class="line">      <span class="keyword">SELECT</span> pg_inherits.* <span class="keyword">FROM</span> x</span><br><span class="line">                                  <span class="keyword">JOIN</span> pg_inherits <span class="keyword">ON</span> x.inhparent = pg_inherits.inhrelid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> array_agg(pg_stat_user_tables.relname)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">INTO</span> parent_tables</span><br><span class="line"></span><br><span class="line">  <span class="keyword">FROM</span> x</span><br><span class="line">         <span class="keyword">INNER</span> <span class="keyword">JOIN</span> pg_stat_user_tables <span class="keyword">ON</span> x.inhparent = pg_stat_user_tables.relid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  RETURN parent_tables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$$;</span><br></pre></td></tr></table></figure><p>其中<code>inhrelid</code>是<code>PostgreSQL</code>中的一种元数据，可以理解成表的<code>id</code>，在知道表名的情况下怎么知道它的<code>id</code>呢，可以去元数据里面查，如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> relid <span class="keyword">FROM</span> pg_stat_user_tables <span class="keyword">WHERE</span> relname = <span class="string">'a_table'</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vert.x项目监测代码变化自动冷重启</title>
      <link href="/2018/08/14/Vert-x%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%B5%8B%E4%BB%A3%E7%A0%81%E5%8F%98%E5%8C%96%E8%87%AA%E5%8A%A8%E5%86%B7%E9%87%8D%E5%90%AF/"/>
      <url>/2018/08/14/Vert-x%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%B5%8B%E4%BB%A3%E7%A0%81%E5%8F%98%E5%8C%96%E8%87%AA%E5%8A%A8%E5%86%B7%E9%87%8D%E5%90%AF/</url>
      <content type="html"><![CDATA[<p>传统的Java Web开发一般都会提供热重载的方式，方便开发人员在代码发生变化的时候，无需手动重启应用，就可以刷新到效果。用惯了的人，在用<code>Vert.x</code>开发的时候多少会有点不习惯，不过<code>Vert.x</code>程序启动速度还是很可观的，所以也勉强能忍。<br>后来通读文档的时候，发现有个关于<code>redeploy</code>的介绍，似乎能用，又似乎不好用的，直到看到官方的<a href="https://github.com/vert-x3/vertx-examples/tree/master/gradle-redeploy" target="_blank" rel="noopener">Vert.x 3.2 Gradle redeploy project</a>总算豁然开朗了。<br>核心代码无非下面几行<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">// Vert.<span class="keyword">x</span> watches <span class="keyword">for</span> <span class="keyword">file</span> <span class="keyword">changes</span> in <span class="keyword">all</span> subdirectories</span><br><span class="line">// of src/ but <span class="keyword">only</span> <span class="keyword">for</span> <span class="keyword">files</span> with .java extension</span><br><span class="line">def watchForChange = <span class="string">'src/**/*.java'</span></span><br><span class="line"></span><br><span class="line">// Vert.<span class="keyword">x</span> will <span class="keyword">call</span> this task <span class="keyword">on</span> <span class="keyword">changes</span></span><br><span class="line">def doOnChange</span><br><span class="line"><span class="keyword">if</span> (System.getProperty(<span class="string">"os.name"</span>).toLowerCase().contains(<span class="string">"windows"</span>)) &#123;</span><br><span class="line">  doOnChange = <span class="string">'.\\gradlew classes'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doOnChange = <span class="string">'./gradlew classes'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run &#123;</span><br><span class="line">  <span class="keyword">args</span> = [<span class="string">'run'</span>, mainVerticleName, <span class="string">"--redeploy=$watchForChange"</span>, <span class="string">"--launcher-class=$mainClassName"</span>, <span class="string">"--on-redeploy=$doOnChange"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我也尝试了一下，的确可用，但是这个官方示例还是有个地方写的不好，就是关于文件分割符的判断，恰好这个在我之前的帖子里面提到过，见<a href="https://www.kankanzhijian.com/2018/07/26/编写跨操作系统Java代码时动态获取文件分隔符/">编写跨操作系统Java代码时动态获取文件分隔符</a><br>所以上面的<code>gradle</code>代码关于<code>doOnChange</code>声明就可以简化成下面的样子了<br><figure class="highlight flix"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doOnChange</span> </span>= <span class="string">".$&#123;File.separator&#125;gradlew classes"</span></span><br></pre></td></tr></table></figure></p><p>测试成功</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>家长的责任及义务</title>
      <link href="/2018/08/13/%E5%AE%B6%E9%95%BF%E7%9A%84%E8%B4%A3%E4%BB%BB%E5%8F%8A%E4%B9%89%E5%8A%A1/"/>
      <url>/2018/08/13/%E5%AE%B6%E9%95%BF%E7%9A%84%E8%B4%A3%E4%BB%BB%E5%8F%8A%E4%B9%89%E5%8A%A1/</url>
      <content type="html"><![CDATA[<h2 id="身为家长，到底能为孩子做些什么，什么又是最重要的呢"><a href="#身为家长，到底能为孩子做些什么，什么又是最重要的呢" class="headerlink" title="身为家长，到底能为孩子做些什么，什么又是最重要的呢"></a>身为家长，到底能为孩子做些什么，什么又是最重要的呢</h2><h3 id="我认为按重要程度，依次有这几点"><a href="#我认为按重要程度，依次有这几点" class="headerlink" title="我认为按重要程度，依次有这几点"></a>我认为按重要程度，依次有这几点</h3><ol><li>和睦温馨的家庭氛围</li><li>不论工作、学习如何辛苦，始终不忘身体健康是第一要务</li><li>活到老学到老的人生态度</li><li>能够支持孩子从事学习活动的经济基础</li></ol>]]></content>
      
      <categories>
          
          <category> 文艺中年 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教育子女 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分享一个Vert.x的自定义Launcher</title>
      <link href="/2018/08/12/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AAVert-x%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89Launcher/"/>
      <url>/2018/08/12/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AAVert-x%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89Launcher/</url>
      <content type="html"><![CDATA[<p>在<code>Vert.x</code>的官方example中，<code>mainClassName</code>一般是指定的<code>io.vertx.core.Launcher</code>，但是在实际应用中，如果我们也不加思索的用这个<code>Launcher</code>就会损失好多定制性，比如：</p><ul><li>blockedThreadCheckInterval（检查线程block定时时间间隔）</li><li>warningExceptionTime（block多久后开始打印堆栈信息）</li><li>maxEventLoopExecuteTime（允许<code>EventLoop</code>的最长执行时间）</li></ul><p>这些设置都是要在<code>Vertx</code>实例化之前准备好的，只要不是Embedded应用（也就是自己调用<code>Vertx.vertx()</code>），那就只剩接管<code>Launcher</code>这条路了，下面分享一个<code>groovy</code>版的自定义<code>Launcher</code></p><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.vertx.core.Launcher</span><br><span class="line"><span class="keyword">import</span> io.vertx.core.VertxOptions</span><br><span class="line"><span class="keyword">import</span> org.slf4j.bridge.SLF4JBridgeHandler</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">AruisLauncher</span> extends <span class="type">Launcher</span> &#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    static &#123;</span></span><br><span class="line"><span class="class">        <span class="type">SLF4JBridgeHandler</span>.removeHandlersForRootLogger();</span></span><br><span class="line"><span class="class">        <span class="type">SLF4JBridgeHandler</span>.install();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    static void main(<span class="type">String</span>[] <span class="title">args</span>) &#123;</span></span><br><span class="line"><span class="class">        new <span class="type">AruisLauncher</span>().dispatch(<span class="title">args</span>)</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    @<span class="type">Override</span></span></span><br><span class="line"><span class="class">    void beforeStartingVertx(<span class="type">VertxOptions</span> <span class="title">options</span>) &#123;</span></span><br><span class="line"><span class="class">        options.setWarningExceptionTime(10L * 1000 * 1000000)</span></span><br><span class="line"><span class="class">        options.setBlockedThreadCheckInterval(2000)</span></span><br><span class="line"><span class="class">        options.setMaxEventLoopExecuteTime(2L * 1000 * 1000000)</span></span><br><span class="line"><span class="class">        options.workerPoolSize = 20</span></span><br><span class="line"><span class="class">        super.beforeStartingVertx(<span class="title">options</span>)</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>在这个<code>Launcher</code>中，我还额外做了几件事：</p><ul><li>用<code>slf4j</code>接管了<code>Vert.x</code>的日志</li><li>提供一个<code>main</code>方法，方便<code>IDE</code>开发环境启动</li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用pg_cron定时刷新PostgreSQL的物化视图</title>
      <link href="/2018/08/11/%E7%94%A8pg-cron%E5%AE%9A%E6%97%B6%E5%88%B7%E6%96%B0PostgreSQL%E7%9A%84%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE/"/>
      <url>/2018/08/11/%E7%94%A8pg-cron%E5%AE%9A%E6%97%B6%E5%88%B7%E6%96%B0PostgreSQL%E7%9A%84%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p>在<code>PostgreSQL</code>中可以很轻松的创建物化视图，但是却没有自动刷新物化视图的机制。通常来说，不外乎两种方式，一种是通过触发器，另一种就是定时任务调度。今天我们就来说说第二种方式。<br>主要借助一个名为<a href="https://github.com/citusdata/pg_cron" target="_blank" rel="noopener">pg_cron</a>的扩展。<br>安装方法在官方介绍里面已经说的很清楚了，不再赘述，这里提醒一点，安装完后，是需要修改<code>postgresql.conf</code>配置文件，并重启<code>PostgreSQL</code>服务的。具体修改如下：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">shared_preload_libraries = <span class="string">'pg_cron'</span></span><br><span class="line">cron<span class="selector-class">.database_name</span> = <span class="string">'postgres'</span></span><br></pre></td></tr></table></figure></p><p>第二行的指定<code>cron</code>的元数据相关信息存放的数据库，是可以改成其他的。这里要明确一个概念，<code>cron</code>安装的数据库，和它要控制的数据库没有什么必然联系，并不因为说安装在了<code>postgres</code>库，就不能调度其他库了，这个在后续具体配置的时候，就能明白了。<br>做完上述步骤，保证<code>PostgreSQL</code>服务重启过后，就可以用<code>psql</code>或其他工具连接到<code>cron.database_name</code>对应的数据，执行<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">CREATE <span class="keyword">EXTENSION </span>pg_cron<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>如果不在指定的库执行的话，会遇到错误<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Jobs must be scheduled <span class="built_in">from</span> <span class="keyword">the</span> database configured <span class="keyword">in</span> cron.database_name, since <span class="keyword">the</span> pg_cron background worker reads job descriptions <span class="built_in">from</span> this database.</span><br></pre></td></tr></table></figure></p><p>届时注意即可。<br>一切准备就绪后，就可以使用了，使用方式相当简单。这里我用一个查询<code>now()</code>的物化视图做演示<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">materialized</span> <span class="keyword">view</span> <span class="keyword">now</span> <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">now</span>();</span><br><span class="line"><span class="keyword">SELECT</span> cron.schedule(<span class="string">'26 * * * *'</span>, <span class="string">'refresh materialized view now;'</span>);</span><br></pre></td></tr></table></figure></p><p>这就实现了每小时26分的时候去刷新物化视图，也就是意味着，任意时候执行<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">now</span>;</span><br></pre></td></tr></table></figure></p><p>获得的结果，都是距离此刻最近的26分，而不是当前时间。<br>那么，已经创建的任务，该如何管理呢。其实很简单，定时任务数据都存放在<code>cron.job</code>表中，我们看看里面的数据就明白了。<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">+<span class="params">---------</span>+<span class="params">------------</span>+<span class="params">--------------------------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+</span><br><span class="line">| jobid   | schedule   | <span class="keyword">command</span>                        | nodename   | nodeport   | database   | username   |</span><br><span class="line">|<span class="params">---------</span>+<span class="params">------------</span>+<span class="params">--------------------------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>|</span><br><span class="line">| 1       | 26 * * * * | refresh materialized view now; | localhost  | 5432       | analyze    | postgres   |</span><br><span class="line">+<span class="params">---------</span>+<span class="params">------------</span>+<span class="params">--------------------------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+<span class="params">------------</span>+</span><br></pre></td></tr></table></figure></p><p>如果要取消一个任务，就需要拿到<code>jobid</code>，然后执行下面这句就好了。<br><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> cron.unschedule(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL修改FDW相关配置</title>
      <link href="/2018/08/10/PostgreSQL%E4%BF%AE%E6%94%B9FDW%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/08/10/PostgreSQL%E4%BF%AE%E6%94%B9FDW%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>必要的时候要修改<code>PostgreSQL</code>中配置的外部服务器。有个<code>ALTER SERVER</code>命令是专门应对这种场景的。比如我的外部数据源服务器地址换了，只需要改下之前配置的<code>host</code>地址即可，<code>SQL</code>如下<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">ALTER SERVER foreign_server <span class="keyword">OPTIONS</span> (<span class="keyword">set</span> host <span class="comment">'192.168.0.88'</span><span class="comment">)</span>;</span><br></pre></td></tr></table></figure></p><p>更多内容可以查看官方文档[<a href="http://www.postgres.cn/docs/9.6/sql-alterserver.html]" target="_blank" rel="noopener">http://www.postgres.cn/docs/9.6/sql-alterserver.html]</a></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中的distinct on</title>
      <link href="/2018/08/09/PostgreSQL%E4%B8%AD%E7%9A%84distinct-on/"/>
      <url>/2018/08/09/PostgreSQL%E4%B8%AD%E7%9A%84distinct-on/</url>
      <content type="html"><![CDATA[<p>想象有这么一张表，存放若干学生不同课程的考试成绩，需求是，找出每门课程中，成绩最好的学生。原始表大概如下：</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+--------------------------------------+-----------------+----------------+-----------+</span><br><span class="line">|<span class="string"> id                                   </span>|<span class="string"> v_studentname   </span>|<span class="string"> v_coursename   </span>|<span class="string"> i_score   </span>|</span><br><span class="line">|<span class="string">--------------------------------------+-----------------+----------------+-----------</span>|</span><br><span class="line">|<span class="string"> fb9fe43a-6f57-4f92-8678-139167693e72 </span>|<span class="string"> 张三            </span>|<span class="string"> 语文           </span>|<span class="string"> 91        </span>|</span><br><span class="line">|<span class="string"> 0898afd7-4253-496e-9190-36fae14bddf2 </span>|<span class="string"> 张三            </span>|<span class="string"> 数学           </span>|<span class="string"> 77        </span>|</span><br><span class="line">|<span class="string"> 2a1f810d-55ee-42cc-ac17-ee970154cecb </span>|<span class="string"> 张三            </span>|<span class="string"> 英语           </span>|<span class="string"> 90        </span>|</span><br><span class="line">|<span class="string"> fa975cd4-af5f-49d0-a89e-6f88665629eb </span>|<span class="string"> 李四            </span>|<span class="string"> 语文           </span>|<span class="string"> 88        </span>|</span><br><span class="line">|<span class="string"> 8833a07c-de8d-4b15-aa34-d9340c2e82c3 </span>|<span class="string"> 李四            </span>|<span class="string"> 数学           </span>|<span class="string"> 87        </span>|</span><br><span class="line">|<span class="string"> 1a9dfbdf-7c44-45d7-8141-590203aa26a9 </span>|<span class="string"> 李四            </span>|<span class="string"> 英语           </span>|<span class="string"> 89        </span>|</span><br><span class="line">|<span class="string"> cd3ec937-0ab9-4745-ad1a-c9f85839eaeb </span>|<span class="string"> 王五            </span>|<span class="string"> 语文           </span>|<span class="string"> 89        </span>|</span><br><span class="line">|<span class="string"> 431b7ccd-3a25-4ff4-9cc2-2e9f111f5c06 </span>|<span class="string"> 王五            </span>|<span class="string"> 数学           </span>|<span class="string"> 91        </span>|</span><br><span class="line">|<span class="string"> 8021e41d-09f5-49fb-a9e2-750d14bbff50 </span>|<span class="string"> 王五            </span>|<span class="string"> 英语           </span>|<span class="string"> 79        </span>|</span><br><span class="line">+--------------------------------------+-----------------+----------------+-----------+</span><br></pre></td></tr></table></figure><h2 id="传统方案"><a href="#传统方案" class="headerlink" title="传统方案"></a>传统方案</h2><p>传统的方法，要找每门课程成绩最好的学生的话，需要借助聚合函数，而且要几步操作：</p><ol><li><p>找到每门课程的最好成绩</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">select v_coursename, max(i_score)</span><br><span class="line"><span class="keyword">from</span> achievement</span><br><span class="line">group by v_coursename;</span><br></pre></td></tr></table></figure></li><li><p>再跟<code>achievement</code>表<code>join</code>，才能找到该课程最高分对应的学生姓名。即使在有<code>CTE</code>支持的情况下，实现起来也很复杂</p> <figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">with cte as (<span class="keyword">select</span> v_coursename, <span class="built_in">max</span>(i_score) <span class="keyword">as</span> i_score <span class="keyword">from</span> achievement <span class="keyword">group</span> <span class="keyword">by</span> v_coursename)</span><br><span class="line"><span class="keyword">select</span> cte.*, achievement.v_studentname</span><br><span class="line"><span class="keyword">from</span> cte</span><br><span class="line">       <span class="keyword">join</span> achievement <span class="keyword">on</span> cte.i_score = achievement.i_score <span class="keyword">and</span> cte.v_coursename = achievement.v_coursename</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> cte.v_coursename;</span><br></pre></td></tr></table></figure><p> 要是没有<code>CTE</code>的支持，估计用纯数据库实现，就捉襟见肘了。</p></li></ol><h2 id="使用distinct-on的方案"><a href="#使用distinct-on的方案" class="headerlink" title="使用distinct on的方案"></a>使用distinct on的方案</h2><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">on</span> (v_coursename) * </span><br><span class="line"><span class="keyword">from</span> achievement</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> v_coursename, i_score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>一句话解决，是不是很开森。</p><h4 id="原理回顾"><a href="#原理回顾" class="headerlink" title="原理回顾"></a>原理回顾</h4><p><code>DISTINCT ON</code>是将结果集按指定字段值的去重，具体实现方法是先对结果集按照<code>DISTINCT ON</code>指定的字段进行排序，然后筛选出每个字段第一次出现时所在的记录，其余的记录都剔除。<br><code>ON</code>修饰符支持多列，运算时会基于多列的总体唯一性进行去重操作。同时查询语句必须要有<code>ORDER BY</code>，并且要保证排序字段从左至右的的顺序，应该是跟<code>DISTINCT ON</code>命中字段顺序相符合，当然<code>ORDER BY</code>可以追加更多的字段。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux软硬链接使用心得</title>
      <link href="/2018/08/08/Linux%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
      <url>/2018/08/08/Linux%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
      <content type="html"><![CDATA[<p><code>ln</code>命令，涉及到的软硬链接的核心概念已经被阐述的很多了。但是用的时候，到底用软链接，还是用硬链接，有时候还是会让人摸不着头绪。所以我尝试总结几点：</p><ol><li>软硬链接都能起到原始文件只占用一份磁盘资源的目的</li><li>硬链接不能针对文件夹，软链接无此限制</li><li>硬链接可以起到备份的作用，只要有硬链接在，原始文件就能访问；软链接无此效果</li><li>不论软链接，硬链接，<code>chmod</code>做的权限变更都具有传递性</li><li>软链接有个坑，如果原始文件删除之后，再创建一个同名的文件，软链接还会莫名其妙建立链接，这可能不一定是我们需要的</li></ol>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL删除数据库时提示other session using the database</title>
      <link href="/2018/08/07/PostgreSQL%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E6%8F%90%E7%A4%BAother-session-using-the-database/"/>
      <url>/2018/08/07/PostgreSQL%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E6%8F%90%E7%A4%BAother-session-using-the-database/</url>
      <content type="html"><![CDATA[<p>PostgreSQL中，如果想drop一个正在被人连接的数据库，是不可以的。提示如下：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">postgres</span>=# drop database ka;</span><br><span class="line">ERROR:  database <span class="string">"ka"</span> is being accessed by other users</span><br><span class="line">DETAIL:  There is 1 other session using the database</span><br></pre></td></tr></table></figure></p><p>应对方法是要通过<code>pg_terminate_backend</code>系统内置函数，把对应库在线连接给清理掉，使用方法如下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pg_terminate_backend(pg_stat_activity.pid)</span><br><span class="line">    <span class="keyword">FROM</span> pg_stat_activity</span><br><span class="line">    <span class="keyword">WHERE</span> pg_stat_activity.datname = <span class="string">'ka'</span></span><br><span class="line">      <span class="keyword">AND</span> pid &lt;&gt; pg_backend_pid();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cordova插件中定制build.gradle的方法</title>
      <link href="/2018/08/06/cordova%E6%8F%92%E4%BB%B6%E4%B8%AD%E5%AE%9A%E5%88%B6build-gradle%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/06/cordova%E6%8F%92%E4%BB%B6%E4%B8%AD%E5%AE%9A%E5%88%B6build-gradle%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>编写<code>cordova</code>插件的时候，有时候要有进一步设置<code>build.gradle</code>文件的需求，比如追加个依赖什么的。这中问题，可以通过设置<code>cordova</code>的<code>plugin.xml</code>来解决的。分为如下几个步骤：</p><ol><li><p>编写cordova.build文件，文件名可以随便叫，内容就放你需要追加的个性化内容，比如我的是</p> <figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            jniLibs.srcDirs = [<span class="string">'libs'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>plugin.xml</code>文件中<code>&lt;platform name=&quot;android&quot;&gt;&lt;/platform&gt;</code>区域内追加配置</p> <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;framework <span class="attribute">src</span>=<span class="string">"src/android/cordova.gradle"</span> <span class="attribute">custom</span>=<span class="string">"true"</span> <span class="attribute">type</span>=<span class="string">"gradleReference"</span>/&gt;</span><br></pre></td></tr></table></figure></li></ol><p>更多信息可以查阅文档 <a href="https://cordova.apache.org/docs/en/latest/plugin_ref/spec.html" target="_blank" rel="noopener">https://cordova.apache.org/docs/en/latest/plugin_ref/spec.html</a></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cordova </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于Geb的京东抢券</title>
      <link href="/2018/08/05/%E5%9F%BA%E4%BA%8EGeb%E7%9A%84%E4%BA%AC%E4%B8%9C%E6%8A%A2%E5%88%B8/"/>
      <url>/2018/08/05/%E5%9F%BA%E4%BA%8EGeb%E7%9A%84%E4%BA%AC%E4%B8%9C%E6%8A%A2%E5%88%B8/</url>
      <content type="html"><![CDATA[<p>前面介绍过<a href="http://gebish.org" target="_blank" rel="noopener">Geb</a>是个好东西，可以用它实现web前端的自动化测试，自然用来解放双手，抢个券什么的不在话下。<br>这次我们主要瞄准京东。最佳的实验场所是京东的移动web版，即<a href="https://m.jd.com/" target="_blank" rel="noopener">https://m.jd.com/</a>，大概分为以下几个步骤：</p><ol><li>打开京东首页</li><li>点击登录按钮</li><li>填写登录用户名密码并登录</li><li>调整到需要抢券的页面</li><li>找到抢券按钮开抢</li></ol><p>下面贴一个，618某活动的抢券代码（现在已经下线了），仅供参考。<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"> static <span class="function"><span class="keyword">def</span> <span class="title">checkin</span><span class="params">(String username, String password)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FirefoxBinary firefoxBinary = new FirefoxBinary();</span><br><span class="line">/<span class="regexp">/        firefoxBinary.addCommandLineOptions("--headless");</span></span><br><span class="line"><span class="regexp">        FirefoxOptions firefoxOptions = new FirefoxOptions();</span></span><br><span class="line"><span class="regexp">        firefoxOptions.setBinary(firefoxBinary);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        def browser = new Browser(driver: new FirefoxDriver(firefoxOptions))</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        browser.with &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            go "https:/</span><span class="regexp">/m.jd.com"</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            $(".jd-search-icon-login").click()</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            $("#username").value(username)</span></span><br><span class="line"><span class="regexp">            $("#password").value(password)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            $("#loginBtn").click()</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            sleep(5000)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            go "https:/</span><span class="regexp">/pro.m.jd.com/mall</span><span class="regexp">/active/q</span>KRVTAJL7v93L71TkJebPv5GJnE/index.html<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            $("</span><span class="comment">#m_1_14").children().each &#123;</span></span><br><span class="line">                it.click()</span><br><span class="line">                sleep(<span class="number">500</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>补充几个说明：</p><ol><li>我用的是<code>Firefox</code>浏览器。所以需要电脑事先装好该浏览器。</li><li>只装浏览器还不够，还需要相应的<code>WebDriver</code>驱动。如果找不到程序会报错的，可以根据错误提示下载该驱动。然后要把本地驱动文件地址设置一下，方便<code>Geb</code>识别，代码如下<code>System.setProperty(&quot;webdriver.gecko.driver&quot;, &quot;/root/geckodriver&quot;)</code></li><li><strong>无节目的Linux服务器可不可用呢？答案是可以</strong>，在安装完上面两样东西之后，只需要代码里添加<code>firefoxBinary.addCommandLineOptions(&quot;--headless&quot;);</code>就可以启动无界面的<code>Firefox</code>了</li></ol><h4 id="友情提醒"><a href="#友情提醒" class="headerlink" title="友情提醒"></a>友情提醒</h4><p>工具抢券也好、代码抢券也好，都是一种对普通消费者不公平的存在。建议学会之后，自用练手即可，切勿以此牟利。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Geb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM下最好用的前端自动化测试工具Geb</title>
      <link href="/2018/08/04/JVM%E4%B8%8B%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Geb/"/>
      <url>/2018/08/04/JVM%E4%B8%8B%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Geb/</url>
      <content type="html"><![CDATA[<p>接触了<code>Angular</code>才知道前端有个端到端测试的说法，然后了解到有<code>WebDriver</code>这种神奇的存在，瞬间打开了新世纪的大门。后来几经寻觅，终于发现一个运行在<code>JVM</code>中的前端测试工具，那就是<a href="http://gebish.org" target="_blank" rel="noopener">Geb</a>。<br>来段代码：<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">import</span> geb.<span class="keyword">Browser</span></span><br><span class="line"><span class="keyword"> </span></span><br><span class="line"><span class="keyword">Browser.drive </span>&#123;</span><br><span class="line">    go <span class="string">"http://myapp.com/login"</span></span><br><span class="line">     </span><br><span class="line">    <span class="meta">assert</span> $(<span class="string">"h1"</span>)<span class="meta">.text</span>() == <span class="string">"Please Login"</span></span><br><span class="line">     </span><br><span class="line">    $(<span class="string">"form.login"</span>).with &#123;</span><br><span class="line">        username = <span class="string">"admin"</span></span><br><span class="line">        password = <span class="string">"password"</span></span><br><span class="line">        login().click()</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">assert</span> $(<span class="string">"h1"</span>)<span class="meta">.text</span>() == <span class="string">"Admin Section"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是很易懂，一个有<code>Java</code>与<code>jQuery</code>基础的人应该非常容易上手。<br>还记得那个阿里员工抢月饼事件么，估计看了新闻之后，前端程序员都会觉得0门槛，但是后端程序员，可能就会觉得自己的技术栈鞭长莫及了。有了<code>Geb</code>，我们能做的事情会更多，也会更加方便。下一篇，我将介绍如何用<code>Geb</code>来实现京东抢券。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Geb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中的几中常见索引及应用场景</title>
      <link href="/2018/08/03/PostgreSQL%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2018/08/03/PostgreSQL%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h2><p><code>B-tree</code>是关系型数据库中，最常见的索引，也是<code>PostgreSQL</code>中经常采用的默认索引。主要应对场景：</p><ul><li>主键</li><li>唯一性约束</li><li>等值比较</li><li>范围查询</li><li>null判断</li></ul><h2 id="GiST"><a href="#GiST" class="headerlink" title="GiST"></a>GiST</h2><p>全称Generalized Search Tree，大白话就是通用搜索树。这是一种<strong>有损</strong>索引，主要应对非结构化数据，比如空间、全文检索什么的。主要应对场景：</p><ul><li>几何类型数据</li><li>范围类型数据</li><li>ltree类型数据</li><li>总之就是要用到不局限于<code>&lt;、&lt;=、=、 &gt;=、&gt;</code>这几种操作符时，要考虑<code>GiST</code>索引</li><li><code>GiST</code>跟<code>B-tree</code>并不矛盾，可以把<code>GiST</code>当作一种补充来用，效果更好</li></ul><h2 id="GIN"><a href="#GIN" class="headerlink" title="GIN"></a>GIN</h2><p>全称Generalized Inverted Index，通用逆序索引。它是从<code>GiST</code>派生出来的一种索引，比<code>GiST</code>最大的优势是无损，也就是说如果要查询的数据都被索引，就可以从索引中直接获取查询结果。<code>GIN</code>索引的缺点是更新操作时，多出一个字段值复制的动作，这点不及<code>GiST</code>的速度快。另外就是它不能对大对象类型索引，比如hstore、text里面有大对象，就不适合用<code>GIN</code>了。主要应对场景：</p><ul><li>jsonb数据类型</li><li>数组数据类型</li><li>配合<code>create extension pg_trgm</code>对<code>varchar</code>模糊查询</li></ul><h2 id="SP-GiST"><a href="#SP-GiST" class="headerlink" title="SP-GiST"></a>SP-GiST</h2><p>SP是Space-Partitioning的简写，也就是说本索引是基于空间分区树算法的GiST索引。与<code>GiST</code>的应用场领域高度重叠，好处就是针对某些领域的特定算法，其效率要高一些。目前支持该索引的类型主要有：</p><ul><li>point</li><li>box</li><li>text</li><li>range</li><li>network</li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>PostgreSQL已将<code>Hash</code>索引列为不推荐使用状态。只能实现<code>=</code>运算相关判断。</p><p>想了解更多索引的应用范围，完全可以在<code>PostgreSQL</code>的元数据中找到答案。尝试执行这个<code>SQL</code>吧<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">SELECT am<span class="selector-class">.amname</span> AS index_method,</span><br><span class="line">       opf<span class="selector-class">.opfname</span> AS opfamily_name,</span><br><span class="line">       amop<span class="selector-class">.amopopr</span>::regoperator AS opfamily_operator</span><br><span class="line">FROM pg_am am, pg_opfamily opf, pg_amop amop</span><br><span class="line">WHERE opf<span class="selector-class">.opfmethod</span> = am<span class="selector-class">.oid</span> AND</span><br><span class="line">      amop<span class="selector-class">.amopfamily</span> = opf.oid</span><br><span class="line">ORDER BY index_method, opfamily_name, opfamily_operator</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中varchar类型like前置%查询命中索引的方法</title>
      <link href="/2018/08/02/PostgreSQL%E4%B8%ADvarchar%E7%B1%BB%E5%9E%8Blike%E5%89%8D%E7%BD%AE-%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/02/PostgreSQL%E4%B8%ADvarchar%E7%B1%BB%E5%9E%8Blike%E5%89%8D%E7%BD%AE-%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>上一篇中，我们学习了<code>PostgreSQL</code>中想要让<code>varchar</code>类型支持<code>like</code>查询能够命中索引，需要注意的地方。但是即便是创建索引时，指定了操作符类<code>varchar_pattern_ops</code>，在使用<code>like</code>查询的时候，还是只能保证<code>sometext%</code>这种查询能够命中索引，但是<code>%sometext</code>这种是无能为力的，见下图。<br><img src="/media/15331709094483.jpg" alt=""><br><img src="/media/15331709707728.jpg" alt=""><br>所以如果需要支持<code>%sometext</code>方式的索引查询，还需要再做点工作：</p><ol><li><code>create extension pg_trgm;</code></li><li><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> log_action_v_uri_index  <span class="keyword">ON</span>  log_action <span class="keyword">using</span> gist (v_uri gist_trgm_ops);</span><br></pre></td></tr></table></figure></li><li><p>上面<code>gist</code>索引时有损的，后来研究支持，发现<code>gin</code>更合适，速度更快 <strong>强烈推荐</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> table_name_md5_index  <span class="keyword">ON</span> table_name <span class="keyword">using</span> gin (<span class="keyword">md5</span> gin_trgm_ops);</span><br></pre></td></tr></table></figure></li></ol><p>然后重新执行<code>explain</code>，就能看到命中索引了<br><img src="/media/15331719609935.jpg" alt=""></p><p>关于<code>btree</code>索引与<code>gist</code>索引的应用场景，我们以后再探讨。 现在我们先看看同样支持<code>sometext%</code>查询命中索引的情况下，我们该用哪种呢。</p><ol><li>首先是查询速度，这次我们换百万行的数据来测试<ul><li>先看<code>btree</code>的<img src="/media/15331926585276.jpg" alt=""></li><li>再看<code>gist</code>的<img src="/media/15331926156740.jpg" alt=""></li><li>直观来看，采用<code>gist</code>索引规划期给的时间是更快的。但是如果采用<code>explain analyse</code>尝试获取真实结果的话，答案就恰恰相反了</li><li>先看<code>btree</code><img src="/media/15331929892802.jpg" alt=""></li><li>再看<code>gist</code><img src="/media/15331930513697.jpg" alt=""></li><li>结果匪夷所思，在<code>gist</code>索引的情况下，不论怎么测试，最终的<code>Execution time</code>都保持在500ms以上。而<code>btree</code>实际执行时间才1ms多。我尝试重启数据库，来保证数据没有缓存，但是<code>btree</code>反馈的实际执行时间也不过就11ms多，之后又会下降了1ms量级。这其中的原因，是因为<code>gist</code>是一种有损索引，所以不能像<code>btree</code>索引那样，直接把值取出来。</li><li><strong>结论：通常情况下btree的查询速度会远好于gist，但是如果gist索引列只参与条件判断，不参与select，gist的速度还是比较理想的</strong></li></ul></li><li>然是是创建索引的速度<ul><li>先看<code>btree</code><img src="/media/15331936107582.jpg" alt=""></li><li>再看<code>gist</code><img src="/media/15331936413004.jpg" alt=""></li><li><strong>结论：创建索引的速度，btree远好于gist</strong></li></ul></li><li>还有功能上<strong>gist索引不支持=查询，也就是如果除了模糊匹配，还需要精确匹配的话，必须引入btree索引</strong></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><code>varchar</code>类型，如果需要模糊查询，需要这么来</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> table_name_md5_index_btree <span class="keyword">ON</span> table_name (<span class="keyword">md5</span> text_pattern_ops);</span><br></pre></td></tr></table></figure><p>  但是此方案只支持<code>左锚定</code></p></li><li><p>如果需要不局限于<code>左锚定</code>的模糊查询，还需要这么来</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> extension pg_trgm;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> table_name_md5_index  <span class="keyword">ON</span> table_name <span class="keyword">using</span> gin (<span class="keyword">md5</span> gin_trgm_ops);</span><br></pre></td></tr></table></figure></li><li><p>如果还需要精确等值查询，请务必保留<code>btree</code>索引</p></li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL中varchar类型支持like查询索引</title>
      <link href="/2018/08/01/PostgreSQL%E4%B8%ADvarchar%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81like%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95/"/>
      <url>/2018/08/01/PostgreSQL%E4%B8%ADvarchar%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81like%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<p>之前在使用<code>PostgreSQL</code>中的<code>varchar</code>类型时想当然的以为用最基本的索引创建语句创建的索引，就支持<code>like</code>查询的。<br>类似这句：<br><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> log_action_v_uri_index <span class="keyword">ON</span> log_action (v_uri);</span><br></pre></td></tr></table></figure></p><p>但是看过<code>explain</code>才知道，单凭这样的索引，在<code>like</code>搜索的时候，仍然是顺序全表扫描，如图：<br><img src="/media/15330845808519.jpg" alt=""><br>后来google了一下解决方案，原来是创建索引的时候追加一下参数，应该这么创建<br><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> log_action_v_uri_index <span class="keyword">ON</span> log_action (v_uri varchar_pattern_ops);</span><br></pre></td></tr></table></figure></p><p>然后对同样的语句再次<code>explain</code>结果如下：<br><img src="/media/15330848868005.jpg" alt=""><br>可以看到，已经命中索引了。<br>这其中涉及到一个重要的知识点，就是<code>PostgreSQL</code>的索引<em>操作符类</em> ，其标准语法为<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="keyword">name</span> <span class="keyword">ON</span> <span class="keyword">table</span> (<span class="keyword">column</span> opclass [<span class="keyword">sort</span> options] [, ...]);</span><br></pre></td></tr></table></figure></p><p>这个<code>opclass</code>可以针对不同的数据类型和查询方式提供多种多样的方案，<br><img src="/media/15330861199315.jpg" alt=""><br>可以看到光<code>btree</code>索引有关的操作符类就非常多，有些<code>is_default</code>是<code>true</code>也就是正好列类型吻合的话，这个操作符类就不要特意说明了。而<code>varchar</code>或者<code>text</code>的默认用的是<code>text_ops</code>，它支持的查询方式仅有<br><img src="/media/15330876281185.jpg" alt=""><br>所以想用模糊查询的话，还是得用<code>text_pattern_ops</code>或者<code>varchar_pattern_ops</code>(这哥俩是一个东西)，它支持正则模糊匹配，也支持<code>like %</code>的方式<br><img src="/media/15330878032471.jpg" alt=""></p><ul><li>更多信息，可以查看官方文档<a href="http://www.postgres.cn/docs/9.6/indexes-opclass.html" target="_blank" rel="noopener">操作符类和操作符族</a></li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IntelliJ IDEA中的SQL Explain</title>
      <link href="/2018/07/31/IntelliJ-IDEA%E4%B8%AD%E7%9A%84SQL-Explain/"/>
      <url>/2018/07/31/IntelliJ-IDEA%E4%B8%AD%E7%9A%84SQL-Explain/</url>
      <content type="html"><![CDATA[<p>善于利用<code>SQL</code>的<code>explain</code>是<code>SQL</code>调整优化的必经之路。但是遇到复杂的<code>SQL</code>，查看<code>explain</code>结果也是有点困难的。比如这样的：<br><img src="/media/15329969004233.jpg" alt=""><br>好在很多数据库的客户端都提供了图形化的表现形式，比如<code>PostgreSQL</code>的<code>pgAdmin4</code>就能看到如下效果：<br><img src="/media/15329972711011.jpg" alt=""><br>不过如果有个工具，能够hold住所有主流的关系型数据库的话，就更嗨皮了。答案就是<code>IntelliJ IDEA</code>。如果你还没有尝试过其自带的<code>Database</code>功能的话，推荐现在就试一下。在屏幕右侧应该能找到。<br><img src="/media/15329976430336.jpg" alt=""><br>只需要按照向导添加相应的数据库连接就好了。不过这个功能免费的社区版是没有的。<br>创建完数据库链接后，通过此按钮打开<code>SQL Console</code>窗口<br><img src="/media/15329978378217.jpg" alt=""><br>然后在里面就可以愉快的编写<code>SQL</code>了。<br>先来一段：<br><img src="/media/15329983218004.jpg" alt=""><br>现在我们可以尝试通过<code>IntelliJ IDEA</code>执行一次<code>explain</code>了。</p><ul><li>先把光标移动到需要<code>explain</code>的<code>SQL</code>上</li><li>右键呼出菜单，找到<img src="/media/15329984643618.jpg" alt="">   执行之</li><li>就能看到效果了<img src="/media/15329985590089.jpg" alt=""></li><li>点击<code>Show Visualisation</code>可以呼出图形化展示<img src="/media/15329987110873.jpg" alt=""></li><li>如果觉得这个功能实用的话，可以给它设置一个快捷键，方法如下<ul><li>呼出<code>Find Action...</code>窗口（快捷键：⇧⌘A），在<code>Help</code>菜单下能找到</li><li>搜索到<code>explain</code><img src="/media/15329989448215.jpg" alt=""></li><li>按快捷键⌥↩︎，或者windows下的<code>alt+回车</code></li><li>就可以设置一个快捷键了<img src="/media/15329990816786.jpg" alt=""></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>启动Docker容器后要注意的时区问题</title>
      <link href="/2018/07/30/%E5%90%AF%E5%8A%A8Docker%E5%AE%B9%E5%99%A8%E5%90%8E%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/30/%E5%90%AF%E5%8A%A8Docker%E5%AE%B9%E5%99%A8%E5%90%8E%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>对于中国用户来说，一般的docker容器启动后，如果执行<code>docker  exec -it xxxx date</code>会发现打印出来的时间，比当前北京时间早八个小时。所以需要调整容器的时区，主要有两个命令（要在容器内部执行）：</p><ul><li><code>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></li><li><code>echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</code></li></ul><p>其中第一个命令就能解决不少问题，比如我用<code>PostgreSQL</code>的话，<code>select now()</code>就可以通过第一条命令修正。但是<code>Tomcat</code>等java相关的程序，还需要第二条命令，才能获得正确的时间。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>tomcat中URL中文乱码问题</title>
      <link href="/2018/07/29/tomcat%E4%B8%ADURL%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/29/tomcat%E4%B8%ADURL%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>找到<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attribute">port</span>=<span class="string">"8080"</span> <span class="attribute">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attribute">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>追加配置为<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attribute">port</span>=<span class="string">"8080"</span> <span class="attribute">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attribute">redirectPort</span>=<span class="string">"8443"</span> <span class="attribute">URIEncoding</span>=<span class="string">"UTF-8"</span>/&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乱码 </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>被忽略的IntelliJ IDEA常用快捷键</title>
      <link href="/2018/07/28/%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84IntelliJ-IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2018/07/28/%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84IntelliJ-IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<ul><li>跳转到方法声明处 （Go to declaration） ⌘B</li><li>快速查看声明（Open quick definition lookup）⇧⌘I</li><li>快速查看文档（Quick documentation lookup）^J</li><li>块级注释（Comment/uncomment with block comment）^⇧/</li><li>查找被调用处（Show usages）⌥⌘F7</li><li>在本文件高亮引用，可以用在return上（Highlight usages in file）⇧⌘F7</li><li>弹出重构窗口 ⌥⇧⌘T</li><li>补全代码（Complete statement）⇧⌘↩︎</li><li>查找功能（Find Action…）⇧⌘A，紧接着如果要给找到的功能设置快捷键，就继续⌥↩︎</li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>制作macOS启动U盘命令</title>
      <link href="/2018/07/27/%E5%88%B6%E4%BD%9CmacOS%E5%90%AF%E5%8A%A8U%E7%9B%98%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/07/27/%E5%88%B6%E4%BD%9CmacOS%E5%90%AF%E5%8A%A8U%E7%9B%98%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo <span class="string">/Applications/Install</span>\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia <span class="params">--volume</span> <span class="string">/Volumes/Sierra</span> <span class="params">--applicationpath</span> <span class="string">/Applications/Install</span>\ macOS\ High\ Sierra.app <span class="params">--nointeraction</span></span><br></pre></td></tr></table></figure><p>其中<code>/Volumes/Sierra</code>的<code>Sierra</code>是U盘的命名。如下图所示。<br><img src="/media/15326512660951.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编写跨操作系统Java代码时动态获取文件分隔符</title>
      <link href="/2018/07/26/%E7%BC%96%E5%86%99%E8%B7%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FJava%E4%BB%A3%E7%A0%81%E6%97%B6%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%88%86%E9%9A%94%E7%AC%A6/"/>
      <url>/2018/07/26/%E7%BC%96%E5%86%99%E8%B7%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FJava%E4%BB%A3%E7%A0%81%E6%97%B6%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%88%86%E9%9A%94%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h3 id="大概有以下几种思路"><a href="#大概有以下几种思路" class="headerlink" title="大概有以下几种思路"></a>大概有以下几种思路</h3><ol><li><code>File.separator</code>系统相关的默认名称分隔符，为方便起见，表示为字符串。 该字符串包含单个字符，即separatorChar。</li><li><code>FileSystems.getDefault().getSeparator()</code>返回名称分隔符，表示为字符串。<br>名称分隔符用于分隔路径字符串中的名称。 实现可能支持多个名称分隔符，在这种情况下，此方法返回特定于实现的默认名称分隔符。 通过调用toString（）方法创建路径字符串时使用此分隔符。<br>对于默认提供程序，此方法返回与java.io.File.separator相同的分隔符。</li><li><code>System.getProperty(&quot;file.separator&quot;)</code></li></ol><p>正常情况下，选择第一种，就ok了。第二种是在Java7时代追加的，功能更为强大。第三种也不错，因为额外提供通过<code>-Dfile.separator=</code>参数来指定的特性。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux免密登录不起作用解决办法</title>
      <link href="/2018/07/25/linux%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2018/07/25/linux%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>已经把公钥添加到<code>~/.ssh/authorized_keys</code>文件之后，有时候依然无法实现免密码登录。后来才发现，是因为有些文件的权限放大了。想想也是，如果<code>authorized_keys</code>文件，是其他用户也能编辑的。那岂不是多了个后门，可以帮助其他用户绕到当前用户了。<br>所以重点在于几个关键文件是否把权限集中在自己手上，并且无论如何是不允许其他用户编辑的。<br>总结为以下几条命令<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">chmod 700 ~<span class="string">/.ssh</span></span><br><span class="line">chmod 600 ~<span class="string">/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure></p><p>有时候，光有上面两句还搞不定，我发现还得追加一句<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">755</span> ~</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小诗一首</title>
      <link href="/2018/07/24/%E5%B0%8F%E8%AF%97%E4%B8%80%E9%A6%96/"/>
      <url>/2018/07/24/%E5%B0%8F%E8%AF%97%E4%B8%80%E9%A6%96/</url>
      <content type="html"><![CDATA[<p><img src="/media/DSC04458.jpg" alt=""></p><h3 id="都谓彭城多霾日，"><a href="#都谓彭城多霾日，" class="headerlink" title="都谓彭城多霾日，"></a>都谓彭城多霾日，</h3><h3 id="落笔春城溅靛青。"><a href="#落笔春城溅靛青。" class="headerlink" title="落笔春城溅靛青。"></a>落笔春城溅靛青。</h3><h3 id="天公莫要惜颜色，"><a href="#天公莫要惜颜色，" class="headerlink" title="天公莫要惜颜色，"></a>天公莫要惜颜色，</h3><h3 id="几许蔚蓝伴我行。"><a href="#几许蔚蓝伴我行。" class="headerlink" title="几许蔚蓝伴我行。"></a>几许蔚蓝伴我行。</h3><h4 id="——戊戌年六月偶瞥于徐州"><a href="#——戊戌年六月偶瞥于徐州" class="headerlink" title="——戊戌年六月偶瞥于徐州"></a>——戊戌年六月偶瞥于徐州</h4>]]></content>
      
      <categories>
          
          <category> 文艺中年 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>IntelliJ IDEA在Winodws下Gradle乱码问题</title>
      <link href="/2018/07/23/IntelliJ-IDEA%E5%9C%A8Winodws%E4%B8%8BGradle%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/23/IntelliJ-IDEA%E5%9C%A8Winodws%E4%B8%8BGradle%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>恐怕没有哪个中国程序员没被字符编码的问题坑过吧。本以为把能设置字符集的地方，都设置成<code>UTF-8</code>就不会踩坑。可是现实是残酷的。<br>比如在中文windows系统环境下，如果使用IntelliJ IDEA开发工具，同时跑gradle项目，那就要小心了。<br>需要在<br><code>File | Settings | Build, Execution, Deployment | Gradle</code><br>下，找到<code>Gradle VM options</code>，然后填入配置<code>-Dfile.encoding=UTF-8</code></p><p>还有一种方法，可以通过修改gradle.bat这个文件来实现，改文件通常存放于，<code>GRADLE_HOME</code>下的<code>bin</code>目录，找到<code>set DEFAULT_JVM_OPTS=</code>修改为<br><code>set DEFAULT_JVM_OPTS=&quot;-Dfile.encoding=UTF-8&quot;</code><br>即可。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> gradle </tag>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL里一条SQL统计合计与小计</title>
      <link href="/2018/07/22/PostgreSQL%E9%87%8C%E4%B8%80%E6%9D%A1SQL%E7%BB%9F%E8%AE%A1%E5%90%88%E8%AE%A1%E4%B8%8E%E5%B0%8F%E8%AE%A1/"/>
      <url>/2018/07/22/PostgreSQL%E9%87%8C%E4%B8%80%E6%9D%A1SQL%E7%BB%9F%E8%AE%A1%E5%90%88%E8%AE%A1%E4%B8%8E%E5%B0%8F%E8%AE%A1/</url>
      <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">GROUPING</span>(student) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">THEN</span> <span class="string">'合计'</span></span><br><span class="line">  <span class="keyword">ELSE</span> student <span class="keyword">END</span>,</span><br><span class="line">  <span class="keyword">CASE</span> <span class="keyword">WHEN</span>  <span class="keyword">GROUPING</span>(student) &lt;&gt; <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">GROUPING</span>(course) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">THEN</span> <span class="string">'小计'</span></span><br><span class="line">  <span class="keyword">ELSE</span> course <span class="keyword">END</span>,</span><br><span class="line">  <span class="keyword">sum</span>(score.score)</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (student, course)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">GROUPING</span>(student) <span class="keyword">DESC</span> ,student <span class="keyword">DESC</span>, <span class="keyword">GROUPING</span>(course) <span class="keyword">DESC</span> ,course <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vert.x异步方法转同步</title>
      <link href="/2018/07/21/Vert-x%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E8%BD%AC%E5%90%8C%E6%AD%A5/"/>
      <url>/2018/07/21/Vert-x%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E8%BD%AC%E5%90%8C%E6%AD%A5/</url>
      <content type="html"><![CDATA[<p>以前用Vert.x的时候就有这样的疑问，如果我提供的方法是基于Vert.x异步实现的。如何被一个同步的应用调用呢，比如Spring。当时我一度以为要自己开一个线程，然后不断轮询结果，之后再返回，通过这样，把一个异步的方法，包装成同步的方法。<br>后来在使用<code>vertx-pac4j</code>的时候，无意中看到它源码中，也有我上面说的场景使用。就在<code>org.pac4j.vertx.context.session.VertxSessionStore</code>类的这一段：<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   <span class="keyword">public</span> Session getSession(<span class="keyword">String</span> sessionId) &#123;</span><br><span class="line">       final CompletableFuture&lt;io.vertx.ext.web.Session&gt; vertxSessionFuture = <span class="keyword">new</span> <span class="type">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">       sessionStore.<span class="keyword">get</span>(sessionId, asyncResult -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (asyncResult.succeeded()) &#123;</span><br><span class="line">               vertxSessionFuture.complete(asyncResult.result());</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               vertxSessionFuture.completeExceptionally(asyncResult.cause());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       final CompletableFuture&lt;Session&gt; pac4jSessionFuture = vertxSessionFuture.thenApply(session -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">VertxSession</span>(session);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> pac4jSessionFuture.<span class="keyword">get</span>();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException|ExecutionException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">TechnicalException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>可以明显看到<code>sessionStore.get</code>是的常规的Vert.x异步调用。<br>基于这种应用方式，我尝试用<code>groovy</code>模仿写了一下，效果显著，代码如下：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.vertx.core.Vertx</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">String</span> sayHello() &#123;</span><br><span class="line"></span><br><span class="line">    def future = <span class="keyword">new</span> CompletableFuture()</span><br><span class="line"></span><br><span class="line">    Vertx vertx = Vertx.vertx()</span><br><span class="line">    vertx.setTimer(<span class="number">3000</span>, &#123;</span><br><span class="line">        future.complete(<span class="string">"hello world"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> future.thenApply(&#123;</span><br><span class="line">        <span class="built_in">return</span> it</span><br><span class="line">    &#125;).<span class="built_in">get</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(sayHello())</span><br></pre></td></tr></table></figure></p><p>上面这种写法，主要还是依赖了java1.8的<code>CompletableFuture</code>类，后续我会单独开文章讲解这个类的使用。今天就先到这里吧。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vert.x </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何在cas登录成功页面显示用户名</title>
      <link href="/2018/07/20/%E5%A6%82%E4%BD%95%E5%9C%A8cas%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%94%A8%E6%88%B7%E5%90%8D/"/>
      <url>/2018/07/20/%E5%A6%82%E4%BD%95%E5%9C%A8cas%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%94%A8%E6%88%B7%E5%90%8D/</url>
      <content type="html"><![CDATA[<p><a href="https://www.apereo.org/projects/cas" target="_blank" rel="noopener">CAS</a>这种本来业务场景就很细分，再加上其上古时代存续至今的特质。估计还在用它的公司已经不多了。间接导致，其中文资料比较匮乏。<br>领导说，想再cas成功后的欢迎页，也就是<code>casGenericSuccess.jsp</code>页面，可以显示<code>欢迎:xxx</code>的字样。<br>不得不说，这个需求非常常规。然而不仅cas默认没有实现，甚至翻遍google，都很难找到满意的答案。比较有参考价值的可能就是<a href="https://groups.google.com/forum/#!topic/jasig-cas-user/q_pjYXCe7ko" target="_blank" rel="noopener">google groups</a>上的这篇。居然要借助额外的jar包(还是个已停止维护的)才能实现。不得已，只能自己想办法。<br>现在给出我的思路：</p><ol><li>在<code>deployerConfigContext.xml</code>文件中，找到<code>authenticationHandlers</code>参数，其应该对应一个类。十有八九，那个类是你自己实现的，如果不是，可以自己继承一下原有参数配置的类。</li><li>然后在那个类里的<code>authenticate</code>方法，可以通过追加<code>HttpSession session = RequestContextHolder.getRequestAttributes().getSessionMutex().session as HttpSession</code>这么一行，获取到<code>session</code>，这就嗨皮了。</li><li>可以在<code>authenticate</code>方法需要返回<code>true</code>的时候，之前增加一行<code>session.setAttribute(&quot;username&quot;,balabala);</code>，这样我们就顺利把username塞到<code>session</code>里的</li><li>最后，修改<code>casGenericSuccess.jsp</code>，在需要显示用户名的地方，加入<code>&lt;%=session.getAttribute(&quot;username&quot;)%&gt;</code>，就可以实现在登录成功页面显示用户名了</li><li>如果想显示更复杂数据内容，可以留意下<code>deployerConfigContext.xml</code>里面的<code>credentialsToPrincipalResolvers</code>所对应的类。它的时间节点是判定用户登录成功之后，组织用户信息用的。</li></ol>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS系统使用Shadowsocks搭建代理服务</title>
      <link href="/2018/07/19/CentOS%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8Shadowsocks%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/07/19/CentOS%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8Shadowsocks%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<ol><li>确认pip是否安装，命令<code>pip help</code>，返回如图信息，说明已安装<br><img src="/media/15319616591142.jpg" alt=""><br>如果返回下图，说明未安装<br><img src="/media/15319617008516.jpg" alt=""><br>未安装需要执行以下子步骤：<ul><li><code>yum -y install epel-release</code></li><li><code>yum install python-pip</code></li></ul></li><li>通过pip安装shadowsocks，命令<code>pip install shadowsocks</code></li><li><p>准备shadowsocks的配置文件，找个地方放就行，比如<code>/root/shadowsocks.json</code>，文件内容如下：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"server"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">  <span class="string">"server_port"</span>: <span class="number">1988</span>,</span><br><span class="line">  <span class="string">"local_address"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">  <span class="string">"local_port"</span>: <span class="number">1080</span>,</span><br><span class="line">  <span class="string">"password"</span>: “xyz<span class="string">",</span></span><br><span class="line">  <span class="string">"timeout"</span>: <span class="number">300</span>,</span><br><span class="line">  <span class="string">"method"</span>: <span class="string">"aes-256-cfb"</span>,</span><br><span class="line">  <span class="string">"fast_open"</span>: false,</span><br><span class="line">  <span class="string">"workers"</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中<code>server_port</code>、<code>passoword</code>、<code>method</code>三个参数比较重要，分别对应:代理服务所在端口、链接密码、加密方式，回头要用到。</p></li><li>准备好配置文件之后，就可以启动shadowsocks服务了，命令为<code>ssserver -c /root/shadowsocks.json -d start</code>，至此shadowsocks服务启动完毕，然后就可以用客户端连接了。</li><li>客户端下载地址在都在github上，这里给出最常用的mac版和windows版<ul><li><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">mac</a></li><li><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">windows</a></li></ul></li><li>客户端安装完毕，就可以配置服务器连接了，这里给个参考配置：<br> <img src="/media/15319627604059.jpg" alt=""><br>地址就是服务器所在的地址，备注随意，剩下的三个配置，正好对应上面提过的配置。</li><li>确定shadowsocks client是启动状态，就可以享受不一样的网络了。</li></ol>]]></content>
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用Gradle自动发布程序至Linux服务器</title>
      <link href="/2018/07/18/%E7%94%A8Gradle%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E7%A8%8B%E5%BA%8F%E8%87%B3Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2018/07/18/%E7%94%A8Gradle%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E7%A8%8B%E5%BA%8F%E8%87%B3Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>你的重复劳动，一定能找“人”帮你做，聪明的程序员一定是拒绝重复的。由于公司条件限制，暂时用不上<code>jenkins</code>，先拿<code>gradle</code>救救急也是不错的。今天要实现的是，通过gradle发布静态站点到服务器。这样可以和上回的<a href="http://www.kankanzhijian.com/2018/07/17/用Gradle打包Vue前端程序/">用Gradle打包Vue前端程序</a>保持一定的连贯性。当然本帖拿来发布<code>war</code>包也是ok的。</p><ul><li>首先追加gradle插件，参考写法</li></ul><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">plugins</span> &#123;</span><br><span class="line">    <span class="attribute">id</span> <span class="string">'org.hidetake.ssh'</span> version <span class="string">'2.9.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">  <span class="keyword">repositories</span> &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">'org.hidetake:gradle-ssh-plugin:2.9.0'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply plugin: <span class="string">'org.hidetake.ssh'</span></span><br></pre></td></tr></table></figure></p><ul><li>配置插件</li></ul><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">remotes</span> &#123;</span><br><span class="line">    <span class="section">webServer</span> &#123;</span><br><span class="line">        <span class="attribute">host</span> = <span class="string">'192.168.1.100'</span></span><br><span class="line">        user = <span class="string">'develop'</span></span><br><span class="line">        port = <span class="number">22</span></span><br><span class="line">        password = <span class="string">'xyz'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得密码服务器密码明文写在这里不安全，可以用公钥ssh的方案，那么这里可以用<code>identity = file(&#39;id_rsa&#39;)</code>代替掉<code>password = &#39;xyz&#39;</code></p><ul><li>配置完Gradle SSH Plugin，就可以自己写<code>task</code>实现上传文件了。下面贴段我的</li></ul><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> deployPortal &#123;</span><br><span class="line">    <span class="keyword">group</span> = <span class="string">'release'</span></span><br><span class="line">    dependsOn zipPortal</span><br><span class="line">    <span class="keyword">doLast</span> &#123;</span><br><span class="line">        ssh.run &#123;</span><br><span class="line">            session(remotes.webServer) &#123;</span><br><span class="line">                put <span class="keyword">from</span>: <span class="string">"$buildDir/portal.zip"</span>, <span class="keyword">into</span>: <span class="string">"/home/develop/"</span></span><br><span class="line">                <span class="keyword">def</span> result = execute <span class="string">'unzip -o  /home/develop/portal.zip -d /home/develop/portal/'</span></span><br><span class="line">                <span class="keyword">println</span>(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个task的主要作用就是把压缩好的静态站点上传至服务器，然后再解压缩。重点就两句话，第一句<code>put from: &quot;本地文件&quot;, into: &quot;服务器路径&quot;</code>，实现文件上传功能。第二句<code>execute &#39;执行shell命令&#39;</code>，实现通过shell命令，解压缩文件。</p><ul><li><p>至于中间那句<code>dependsOn zipPortal</code>表示执行发布task之前，先要把文件准备好，这个<code>zipPortal</code>task我是这么写的</p>  <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> zipPortal(type: Zip) &#123;</span><br><span class="line">    dependsOn(<span class="string">':portal:build'</span>)</span><br><span class="line">    <span class="keyword">from</span> <span class="string">'portal/www'</span></span><br><span class="line">    archiveName <span class="string">'portal.zip'</span></span><br><span class="line">    <span class="keyword">destinationDir</span> buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>换句话说，如果你是要上传<code>war</code>包的话，可能就不是<code>dependsOn zipPortal</code>而是<code>dependsOn war</code>了。其他的地方，大同小异。</p></li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用Gradle打包Vue前端程序</title>
      <link href="/2018/07/17/%E7%94%A8Gradle%E6%89%93%E5%8C%85Vue%E5%89%8D%E7%AB%AF%E7%A8%8B%E5%BA%8F/"/>
      <url>/2018/07/17/%E7%94%A8Gradle%E6%89%93%E5%8C%85Vue%E5%89%8D%E7%AB%AF%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>我这边打包和发布程序，属于重度依赖Gradle的状态。所以纵容前端程序游离在这个体系外，不利于团队的整体协作。于是有了这篇文章。<br>其实很简单，首先我们需要一个以Gradle为基石的项目，把前后端项目组织成这样<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">myproject</span><br><span class="line">├── build.gradle</span><br><span class="line">├── frontend</span><br><span class="line">│   ├── build</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── node_modules</span><br><span class="line">│   ├── package.json</span><br><span class="line">│   └── src</span><br><span class="line">├── javaweb</span><br><span class="line">│   ├── build</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   ├── out</span><br><span class="line">│   └── src</span><br><span class="line">└── settings.gradle</span><br></pre></td></tr></table></figure></p><p>其中<code>frontend</code>文件夹就是<code>vue</code>项目的存放路径，我们先在此文件夹中，追加文件<code>build.gradle</code>，放至在package.json隔壁。填上很简单的内容：<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  <span class="built_in">id</span> <span class="string">"com.palantir.npm-run"</span> <span class="built_in">version</span> <span class="string">"0.5.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代表这个项目要用到gradle-npm-run的插件<br>然后修改settings.gradle，追加一行<br><code>include &#39;frontend&#39;</code>，这样gradle就能顺利识别vue前端项目了，并且依靠插件，我们获得了这几个task<br><img src="/media/15317809896046.jpg" alt="-w148"><br>其中<code>build</code>就可以实现通过<code>gradle frontend:build</code>的命令，实现gradle对vue项目的打包了。<br>明天，我将继续讲解，如何用gardle实现像Linux服务器，敬请期待。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> gradle </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux挂载新磁盘（适用阿里云、华为云）</title>
      <link href="/2018/07/16/linux%E6%8C%82%E8%BD%BD%E6%96%B0%E7%A3%81%E7%9B%98%EF%BC%88%E9%80%82%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E3%80%81%E5%8D%8E%E4%B8%BA%E4%BA%91%EF%BC%89/"/>
      <url>/2018/07/16/linux%E6%8C%82%E8%BD%BD%E6%96%B0%E7%A3%81%E7%9B%98%EF%BC%88%E9%80%82%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E3%80%81%E5%8D%8E%E4%B8%BA%E4%BA%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>公司项目用的是华为的云服务器，刚申请了新的硬盘资源，需要手动分区挂载。虽然华为没给啥资料，但是不是还有阿里云嘛。所以结合阿里云的资料。我们就可以在华为云实操一把了。附里云资料地址<a href="https://help.aliyun.com/document_detail/25426.html?spm=a2c4g.11186623.2.4.nTZpwz" target="_blank" rel="noopener">Linux 格式化和挂载数据盘</a></p><ol><li><code>fdisk -l</code>查看服务器是否识别到新硬盘的接入，一般会在最后，返回<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">磁盘 /dev/xvde：<span class="number">536.9</span> GB, <span class="number">536870912000</span> 字节，<span class="number">1048576000</span> 个扇区</span><br><span class="line">Units = 扇区 of <span class="number">1</span> * <span class="number">512</span> = <span class="number">512</span> bytes</span><br><span class="line">扇区大小(逻辑/物理)：<span class="number">512</span> 字节 / <span class="number">512</span> 字节</span><br><span class="line">I/O 大小(最小/最佳)：<span class="number">512</span> 字节 / <span class="number">512</span> 字节</span><br></pre></td></tr></table></figure></li></ol><p>说明识别到一个500多G的硬盘，记录下这个硬盘设备号<code>/dev/xvde</code>(这是个变量，你那里不一定跟我一样)</p><ol start="2"><li><code>fdisk /dev/xvde</code>对上面的新硬盘进行分区操作，这是一个交互式命令，首先输入<code>n</code>，也就是创建新分区的意思，如果就打算分一个区的话，后续就按根据提示输入一路回车，到如下界面：<img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-16%2009.20.59.png" alt="屏幕快照 2018-07-16 09.20.59"><br>此时输入<code>wq</code>将分区表写入磁盘，并退出。会收到提示：<br><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-16%2009.22.56.png" alt="屏幕快照 2018-07-16 09.22.56"></li><li><code>fdisk -l</code>再次执行此命令，可以看到新分区信息（一般在最后）<br><img src="/media/15317042937460.jpg" alt=""></li><li><code>mkfs.ext4 /dev/xvde1</code>将这个分区格式化成ext4文件系统。如图：<br><img src="/media/15317044049926.jpg" alt=""></li><li><code>mount /dev/xvde1 /mnt</code>挂载分区</li><li><code>df -h</code>可以查看到新挂载的分区，此时分区已经可以使用了。但是还没有开机自动挂载，如果要开机自动挂载，还需做第7步</li><li>保险起见，先备份<code>fstab</code>，执行命令<code>cp /etc/fstab /etc/fstab.bak</code>，然后执行<code>echo /dev/xvde1 /mnt ext4 defaults 0 0 &gt;&gt; /etc/fstab</code>。之后即使重启，分区也会自动挂载喽。可以通过<code>df -h</code>看到效果：<br><img src="/media/15317048391668.jpg" alt=""></li></ol>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用了docker之后性能损耗多少？</title>
      <link href="/2018/07/15/%E7%94%A8%E4%BA%86docker%E4%B9%8B%E5%90%8E%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97%E5%A4%9A%E5%B0%91/"/>
      <url>/2018/07/15/%E7%94%A8%E4%BA%86docker%E4%B9%8B%E5%90%8E%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97%E5%A4%9A%E5%B0%91/</url>
      <content type="html"><![CDATA[<p>Docker的一大优势，就是拥有微乎其微的性能损耗，换来良好的硬件资源隔离效果。虽然各大厂商都在主要业务领域使用了Docker，已经从侧面表明Docker的性能损耗不是个什么问题。但是较真的同学，肯定还是想知道Docker到底有没有损耗呢，损耗多少。<br>这里我用PostgreSQL数据库做个简单的对比测试。分别在同一台服务器的Docker内外个各装一个10.3版本的PostgreSQL。然后执行同一个SQL。SQL如下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">with cte as ( <span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">VALUES</span> (uuid_generate_v4(), <span class="string">'xiaoming'</span>,<span class="number">10</span>, <span class="string">'语文'</span>),</span><br><span class="line">      (uuid_generate_v4(), <span class="string">'xiaohong'</span>,<span class="number">12</span>, <span class="string">'数学'</span>),</span><br><span class="line">      (uuid_generate_v4(), <span class="string">'xiaoli'</span>,<span class="number">11</span>, <span class="string">'英语'</span>),</span><br><span class="line">      (uuid_generate_v4(), <span class="string">'xiaozhi'</span>,<span class="number">11</span>, <span class="string">'英语'</span>),</span><br><span class="line">      (uuid_generate_v4(), <span class="string">'xiaoxin'</span>,<span class="number">11</span>, <span class="string">'英语'</span>)</span><br><span class="line">  )</span><br><span class="line">    <span class="keyword">AS</span> tmp (<span class="keyword">id</span>, <span class="keyword">name</span>,age, fav))</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> array_to_json(array_agg(row_to_json(cte)))</span><br><span class="line"><span class="keyword">from</span> cte;</span><br></pre></td></tr></table></figure></p><p>因为不是从硬盘IO，所以这条SQL更贴近于CPU密集型的场景。压测功能是依托JMH开发的，源码已经上传至<a href="https://github.com/aruis/somebenchmark/tree/sqlbench" target="_blank" rel="noopener">https://github.com/aruis/somebenchmark/tree/sqlbench</a>，下面直接看结果：<br><img src="/media/15316574043348.jpg" alt="-w567"><br>可以看到第一行的吞吐量，大概是第二行的95%，亦即是说，在我这个应用场景下，Docker有5%的性能损耗。<br>应该可以给大家做个参考。</p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用JMH做简单的JVM性能测试</title>
      <link href="/2018/07/14/%E7%94%A8JMH%E5%81%9A%E7%AE%80%E5%8D%95%E7%9A%84JVM%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/07/14/%E7%94%A8JMH%E5%81%9A%E7%AE%80%E5%8D%95%E7%9A%84JVM%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>写java也有年头了，有时候遇到对比某几种方法性能的情景，都是自己傻傻的打印<code>new Date()</code>计算时间差。现在想来，这种原始的方式，就跟不会用IDE Debug，只会<code>System.out.println()</code>打印调试没什么区别。<br>这次被人安利<code>JMH</code>，说来惭愧，是我在Twitter上质疑<code>Vert.x</code>采用了效率不高的Json序列化库，影响了其在<a href="https://www.techempower.com/benchmarks/" target="_blank" rel="noopener">techempower</a>的成绩。结果<a href="https://twitter.com/julienviet" target="_blank" rel="noopener">@julienviet</a>神回复我说”you should make a JMH microbenchmark to find out”，所以才有了这篇，利用JMH做Json序列化速度对比的文章。<br>这是测试结果：<br><img src="/media/15315228604634.jpg" alt="-w783"><br>可以看到<code>Vert.x</code>的Json序列化速度还是出类拔萃的，当然，其本质还是实用的<code>jackson</code><br>上代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aruistar.benchmark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aruistar.benchmark.model.User;</span><br><span class="line"><span class="keyword">import</span> com.jsoniter.output.JsonStream;</span><br><span class="line"><span class="keyword">import</span> groovy.json.JsonBuilder;</span><br><span class="line"><span class="keyword">import</span> groovy.json.JsonOutput;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.Benchmark;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonToStringBenchmark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(JsonToStringBenchmark.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .warmupIterations(<span class="number">2</span>)</span><br><span class="line">                .measurementIterations(<span class="number">3</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    @Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsonObjectToBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> User(<span class="string">"Hello, World!"</span>, <span class="string">"tomcat"</span>, <span class="number">10</span>, <span class="string">"angular"</span>, <span class="keyword">true</span>).toBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsonObjectToString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> User(<span class="string">"Hello, World!"</span>, <span class="string">"tomcat"</span>, <span class="number">10</span>, <span class="string">"angular"</span>, <span class="keyword">true</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsonBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> JsonBuilder(<span class="keyword">new</span> User(<span class="string">"Hello, World!"</span>, <span class="string">"tomcat"</span>, <span class="number">10</span>, <span class="string">"angular"</span>, <span class="keyword">true</span>).getMap()).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsonOutput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JsonOutput.toJson(<span class="keyword">new</span> User(<span class="string">"Hello, World!"</span>, <span class="string">"tomcat"</span>, <span class="number">10</span>, <span class="string">"angular"</span>, <span class="keyword">true</span>).getMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsoniter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JsonStream.serialize(<span class="keyword">new</span> User(<span class="string">"Hello, World!"</span>, <span class="string">"tomcat"</span>, <span class="number">10</span>, <span class="string">"angular"</span>, <span class="keyword">true</span>).getMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aruistar.benchmark.model;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.vertx.core.json.JsonObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">JsonObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String username, <span class="keyword">int</span> age, String title, <span class="keyword">boolean</span> bool)</span> </span>&#123;</span><br><span class="line">        put(<span class="string">"name"</span>, name);</span><br><span class="line">        put(<span class="string">"age"</span>, age);</span><br><span class="line">        put(<span class="string">"title"</span>, title);</span><br><span class="line">        put(<span class="string">"bool"</span>, bool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码地址，<a href="https://github.com/aruis/somebenchmark" target="_blank" rel="noopener">https://github.com/aruis/somebenchmark</a></p><p>需要注意的是，如果在IDEA打开，想直接通过main方法启动，需要执行如下步骤<br><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">Do you have org.openjdk.jmh:jmh-generator-annprocess on your classpath?</span><br><span class="line">If yes, <span class="keyword">is</span> annotation processing enabled <span class="built_in">in</span> your IDE? You can find the checkbox under</span><br><span class="line">P<span class="function"><span class="title">references</span> -&gt;</span> B<span class="function"><span class="title">uild</span>, Execution, Deployment -&gt;</span> C<span class="function"><span class="title">ompiler</span> -&gt;</span> Annotation Processors</span><br></pre></td></tr></table></figure></p><ul><li>参考[<a href="https://github.com/artyushov/idea-jmh-plugin/issues/13]" target="_blank" rel="noopener">https://github.com/artyushov/idea-jmh-plugin/issues/13]</a></li></ul>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL数组类型数据一条sql实现翻译</title>
      <link href="/2018/07/13/PostgreSQL%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E4%B8%80%E6%9D%A1sql%E5%AE%9E%E7%8E%B0%E7%BF%BB%E8%AF%91/"/>
      <url>/2018/07/13/PostgreSQL%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E4%B8%80%E6%9D%A1sql%E5%AE%9E%E7%8E%B0%E7%BF%BB%E8%AF%91/</url>
      <content type="html"><![CDATA[<p>PostgreSQL的ARRAY类型是个非常实用的类型。以往在设计“多选”这种业务场景的时候，要么需要设计子表，要么弄个varchar字段，存放<code>1,3,5</code>这种逗号隔开的数据。现在有了原生支持的ARRAY类型，终于可以大胆的把多选的数据id放在这个字段里了。<br>接踵而至的问题是，如何一次性实现数组字段的数据翻译呢。比如实际数据是<code>{1,3,5}</code>，关联查询后，希望看到<code>{红,黄,蓝}</code><br>话不多说，直接上sql<br><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> app_message.id,app_message.ids_at_auth_user__to,</span><br><span class="line">  <span class="built_in">array_agg</span>(auth_user.v_username) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> app_message.id) <span class="keyword">as</span> av_username_at_auth_user</span><br><span class="line"><span class="keyword">from</span> app_message</span><br><span class="line">  <span class="keyword">join</span> auth_user <span class="keyword">on</span> auth_user.id = <span class="keyword">ANY</span> (ids_at_auth_user__to)</span><br></pre></td></tr></table></figure></p><p><code>app_message</code>是个收发消息表，里面<code>ids_at_auth_user__to</code>字段是个ARRAY，存储了<code>auth_user</code>表的若干个id，代表收件箱的人（多人）<br><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-27%2011.41.45.png" alt="屏幕快照 2018-04-27 11.41.45"></p>]]></content>
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
